/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
  storage: Storage,
  align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
  #[inline]
  pub const fn new(storage: Storage) -> Self {
    Self { storage, align: [] }
  }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  #[inline]
  pub fn get_bit(&self, index: usize) -> bool {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = self.storage.as_ref()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    byte & mask == mask
  }
  #[inline]
  pub fn set_bit(&mut self, index: usize, val: bool) {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = &mut self.storage.as_mut()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    if val {
      *byte |= mask;
    } else {
      *byte &= !mask;
    }
  }
  #[inline]
  pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    let mut val = 0;
    for i in 0..(bit_width as usize) {
      if self.get_bit(i + bit_offset) {
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        val |= 1 << index;
      }
    }
    val
  }
  #[inline]
  pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    for i in 0..(bit_width as usize) {
      let mask = 1 << i;
      let val_bit_is_set = val & mask == mask;
      let index = if cfg!(target_endian = "big") {
        bit_width as usize - 1 - i
      } else {
        i
      };
      self.set_bit(index + bit_offset, val_bit_is_set);
    }
  }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
  #[inline]
  pub const fn new() -> Self {
    __IncompleteArrayField(::std::marker::PhantomData, [])
  }
  #[inline]
  pub fn as_ptr(&self) -> *const T {
    self as *const _ as *const T
  }
  #[inline]
  pub fn as_mut_ptr(&mut self) -> *mut T {
    self as *mut _ as *mut T
  }
  #[inline]
  pub unsafe fn as_slice(&self, len: usize) -> &[T] {
    ::std::slice::from_raw_parts(self.as_ptr(), len)
  }
  #[inline]
  pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
    ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
  }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
  fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    fmt.write_str("__IncompleteArrayField")
  }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
  #[inline]
  pub const fn new() -> Self {
    __BindgenUnionField(::std::marker::PhantomData)
  }
  #[inline]
  pub unsafe fn as_ref(&self) -> &T {
    ::std::mem::transmute(self)
  }
  #[inline]
  pub unsafe fn as_mut(&mut self) -> &mut T {
    ::std::mem::transmute(self)
  }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
  #[inline]
  fn default() -> Self {
    Self::new()
  }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
  #[inline]
  fn clone(&self) -> Self {
    Self::new()
  }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
  fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    fmt.write_str("__BindgenUnionField")
  }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
  fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
  fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
    true
  }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const ERROR_SEVERITY_SUCCESS: u32 = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472;
pub const LANG_NEUTRAL: u32 = 0;
pub const ERROR_SUCCESS: u32 = 0;
pub const ERROR_INVALID_FUNCTION: u32 = 1;
pub const ERROR_FILE_NOT_FOUND: u32 = 2;
pub const ERROR_PATH_NOT_FOUND: u32 = 3;
pub const ERROR_TOO_MANY_OPEN_FILES: u32 = 4;
pub const ERROR_ACCESS_DENIED: u32 = 5;
pub const ERROR_INVALID_HANDLE: u32 = 6;
pub const ERROR_ARENA_TRASHED: u32 = 7;
pub const ERROR_NOT_ENOUGH_MEMORY: u32 = 8;
pub const ERROR_INVALID_BLOCK: u32 = 9;
pub const ERROR_BAD_ENVIRONMENT: u32 = 10;
pub const ERROR_BAD_FORMAT: u32 = 11;
pub const ERROR_INVALID_ACCESS: u32 = 12;
pub const ERROR_INVALID_DATA: u32 = 13;
pub const ERROR_OUTOFMEMORY: u32 = 14;
pub const ERROR_INVALID_DRIVE: u32 = 15;
pub const ERROR_CURRENT_DIRECTORY: u32 = 16;
pub const ERROR_NOT_SAME_DEVICE: u32 = 17;
pub const ERROR_NO_MORE_FILES: u32 = 18;
pub const ERROR_WRITE_PROTECT: u32 = 19;
pub const ERROR_BAD_UNIT: u32 = 20;
pub const ERROR_NOT_READY: u32 = 21;
pub const ERROR_BAD_COMMAND: u32 = 22;
pub const ERROR_CRC: u32 = 23;
pub const ERROR_BAD_LENGTH: u32 = 24;
pub const ERROR_SEEK: u32 = 25;
pub const ERROR_NOT_DOS_DISK: u32 = 26;
pub const ERROR_SECTOR_NOT_FOUND: u32 = 27;
pub const ERROR_OUT_OF_PAPER: u32 = 28;
pub const ERROR_WRITE_FAULT: u32 = 29;
pub const ERROR_READ_FAULT: u32 = 30;
pub const ERROR_GEN_FAILURE: u32 = 31;
pub const ERROR_SHARING_VIOLATION: u32 = 32;
pub const ERROR_LOCK_VIOLATION: u32 = 33;
pub const ERROR_WRONG_DISK: u32 = 34;
pub const ERROR_SHARING_BUFFER_EXCEEDED: u32 = 36;
pub const ERROR_HANDLE_EOF: u32 = 38;
pub const ERROR_HANDLE_DISK_FULL: u32 = 39;
pub const ERROR_NOT_SUPPORTED: u32 = 50;
pub const ERROR_REM_NOT_LIST: u32 = 51;
pub const ERROR_DUP_NAME: u32 = 52;
pub const ERROR_BAD_NETPATH: u32 = 53;
pub const ERROR_NETWORK_BUSY: u32 = 54;
pub const ERROR_DEV_NOT_EXIST: u32 = 55;
pub const ERROR_TOO_MANY_CMDS: u32 = 56;
pub const ERROR_ADAP_HDW_ERR: u32 = 57;
pub const ERROR_BAD_NET_RESP: u32 = 58;
pub const ERROR_UNEXP_NET_ERR: u32 = 59;
pub const ERROR_BAD_REM_ADAP: u32 = 60;
pub const ERROR_PRINTQ_FULL: u32 = 61;
pub const ERROR_NO_SPOOL_SPACE: u32 = 62;
pub const ERROR_PRINT_CANCELLED: u32 = 63;
pub const ERROR_NETNAME_DELETED: u32 = 64;
pub const ERROR_NETWORK_ACCESS_DENIED: u32 = 65;
pub const ERROR_BAD_DEV_TYPE: u32 = 66;
pub const ERROR_BAD_NET_NAME: u32 = 67;
pub const ERROR_TOO_MANY_NAMES: u32 = 68;
pub const ERROR_TOO_MANY_SESS: u32 = 69;
pub const ERROR_SHARING_PAUSED: u32 = 70;
pub const ERROR_REQ_NOT_ACCEP: u32 = 71;
pub const ERROR_REDIR_PAUSED: u32 = 72;
pub const ERROR_FILE_EXISTS: u32 = 80;
pub const ERROR_CANNOT_MAKE: u32 = 82;
pub const ERROR_FAIL_I24: u32 = 83;
pub const ERROR_OUT_OF_STRUCTURES: u32 = 84;
pub const ERROR_ALREADY_ASSIGNED: u32 = 85;
pub const ERROR_INVALID_PASSWORD: u32 = 86;
pub const ERROR_INVALID_PARAMETER: u32 = 87;
pub const ERROR_NET_WRITE_FAULT: u32 = 88;
pub const ERROR_NO_PROC_SLOTS: u32 = 89;
pub const ERROR_TOO_MANY_SEMAPHORES: u32 = 100;
pub const ERROR_EXCL_SEM_ALREADY_OWNED: u32 = 101;
pub const ERROR_SEM_IS_SET: u32 = 102;
pub const ERROR_TOO_MANY_SEM_REQUESTS: u32 = 103;
pub const ERROR_INVALID_AT_INTERRUPT_TIME: u32 = 104;
pub const ERROR_SEM_OWNER_DIED: u32 = 105;
pub const ERROR_SEM_USER_LIMIT: u32 = 106;
pub const ERROR_DISK_CHANGE: u32 = 107;
pub const ERROR_DRIVE_LOCKED: u32 = 108;
pub const ERROR_BROKEN_PIPE: u32 = 109;
pub const ERROR_OPEN_FAILED: u32 = 110;
pub const ERROR_BUFFER_OVERFLOW: u32 = 111;
pub const ERROR_DISK_FULL: u32 = 112;
pub const ERROR_NO_MORE_SEARCH_HANDLES: u32 = 113;
pub const ERROR_INVALID_TARGET_HANDLE: u32 = 114;
pub const ERROR_INVALID_CATEGORY: u32 = 117;
pub const ERROR_INVALID_VERIFY_SWITCH: u32 = 118;
pub const ERROR_BAD_DRIVER_LEVEL: u32 = 119;
pub const ERROR_CALL_NOT_IMPLEMENTED: u32 = 120;
pub const ERROR_SEM_TIMEOUT: u32 = 121;
pub const ERROR_INSUFFICIENT_BUFFER: u32 = 122;
pub const ERROR_INVALID_NAME: u32 = 123;
pub const ERROR_INVALID_LEVEL: u32 = 124;
pub const ERROR_NO_VOLUME_LABEL: u32 = 125;
pub const ERROR_MOD_NOT_FOUND: u32 = 126;
pub const ERROR_PROC_NOT_FOUND: u32 = 127;
pub const ERROR_WAIT_NO_CHILDREN: u32 = 128;
pub const ERROR_CHILD_NOT_COMPLETE: u32 = 129;
pub const ERROR_DIRECT_ACCESS_HANDLE: u32 = 130;
pub const ERROR_NEGATIVE_SEEK: u32 = 131;
pub const ERROR_SEEK_ON_DEVICE: u32 = 132;
pub const ERROR_IS_JOIN_TARGET: u32 = 133;
pub const ERROR_IS_JOINED: u32 = 134;
pub const ERROR_IS_SUBSTED: u32 = 135;
pub const ERROR_NOT_JOINED: u32 = 136;
pub const ERROR_NOT_SUBSTED: u32 = 137;
pub const ERROR_JOIN_TO_JOIN: u32 = 138;
pub const ERROR_SUBST_TO_SUBST: u32 = 139;
pub const ERROR_JOIN_TO_SUBST: u32 = 140;
pub const ERROR_SUBST_TO_JOIN: u32 = 141;
pub const ERROR_BUSY_DRIVE: u32 = 142;
pub const ERROR_SAME_DRIVE: u32 = 143;
pub const ERROR_DIR_NOT_ROOT: u32 = 144;
pub const ERROR_DIR_NOT_EMPTY: u32 = 145;
pub const ERROR_IS_SUBST_PATH: u32 = 146;
pub const ERROR_IS_JOIN_PATH: u32 = 147;
pub const ERROR_PATH_BUSY: u32 = 148;
pub const ERROR_IS_SUBST_TARGET: u32 = 149;
pub const ERROR_SYSTEM_TRACE: u32 = 150;
pub const ERROR_INVALID_EVENT_COUNT: u32 = 151;
pub const ERROR_TOO_MANY_MUXWAITERS: u32 = 152;
pub const ERROR_INVALID_LIST_FORMAT: u32 = 153;
pub const ERROR_LABEL_TOO_LONG: u32 = 154;
pub const ERROR_TOO_MANY_TCBS: u32 = 155;
pub const ERROR_SIGNAL_REFUSED: u32 = 156;
pub const ERROR_DISCARDED: u32 = 157;
pub const ERROR_NOT_LOCKED: u32 = 158;
pub const ERROR_BAD_THREADID_ADDR: u32 = 159;
pub const ERROR_BAD_ARGUMENTS: u32 = 160;
pub const ERROR_BAD_PATHNAME: u32 = 161;
pub const ERROR_SIGNAL_PENDING: u32 = 162;
pub const ERROR_MAX_THRDS_REACHED: u32 = 164;
pub const ERROR_LOCK_FAILED: u32 = 167;
pub const ERROR_BUSY: u32 = 170;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS: u32 = 171;
pub const ERROR_CANCEL_VIOLATION: u32 = 173;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED: u32 = 174;
pub const ERROR_INVALID_SEGMENT_NUMBER: u32 = 180;
pub const ERROR_INVALID_ORDINAL: u32 = 182;
pub const ERROR_ALREADY_EXISTS: u32 = 183;
pub const ERROR_INVALID_FLAG_NUMBER: u32 = 186;
pub const ERROR_SEM_NOT_FOUND: u32 = 187;
pub const ERROR_INVALID_STARTING_CODESEG: u32 = 188;
pub const ERROR_INVALID_STACKSEG: u32 = 189;
pub const ERROR_INVALID_MODULETYPE: u32 = 190;
pub const ERROR_INVALID_EXE_SIGNATURE: u32 = 191;
pub const ERROR_EXE_MARKED_INVALID: u32 = 192;
pub const ERROR_BAD_EXE_FORMAT: u32 = 193;
pub const ERROR_ITERATED_DATA_EXCEEDS_64k: u32 = 194;
pub const ERROR_INVALID_MINALLOCSIZE: u32 = 195;
pub const ERROR_DYNLINK_FROM_INVALID_RING: u32 = 196;
pub const ERROR_IOPL_NOT_ENABLED: u32 = 197;
pub const ERROR_INVALID_SEGDPL: u32 = 198;
pub const ERROR_AUTODATASEG_EXCEEDS_64k: u32 = 199;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE: u32 = 200;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM: u32 = 201;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN: u32 = 202;
pub const ERROR_ENVVAR_NOT_FOUND: u32 = 203;
pub const ERROR_NO_SIGNAL_SENT: u32 = 205;
pub const ERROR_FILENAME_EXCED_RANGE: u32 = 206;
pub const ERROR_RING2_STACK_IN_USE: u32 = 207;
pub const ERROR_META_EXPANSION_TOO_LONG: u32 = 208;
pub const ERROR_INVALID_SIGNAL_NUMBER: u32 = 209;
pub const ERROR_THREAD_1_INACTIVE: u32 = 210;
pub const ERROR_LOCKED: u32 = 212;
pub const ERROR_TOO_MANY_MODULES: u32 = 214;
pub const ERROR_NESTING_NOT_ALLOWED: u32 = 215;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH: u32 = 216;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY: u32 = 217;
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY: u32 = 218;
pub const ERROR_FILE_CHECKED_OUT: u32 = 220;
pub const ERROR_CHECKOUT_REQUIRED: u32 = 221;
pub const ERROR_BAD_FILE_TYPE: u32 = 222;
pub const ERROR_FILE_TOO_LARGE: u32 = 223;
pub const ERROR_FORMS_AUTH_REQUIRED: u32 = 224;
pub const ERROR_VIRUS_INFECTED: u32 = 225;
pub const ERROR_VIRUS_DELETED: u32 = 226;
pub const ERROR_PIPE_LOCAL: u32 = 229;
pub const ERROR_BAD_PIPE: u32 = 230;
pub const ERROR_PIPE_BUSY: u32 = 231;
pub const ERROR_NO_DATA: u32 = 232;
pub const ERROR_PIPE_NOT_CONNECTED: u32 = 233;
pub const ERROR_MORE_DATA: u32 = 234;
pub const ERROR_NO_WORK_DONE: u32 = 235;
pub const ERROR_VC_DISCONNECTED: u32 = 240;
pub const ERROR_INVALID_EA_NAME: u32 = 254;
pub const ERROR_EA_LIST_INCONSISTENT: u32 = 255;
pub const ERROR_NO_MORE_ITEMS: u32 = 259;
pub const ERROR_CANNOT_COPY: u32 = 266;
pub const ERROR_DIRECTORY: u32 = 267;
pub const ERROR_EAS_DIDNT_FIT: u32 = 275;
pub const ERROR_EA_FILE_CORRUPT: u32 = 276;
pub const ERROR_EA_TABLE_FULL: u32 = 277;
pub const ERROR_INVALID_EA_HANDLE: u32 = 278;
pub const ERROR_EAS_NOT_SUPPORTED: u32 = 282;
pub const ERROR_NOT_OWNER: u32 = 288;
pub const ERROR_TOO_MANY_POSTS: u32 = 298;
pub const ERROR_PARTIAL_COPY: u32 = 299;
pub const ERROR_OPLOCK_NOT_GRANTED: u32 = 300;
pub const ERROR_INVALID_OPLOCK_PROTOCOL: u32 = 301;
pub const ERROR_DISK_TOO_FRAGMENTED: u32 = 302;
pub const ERROR_DELETE_PENDING: u32 = 303;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING: u32 = 304;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME: u32 = 305;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT: u32 = 306;
pub const ERROR_INVALID_LOCK_RANGE: u32 = 307;
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT: u32 = 308;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED: u32 = 309;
pub const ERROR_INVALID_EXCEPTION_HANDLER: u32 = 310;
pub const ERROR_DUPLICATE_PRIVILEGES: u32 = 311;
pub const ERROR_NO_RANGES_PROCESSED: u32 = 312;
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE: u32 = 313;
pub const ERROR_DISK_RESOURCES_EXHAUSTED: u32 = 314;
pub const ERROR_INVALID_TOKEN: u32 = 315;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED: u32 = 316;
pub const ERROR_MR_MID_NOT_FOUND: u32 = 317;
pub const ERROR_SCOPE_NOT_FOUND: u32 = 318;
pub const ERROR_UNDEFINED_SCOPE: u32 = 319;
pub const ERROR_INVALID_CAP: u32 = 320;
pub const ERROR_DEVICE_UNREACHABLE: u32 = 321;
pub const ERROR_DEVICE_NO_RESOURCES: u32 = 322;
pub const ERROR_DATA_CHECKSUM_ERROR: u32 = 323;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION: u32 = 324;
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED: u32 = 326;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION: u32 = 327;
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST: u32 = 328;
pub const ERROR_OPERATION_IN_PROGRESS: u32 = 329;
pub const ERROR_BAD_DEVICE_PATH: u32 = 330;
pub const ERROR_TOO_MANY_DESCRIPTORS: u32 = 331;
pub const ERROR_SCRUB_DATA_DISABLED: u32 = 332;
pub const ERROR_NOT_REDUNDANT_STORAGE: u32 = 333;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED: u32 = 334;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED: u32 = 335;
pub const ERROR_DIRECTORY_NOT_SUPPORTED: u32 = 336;
pub const ERROR_NOT_READ_FROM_COPY: u32 = 337;
pub const ERROR_FT_WRITE_FAILURE: u32 = 338;
pub const ERROR_FT_DI_SCAN_REQUIRED: u32 = 339;
pub const ERROR_INVALID_KERNEL_INFO_VERSION: u32 = 340;
pub const ERROR_INVALID_PEP_INFO_VERSION: u32 = 341;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED: u32 = 342;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN: u32 = 343;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL: u32 = 344;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH: u32 = 345;
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS: u32 = 346;
pub const ERROR_BLOCK_TOO_MANY_REFERENCES: u32 = 347;
pub const ERROR_MARKED_TO_DISALLOW_WRITES: u32 = 348;
pub const ERROR_ENCLAVE_FAILURE: u32 = 349;
pub const ERROR_FAIL_NOACTION_REBOOT: u32 = 350;
pub const ERROR_FAIL_SHUTDOWN: u32 = 351;
pub const ERROR_FAIL_RESTART: u32 = 352;
pub const ERROR_MAX_SESSIONS_REACHED: u32 = 353;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP: u32 = 354;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL: u32 = 355;
pub const ERROR_EDP_POLICY_DENIES_OPERATION: u32 = 356;
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED: u32 = 357;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT: u32 = 358;
pub const ERROR_DEVICE_IN_MAINTENANCE: u32 = 359;
pub const ERROR_NOT_SUPPORTED_ON_DAX: u32 = 360;
pub const ERROR_DAX_MAPPING_EXISTS: u32 = 361;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING: u32 = 362;
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT: u32 = 363;
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE: u32 = 364;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE: u32 = 365;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH: u32 = 366;
pub const ERROR_CHILD_PROCESS_BLOCKED: u32 = 367;
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE: u32 = 368;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE: u32 = 369;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT: u32 = 370;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY: u32 = 371;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN: u32 = 372;
pub const ERROR_GDI_HANDLE_LEAK: u32 = 373;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS: u32 = 374;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED: u32 = 375;
pub const ERROR_NOT_A_CLOUD_FILE: u32 = 376;
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC: u32 = 377;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED: u32 = 378;
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED: u32 = 379;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST: u32 = 380;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME: u32 = 381;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY: u32 = 382;
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED: u32 = 383;
pub const ERROR_SMB1_NOT_AVAILABLE: u32 = 384;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION: u32 = 385;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED: u32 = 386;
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES: u32 = 387;
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE: u32 = 388;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL: u32 = 389;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT: u32 = 390;
pub const ERROR_CLOUD_FILE_IN_USE: u32 = 391;
pub const ERROR_CLOUD_FILE_PINNED: u32 = 392;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED: u32 = 393;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT: u32 = 394;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED: u32 = 395;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS: u32 = 396;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT: u32 = 397;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED: u32 = 398;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED: u32 = 399;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND: u32 = 400;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND: u32 = 401;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND: u32 = 402;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND: u32 = 403;
pub const ERROR_CLOUD_FILE_PROVIDER_TERMINATED: u32 = 404;
pub const ERROR_NOT_A_CLOUD_SYNC_ROOT: u32 = 405;
pub const ERROR_FILE_PROTECTED_UNDER_DPL: u32 = 406;
pub const ERROR_VOLUME_NOT_CLUSTER_ALIGNED: u32 = 407;
pub const ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND: u32 = 408;
pub const ERROR_APPX_FILE_NOT_ENCRYPTED: u32 = 409;
pub const ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED: u32 = 410;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET: u32 = 411;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE: u32 = 412;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER: u32 = 413;
pub const ERROR_LINUX_SUBSYSTEM_NOT_PRESENT: u32 = 414;
pub const ERROR_FT_READ_FAILURE: u32 = 415;
pub const ERROR_STORAGE_RESERVE_ID_INVALID: u32 = 416;
pub const ERROR_STORAGE_RESERVE_DOES_NOT_EXIST: u32 = 417;
pub const ERROR_STORAGE_RESERVE_ALREADY_EXISTS: u32 = 418;
pub const ERROR_STORAGE_RESERVE_NOT_EMPTY: u32 = 419;
pub const ERROR_NOT_A_DAX_VOLUME: u32 = 420;
pub const ERROR_NOT_DAX_MAPPABLE: u32 = 421;
pub const ERROR_TIME_SENSITIVE_THREAD: u32 = 422;
pub const ERROR_DPL_NOT_SUPPORTED_FOR_USER: u32 = 423;
pub const ERROR_CASE_DIFFERING_NAMES_IN_DIR: u32 = 424;
pub const ERROR_FILE_NOT_SUPPORTED: u32 = 425;
pub const ERROR_CLOUD_FILE_REQUEST_TIMEOUT: u32 = 426;
pub const ERROR_NO_TASK_QUEUE: u32 = 427;
pub const ERROR_SRC_SRV_DLL_LOAD_FAILED: u32 = 428;
pub const ERROR_NOT_SUPPORTED_WITH_BTT: u32 = 429;
pub const ERROR_ENCRYPTION_DISABLED: u32 = 430;
pub const ERROR_ENCRYPTING_METADATA_DISALLOWED: u32 = 431;
pub const ERROR_CANT_CLEAR_ENCRYPTION_FLAG: u32 = 432;
pub const ERROR_NO_SUCH_DEVICE: u32 = 433;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED: u32 = 450;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE: u32 = 451;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED: u32 = 452;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED: u32 = 453;
pub const ERROR_CAPAUTHZ_NO_POLICY: u32 = 454;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED: u32 = 455;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG: u32 = 456;
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY: u32 = 457;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR: u32 = 458;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED: u32 = 459;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH: u32 = 460;
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT: u32 = 480;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT: u32 = 481;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT: u32 = 482;
pub const ERROR_DEVICE_HARDWARE_ERROR: u32 = 483;
pub const ERROR_INVALID_ADDRESS: u32 = 487;
pub const ERROR_VRF_CFG_ENABLED: u32 = 1183;
pub const ERROR_PARTITION_TERMINATING: u32 = 1184;
pub const ERROR_USER_PROFILE_LOAD: u32 = 500;
pub const ERROR_ARITHMETIC_OVERFLOW: u32 = 534;
pub const ERROR_PIPE_CONNECTED: u32 = 535;
pub const ERROR_PIPE_LISTENING: u32 = 536;
pub const ERROR_VERIFIER_STOP: u32 = 537;
pub const ERROR_ABIOS_ERROR: u32 = 538;
pub const ERROR_WX86_WARNING: u32 = 539;
pub const ERROR_WX86_ERROR: u32 = 540;
pub const ERROR_TIMER_NOT_CANCELED: u32 = 541;
pub const ERROR_UNWIND: u32 = 542;
pub const ERROR_BAD_STACK: u32 = 543;
pub const ERROR_INVALID_UNWIND_TARGET: u32 = 544;
pub const ERROR_INVALID_PORT_ATTRIBUTES: u32 = 545;
pub const ERROR_PORT_MESSAGE_TOO_LONG: u32 = 546;
pub const ERROR_INVALID_QUOTA_LOWER: u32 = 547;
pub const ERROR_DEVICE_ALREADY_ATTACHED: u32 = 548;
pub const ERROR_INSTRUCTION_MISALIGNMENT: u32 = 549;
pub const ERROR_PROFILING_NOT_STARTED: u32 = 550;
pub const ERROR_PROFILING_NOT_STOPPED: u32 = 551;
pub const ERROR_COULD_NOT_INTERPRET: u32 = 552;
pub const ERROR_PROFILING_AT_LIMIT: u32 = 553;
pub const ERROR_CANT_WAIT: u32 = 554;
pub const ERROR_CANT_TERMINATE_SELF: u32 = 555;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR: u32 = 556;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR: u32 = 557;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR: u32 = 558;
pub const ERROR_BAD_FUNCTION_TABLE: u32 = 559;
pub const ERROR_NO_GUID_TRANSLATION: u32 = 560;
pub const ERROR_INVALID_LDT_SIZE: u32 = 561;
pub const ERROR_INVALID_LDT_OFFSET: u32 = 563;
pub const ERROR_INVALID_LDT_DESCRIPTOR: u32 = 564;
pub const ERROR_TOO_MANY_THREADS: u32 = 565;
pub const ERROR_THREAD_NOT_IN_PROCESS: u32 = 566;
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED: u32 = 567;
pub const ERROR_LOGON_SERVER_CONFLICT: u32 = 568;
pub const ERROR_SYNCHRONIZATION_REQUIRED: u32 = 569;
pub const ERROR_NET_OPEN_FAILED: u32 = 570;
pub const ERROR_IO_PRIVILEGE_FAILED: u32 = 571;
pub const ERROR_CONTROL_C_EXIT: u32 = 572;
pub const ERROR_MISSING_SYSTEMFILE: u32 = 573;
pub const ERROR_UNHANDLED_EXCEPTION: u32 = 574;
pub const ERROR_APP_INIT_FAILURE: u32 = 575;
pub const ERROR_PAGEFILE_CREATE_FAILED: u32 = 576;
pub const ERROR_INVALID_IMAGE_HASH: u32 = 577;
pub const ERROR_NO_PAGEFILE: u32 = 578;
pub const ERROR_ILLEGAL_FLOAT_CONTEXT: u32 = 579;
pub const ERROR_NO_EVENT_PAIR: u32 = 580;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR: u32 = 581;
pub const ERROR_ILLEGAL_CHARACTER: u32 = 582;
pub const ERROR_UNDEFINED_CHARACTER: u32 = 583;
pub const ERROR_FLOPPY_VOLUME: u32 = 584;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT: u32 = 585;
pub const ERROR_BACKUP_CONTROLLER: u32 = 586;
pub const ERROR_MUTANT_LIMIT_EXCEEDED: u32 = 587;
pub const ERROR_FS_DRIVER_REQUIRED: u32 = 588;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE: u32 = 589;
pub const ERROR_DEBUG_ATTACH_FAILED: u32 = 590;
pub const ERROR_SYSTEM_PROCESS_TERMINATED: u32 = 591;
pub const ERROR_DATA_NOT_ACCEPTED: u32 = 592;
pub const ERROR_VDM_HARD_ERROR: u32 = 593;
pub const ERROR_DRIVER_CANCEL_TIMEOUT: u32 = 594;
pub const ERROR_REPLY_MESSAGE_MISMATCH: u32 = 595;
pub const ERROR_LOST_WRITEBEHIND_DATA: u32 = 596;
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID: u32 = 597;
pub const ERROR_NOT_TINY_STREAM: u32 = 598;
pub const ERROR_STACK_OVERFLOW_READ: u32 = 599;
pub const ERROR_CONVERT_TO_LARGE: u32 = 600;
pub const ERROR_FOUND_OUT_OF_SCOPE: u32 = 601;
pub const ERROR_ALLOCATE_BUCKET: u32 = 602;
pub const ERROR_MARSHALL_OVERFLOW: u32 = 603;
pub const ERROR_INVALID_VARIANT: u32 = 604;
pub const ERROR_BAD_COMPRESSION_BUFFER: u32 = 605;
pub const ERROR_AUDIT_FAILED: u32 = 606;
pub const ERROR_TIMER_RESOLUTION_NOT_SET: u32 = 607;
pub const ERROR_INSUFFICIENT_LOGON_INFO: u32 = 608;
pub const ERROR_BAD_DLL_ENTRYPOINT: u32 = 609;
pub const ERROR_BAD_SERVICE_ENTRYPOINT: u32 = 610;
pub const ERROR_IP_ADDRESS_CONFLICT1: u32 = 611;
pub const ERROR_IP_ADDRESS_CONFLICT2: u32 = 612;
pub const ERROR_REGISTRY_QUOTA_LIMIT: u32 = 613;
pub const ERROR_NO_CALLBACK_ACTIVE: u32 = 614;
pub const ERROR_PWD_TOO_SHORT: u32 = 615;
pub const ERROR_PWD_TOO_RECENT: u32 = 616;
pub const ERROR_PWD_HISTORY_CONFLICT: u32 = 617;
pub const ERROR_UNSUPPORTED_COMPRESSION: u32 = 618;
pub const ERROR_INVALID_HW_PROFILE: u32 = 619;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH: u32 = 620;
pub const ERROR_QUOTA_LIST_INCONSISTENT: u32 = 621;
pub const ERROR_EVALUATION_EXPIRATION: u32 = 622;
pub const ERROR_ILLEGAL_DLL_RELOCATION: u32 = 623;
pub const ERROR_DLL_INIT_FAILED_LOGOFF: u32 = 624;
pub const ERROR_VALIDATE_CONTINUE: u32 = 625;
pub const ERROR_NO_MORE_MATCHES: u32 = 626;
pub const ERROR_RANGE_LIST_CONFLICT: u32 = 627;
pub const ERROR_SERVER_SID_MISMATCH: u32 = 628;
pub const ERROR_CANT_ENABLE_DENY_ONLY: u32 = 629;
pub const ERROR_FLOAT_MULTIPLE_FAULTS: u32 = 630;
pub const ERROR_FLOAT_MULTIPLE_TRAPS: u32 = 631;
pub const ERROR_NOINTERFACE: u32 = 632;
pub const ERROR_DRIVER_FAILED_SLEEP: u32 = 633;
pub const ERROR_CORRUPT_SYSTEM_FILE: u32 = 634;
pub const ERROR_COMMITMENT_MINIMUM: u32 = 635;
pub const ERROR_PNP_RESTART_ENUMERATION: u32 = 636;
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE: u32 = 637;
pub const ERROR_PNP_REBOOT_REQUIRED: u32 = 638;
pub const ERROR_INSUFFICIENT_POWER: u32 = 639;
pub const ERROR_MULTIPLE_FAULT_VIOLATION: u32 = 640;
pub const ERROR_SYSTEM_SHUTDOWN: u32 = 641;
pub const ERROR_PORT_NOT_SET: u32 = 642;
pub const ERROR_DS_VERSION_CHECK_FAILURE: u32 = 643;
pub const ERROR_RANGE_NOT_FOUND: u32 = 644;
pub const ERROR_NOT_SAFE_MODE_DRIVER: u32 = 646;
pub const ERROR_FAILED_DRIVER_ENTRY: u32 = 647;
pub const ERROR_DEVICE_ENUMERATION_ERROR: u32 = 648;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED: u32 = 649;
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER: u32 = 650;
pub const ERROR_MCA_OCCURED: u32 = 651;
pub const ERROR_DRIVER_DATABASE_ERROR: u32 = 652;
pub const ERROR_SYSTEM_HIVE_TOO_LARGE: u32 = 653;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD: u32 = 654;
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE: u32 = 655;
pub const ERROR_HIBERNATION_FAILURE: u32 = 656;
pub const ERROR_PWD_TOO_LONG: u32 = 657;
pub const ERROR_FILE_SYSTEM_LIMITATION: u32 = 665;
pub const ERROR_ASSERTION_FAILURE: u32 = 668;
pub const ERROR_ACPI_ERROR: u32 = 669;
pub const ERROR_WOW_ASSERTION: u32 = 670;
pub const ERROR_PNP_BAD_MPS_TABLE: u32 = 671;
pub const ERROR_PNP_TRANSLATION_FAILED: u32 = 672;
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED: u32 = 673;
pub const ERROR_PNP_INVALID_ID: u32 = 674;
pub const ERROR_WAKE_SYSTEM_DEBUGGER: u32 = 675;
pub const ERROR_HANDLES_CLOSED: u32 = 676;
pub const ERROR_EXTRANEOUS_INFORMATION: u32 = 677;
pub const ERROR_RXACT_COMMIT_NECESSARY: u32 = 678;
pub const ERROR_MEDIA_CHECK: u32 = 679;
pub const ERROR_GUID_SUBSTITUTION_MADE: u32 = 680;
pub const ERROR_STOPPED_ON_SYMLINK: u32 = 681;
pub const ERROR_LONGJUMP: u32 = 682;
pub const ERROR_PLUGPLAY_QUERY_VETOED: u32 = 683;
pub const ERROR_UNWIND_CONSOLIDATE: u32 = 684;
pub const ERROR_REGISTRY_HIVE_RECOVERED: u32 = 685;
pub const ERROR_DLL_MIGHT_BE_INSECURE: u32 = 686;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE: u32 = 687;
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED: u32 = 688;
pub const ERROR_DBG_REPLY_LATER: u32 = 689;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE: u32 = 690;
pub const ERROR_DBG_TERMINATE_THREAD: u32 = 691;
pub const ERROR_DBG_TERMINATE_PROCESS: u32 = 692;
pub const ERROR_DBG_CONTROL_C: u32 = 693;
pub const ERROR_DBG_PRINTEXCEPTION_C: u32 = 694;
pub const ERROR_DBG_RIPEXCEPTION: u32 = 695;
pub const ERROR_DBG_CONTROL_BREAK: u32 = 696;
pub const ERROR_DBG_COMMAND_EXCEPTION: u32 = 697;
pub const ERROR_OBJECT_NAME_EXISTS: u32 = 698;
pub const ERROR_THREAD_WAS_SUSPENDED: u32 = 699;
pub const ERROR_IMAGE_NOT_AT_BASE: u32 = 700;
pub const ERROR_RXACT_STATE_CREATED: u32 = 701;
pub const ERROR_SEGMENT_NOTIFICATION: u32 = 702;
pub const ERROR_BAD_CURRENT_DIRECTORY: u32 = 703;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP: u32 = 704;
pub const ERROR_FT_WRITE_RECOVERY: u32 = 705;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH: u32 = 706;
pub const ERROR_RECEIVE_PARTIAL: u32 = 707;
pub const ERROR_RECEIVE_EXPEDITED: u32 = 708;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED: u32 = 709;
pub const ERROR_EVENT_DONE: u32 = 710;
pub const ERROR_EVENT_PENDING: u32 = 711;
pub const ERROR_CHECKING_FILE_SYSTEM: u32 = 712;
pub const ERROR_FATAL_APP_EXIT: u32 = 713;
pub const ERROR_PREDEFINED_HANDLE: u32 = 714;
pub const ERROR_WAS_UNLOCKED: u32 = 715;
pub const ERROR_SERVICE_NOTIFICATION: u32 = 716;
pub const ERROR_WAS_LOCKED: u32 = 717;
pub const ERROR_LOG_HARD_ERROR: u32 = 718;
pub const ERROR_ALREADY_WIN32: u32 = 719;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE: u32 = 720;
pub const ERROR_NO_YIELD_PERFORMED: u32 = 721;
pub const ERROR_TIMER_RESUME_IGNORED: u32 = 722;
pub const ERROR_ARBITRATION_UNHANDLED: u32 = 723;
pub const ERROR_CARDBUS_NOT_SUPPORTED: u32 = 724;
pub const ERROR_MP_PROCESSOR_MISMATCH: u32 = 725;
pub const ERROR_HIBERNATED: u32 = 726;
pub const ERROR_RESUME_HIBERNATION: u32 = 727;
pub const ERROR_FIRMWARE_UPDATED: u32 = 728;
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES: u32 = 729;
pub const ERROR_WAKE_SYSTEM: u32 = 730;
pub const ERROR_WAIT_1: u32 = 731;
pub const ERROR_WAIT_2: u32 = 732;
pub const ERROR_WAIT_3: u32 = 733;
pub const ERROR_WAIT_63: u32 = 734;
pub const ERROR_ABANDONED_WAIT_0: u32 = 735;
pub const ERROR_ABANDONED_WAIT_63: u32 = 736;
pub const ERROR_USER_APC: u32 = 737;
pub const ERROR_KERNEL_APC: u32 = 738;
pub const ERROR_ALERTED: u32 = 739;
pub const ERROR_ELEVATION_REQUIRED: u32 = 740;
pub const ERROR_REPARSE: u32 = 741;
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS: u32 = 742;
pub const ERROR_VOLUME_MOUNTED: u32 = 743;
pub const ERROR_RXACT_COMMITTED: u32 = 744;
pub const ERROR_NOTIFY_CLEANUP: u32 = 745;
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED: u32 = 746;
pub const ERROR_PAGE_FAULT_TRANSITION: u32 = 747;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO: u32 = 748;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE: u32 = 749;
pub const ERROR_PAGE_FAULT_GUARD_PAGE: u32 = 750;
pub const ERROR_PAGE_FAULT_PAGING_FILE: u32 = 751;
pub const ERROR_CACHE_PAGE_LOCKED: u32 = 752;
pub const ERROR_CRASH_DUMP: u32 = 753;
pub const ERROR_BUFFER_ALL_ZEROS: u32 = 754;
pub const ERROR_REPARSE_OBJECT: u32 = 755;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED: u32 = 756;
pub const ERROR_TRANSLATION_COMPLETE: u32 = 757;
pub const ERROR_NOTHING_TO_TERMINATE: u32 = 758;
pub const ERROR_PROCESS_NOT_IN_JOB: u32 = 759;
pub const ERROR_PROCESS_IN_JOB: u32 = 760;
pub const ERROR_VOLSNAP_HIBERNATE_READY: u32 = 761;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY: u32 = 762;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED: u32 = 763;
pub const ERROR_INTERRUPT_STILL_CONNECTED: u32 = 764;
pub const ERROR_WAIT_FOR_OPLOCK: u32 = 765;
pub const ERROR_DBG_EXCEPTION_HANDLED: u32 = 766;
pub const ERROR_DBG_CONTINUE: u32 = 767;
pub const ERROR_CALLBACK_POP_STACK: u32 = 768;
pub const ERROR_COMPRESSION_DISABLED: u32 = 769;
pub const ERROR_CANTFETCHBACKWARDS: u32 = 770;
pub const ERROR_CANTSCROLLBACKWARDS: u32 = 771;
pub const ERROR_ROWSNOTRELEASED: u32 = 772;
pub const ERROR_BAD_ACCESSOR_FLAGS: u32 = 773;
pub const ERROR_ERRORS_ENCOUNTERED: u32 = 774;
pub const ERROR_NOT_CAPABLE: u32 = 775;
pub const ERROR_REQUEST_OUT_OF_SEQUENCE: u32 = 776;
pub const ERROR_VERSION_PARSE_ERROR: u32 = 777;
pub const ERROR_BADSTARTPOSITION: u32 = 778;
pub const ERROR_MEMORY_HARDWARE: u32 = 779;
pub const ERROR_DISK_REPAIR_DISABLED: u32 = 780;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE: u32 = 781;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION: u32 = 782;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION: u32 = 783;
pub const ERROR_MCA_EXCEPTION: u32 = 784;
pub const ERROR_ACCESS_AUDIT_BY_POLICY: u32 = 785;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY: u32 = 786;
pub const ERROR_ABANDON_HIBERFILE: u32 = 787;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED: u32 = 788;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR: u32 = 789;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR: u32 = 790;
pub const ERROR_BAD_MCFG_TABLE: u32 = 791;
pub const ERROR_DISK_REPAIR_REDIRECTED: u32 = 792;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL: u32 = 793;
pub const ERROR_CORRUPT_LOG_OVERFULL: u32 = 794;
pub const ERROR_CORRUPT_LOG_CORRUPTED: u32 = 795;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE: u32 = 796;
pub const ERROR_CORRUPT_LOG_DELETED_FULL: u32 = 797;
pub const ERROR_CORRUPT_LOG_CLEARED: u32 = 798;
pub const ERROR_ORPHAN_NAME_EXHAUSTED: u32 = 799;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE: u32 = 800;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK: u32 = 801;
pub const ERROR_CANNOT_BREAK_OPLOCK: u32 = 802;
pub const ERROR_OPLOCK_HANDLE_CLOSED: u32 = 803;
pub const ERROR_NO_ACE_CONDITION: u32 = 804;
pub const ERROR_INVALID_ACE_CONDITION: u32 = 805;
pub const ERROR_FILE_HANDLE_REVOKED: u32 = 806;
pub const ERROR_IMAGE_AT_DIFFERENT_BASE: u32 = 807;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE: u32 = 808;
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS: u32 = 809;
pub const ERROR_QUOTA_ACTIVITY: u32 = 810;
pub const ERROR_HANDLE_REVOKED: u32 = 811;
pub const ERROR_CALLBACK_INVOKE_INLINE: u32 = 812;
pub const ERROR_CPU_SET_INVALID: u32 = 813;
pub const ERROR_ENCLAVE_NOT_TERMINATED: u32 = 814;
pub const ERROR_ENCLAVE_VIOLATION: u32 = 815;
pub const ERROR_EA_ACCESS_DENIED: u32 = 994;
pub const ERROR_OPERATION_ABORTED: u32 = 995;
pub const ERROR_IO_INCOMPLETE: u32 = 996;
pub const ERROR_IO_PENDING: u32 = 997;
pub const ERROR_NOACCESS: u32 = 998;
pub const ERROR_SWAPERROR: u32 = 999;
pub const ERROR_STACK_OVERFLOW: u32 = 1001;
pub const ERROR_INVALID_MESSAGE: u32 = 1002;
pub const ERROR_CAN_NOT_COMPLETE: u32 = 1003;
pub const ERROR_INVALID_FLAGS: u32 = 1004;
pub const ERROR_UNRECOGNIZED_VOLUME: u32 = 1005;
pub const ERROR_FILE_INVALID: u32 = 1006;
pub const ERROR_FULLSCREEN_MODE: u32 = 1007;
pub const ERROR_NO_TOKEN: u32 = 1008;
pub const ERROR_BADDB: u32 = 1009;
pub const ERROR_BADKEY: u32 = 1010;
pub const ERROR_CANTOPEN: u32 = 1011;
pub const ERROR_CANTREAD: u32 = 1012;
pub const ERROR_CANTWRITE: u32 = 1013;
pub const ERROR_REGISTRY_RECOVERED: u32 = 1014;
pub const ERROR_REGISTRY_CORRUPT: u32 = 1015;
pub const ERROR_REGISTRY_IO_FAILED: u32 = 1016;
pub const ERROR_NOT_REGISTRY_FILE: u32 = 1017;
pub const ERROR_KEY_DELETED: u32 = 1018;
pub const ERROR_NO_LOG_SPACE: u32 = 1019;
pub const ERROR_KEY_HAS_CHILDREN: u32 = 1020;
pub const ERROR_CHILD_MUST_BE_VOLATILE: u32 = 1021;
pub const ERROR_NOTIFY_ENUM_DIR: u32 = 1022;
pub const ERROR_DEPENDENT_SERVICES_RUNNING: u32 = 1051;
pub const ERROR_INVALID_SERVICE_CONTROL: u32 = 1052;
pub const ERROR_SERVICE_REQUEST_TIMEOUT: u32 = 1053;
pub const ERROR_SERVICE_NO_THREAD: u32 = 1054;
pub const ERROR_SERVICE_DATABASE_LOCKED: u32 = 1055;
pub const ERROR_SERVICE_ALREADY_RUNNING: u32 = 1056;
pub const ERROR_INVALID_SERVICE_ACCOUNT: u32 = 1057;
pub const ERROR_SERVICE_DISABLED: u32 = 1058;
pub const ERROR_CIRCULAR_DEPENDENCY: u32 = 1059;
pub const ERROR_SERVICE_DOES_NOT_EXIST: u32 = 1060;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL: u32 = 1061;
pub const ERROR_SERVICE_NOT_ACTIVE: u32 = 1062;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: u32 = 1063;
pub const ERROR_EXCEPTION_IN_SERVICE: u32 = 1064;
pub const ERROR_DATABASE_DOES_NOT_EXIST: u32 = 1065;
pub const ERROR_SERVICE_SPECIFIC_ERROR: u32 = 1066;
pub const ERROR_PROCESS_ABORTED: u32 = 1067;
pub const ERROR_SERVICE_DEPENDENCY_FAIL: u32 = 1068;
pub const ERROR_SERVICE_LOGON_FAILED: u32 = 1069;
pub const ERROR_SERVICE_START_HANG: u32 = 1070;
pub const ERROR_INVALID_SERVICE_LOCK: u32 = 1071;
pub const ERROR_SERVICE_MARKED_FOR_DELETE: u32 = 1072;
pub const ERROR_SERVICE_EXISTS: u32 = 1073;
pub const ERROR_ALREADY_RUNNING_LKG: u32 = 1074;
pub const ERROR_SERVICE_DEPENDENCY_DELETED: u32 = 1075;
pub const ERROR_BOOT_ALREADY_ACCEPTED: u32 = 1076;
pub const ERROR_SERVICE_NEVER_STARTED: u32 = 1077;
pub const ERROR_DUPLICATE_SERVICE_NAME: u32 = 1078;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT: u32 = 1079;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE: u32 = 1080;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT: u32 = 1081;
pub const ERROR_NO_RECOVERY_PROGRAM: u32 = 1082;
pub const ERROR_SERVICE_NOT_IN_EXE: u32 = 1083;
pub const ERROR_NOT_SAFEBOOT_SERVICE: u32 = 1084;
pub const ERROR_END_OF_MEDIA: u32 = 1100;
pub const ERROR_FILEMARK_DETECTED: u32 = 1101;
pub const ERROR_BEGINNING_OF_MEDIA: u32 = 1102;
pub const ERROR_SETMARK_DETECTED: u32 = 1103;
pub const ERROR_NO_DATA_DETECTED: u32 = 1104;
pub const ERROR_PARTITION_FAILURE: u32 = 1105;
pub const ERROR_INVALID_BLOCK_LENGTH: u32 = 1106;
pub const ERROR_DEVICE_NOT_PARTITIONED: u32 = 1107;
pub const ERROR_UNABLE_TO_LOCK_MEDIA: u32 = 1108;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA: u32 = 1109;
pub const ERROR_MEDIA_CHANGED: u32 = 1110;
pub const ERROR_BUS_RESET: u32 = 1111;
pub const ERROR_NO_MEDIA_IN_DRIVE: u32 = 1112;
pub const ERROR_NO_UNICODE_TRANSLATION: u32 = 1113;
pub const ERROR_DLL_INIT_FAILED: u32 = 1114;
pub const ERROR_SHUTDOWN_IN_PROGRESS: u32 = 1115;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS: u32 = 1116;
pub const ERROR_IO_DEVICE: u32 = 1117;
pub const ERROR_SERIAL_NO_DEVICE: u32 = 1118;
pub const ERROR_IRQ_BUSY: u32 = 1119;
pub const ERROR_MORE_WRITES: u32 = 1120;
pub const ERROR_COUNTER_TIMEOUT: u32 = 1121;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND: u32 = 1122;
pub const ERROR_FLOPPY_WRONG_CYLINDER: u32 = 1123;
pub const ERROR_FLOPPY_UNKNOWN_ERROR: u32 = 1124;
pub const ERROR_FLOPPY_BAD_REGISTERS: u32 = 1125;
pub const ERROR_DISK_RECALIBRATE_FAILED: u32 = 1126;
pub const ERROR_DISK_OPERATION_FAILED: u32 = 1127;
pub const ERROR_DISK_RESET_FAILED: u32 = 1128;
pub const ERROR_EOM_OVERFLOW: u32 = 1129;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY: u32 = 1130;
pub const ERROR_POSSIBLE_DEADLOCK: u32 = 1131;
pub const ERROR_MAPPED_ALIGNMENT: u32 = 1132;
pub const ERROR_SET_POWER_STATE_VETOED: u32 = 1140;
pub const ERROR_SET_POWER_STATE_FAILED: u32 = 1141;
pub const ERROR_TOO_MANY_LINKS: u32 = 1142;
pub const ERROR_OLD_WIN_VERSION: u32 = 1150;
pub const ERROR_APP_WRONG_OS: u32 = 1151;
pub const ERROR_SINGLE_INSTANCE_APP: u32 = 1152;
pub const ERROR_RMODE_APP: u32 = 1153;
pub const ERROR_INVALID_DLL: u32 = 1154;
pub const ERROR_NO_ASSOCIATION: u32 = 1155;
pub const ERROR_DDE_FAIL: u32 = 1156;
pub const ERROR_DLL_NOT_FOUND: u32 = 1157;
pub const ERROR_NO_MORE_USER_HANDLES: u32 = 1158;
pub const ERROR_MESSAGE_SYNC_ONLY: u32 = 1159;
pub const ERROR_SOURCE_ELEMENT_EMPTY: u32 = 1160;
pub const ERROR_DESTINATION_ELEMENT_FULL: u32 = 1161;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS: u32 = 1162;
pub const ERROR_MAGAZINE_NOT_PRESENT: u32 = 1163;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED: u32 = 1164;
pub const ERROR_DEVICE_REQUIRES_CLEANING: u32 = 1165;
pub const ERROR_DEVICE_DOOR_OPEN: u32 = 1166;
pub const ERROR_DEVICE_NOT_CONNECTED: u32 = 1167;
pub const ERROR_NOT_FOUND: u32 = 1168;
pub const ERROR_NO_MATCH: u32 = 1169;
pub const ERROR_SET_NOT_FOUND: u32 = 1170;
pub const ERROR_POINT_NOT_FOUND: u32 = 1171;
pub const ERROR_NO_TRACKING_SERVICE: u32 = 1172;
pub const ERROR_NO_VOLUME_ID: u32 = 1173;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED: u32 = 1175;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT: u32 = 1176;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2: u32 = 1177;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS: u32 = 1178;
pub const ERROR_JOURNAL_NOT_ACTIVE: u32 = 1179;
pub const ERROR_POTENTIAL_FILE_FOUND: u32 = 1180;
pub const ERROR_JOURNAL_ENTRY_DELETED: u32 = 1181;
pub const ERROR_SHUTDOWN_IS_SCHEDULED: u32 = 1190;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON: u32 = 1191;
pub const ERROR_BAD_DEVICE: u32 = 1200;
pub const ERROR_CONNECTION_UNAVAIL: u32 = 1201;
pub const ERROR_DEVICE_ALREADY_REMEMBERED: u32 = 1202;
pub const ERROR_NO_NET_OR_BAD_PATH: u32 = 1203;
pub const ERROR_BAD_PROVIDER: u32 = 1204;
pub const ERROR_CANNOT_OPEN_PROFILE: u32 = 1205;
pub const ERROR_BAD_PROFILE: u32 = 1206;
pub const ERROR_NOT_CONTAINER: u32 = 1207;
pub const ERROR_EXTENDED_ERROR: u32 = 1208;
pub const ERROR_INVALID_GROUPNAME: u32 = 1209;
pub const ERROR_INVALID_COMPUTERNAME: u32 = 1210;
pub const ERROR_INVALID_EVENTNAME: u32 = 1211;
pub const ERROR_INVALID_DOMAINNAME: u32 = 1212;
pub const ERROR_INVALID_SERVICENAME: u32 = 1213;
pub const ERROR_INVALID_NETNAME: u32 = 1214;
pub const ERROR_INVALID_SHARENAME: u32 = 1215;
pub const ERROR_INVALID_PASSWORDNAME: u32 = 1216;
pub const ERROR_INVALID_MESSAGENAME: u32 = 1217;
pub const ERROR_INVALID_MESSAGEDEST: u32 = 1218;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT: u32 = 1219;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED: u32 = 1220;
pub const ERROR_DUP_DOMAINNAME: u32 = 1221;
pub const ERROR_NO_NETWORK: u32 = 1222;
pub const ERROR_CANCELLED: u32 = 1223;
pub const ERROR_USER_MAPPED_FILE: u32 = 1224;
pub const ERROR_CONNECTION_REFUSED: u32 = 1225;
pub const ERROR_GRACEFUL_DISCONNECT: u32 = 1226;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED: u32 = 1227;
pub const ERROR_ADDRESS_NOT_ASSOCIATED: u32 = 1228;
pub const ERROR_CONNECTION_INVALID: u32 = 1229;
pub const ERROR_CONNECTION_ACTIVE: u32 = 1230;
pub const ERROR_NETWORK_UNREACHABLE: u32 = 1231;
pub const ERROR_HOST_UNREACHABLE: u32 = 1232;
pub const ERROR_PROTOCOL_UNREACHABLE: u32 = 1233;
pub const ERROR_PORT_UNREACHABLE: u32 = 1234;
pub const ERROR_REQUEST_ABORTED: u32 = 1235;
pub const ERROR_CONNECTION_ABORTED: u32 = 1236;
pub const ERROR_RETRY: u32 = 1237;
pub const ERROR_CONNECTION_COUNT_LIMIT: u32 = 1238;
pub const ERROR_LOGIN_TIME_RESTRICTION: u32 = 1239;
pub const ERROR_LOGIN_WKSTA_RESTRICTION: u32 = 1240;
pub const ERROR_INCORRECT_ADDRESS: u32 = 1241;
pub const ERROR_ALREADY_REGISTERED: u32 = 1242;
pub const ERROR_SERVICE_NOT_FOUND: u32 = 1243;
pub const ERROR_NOT_AUTHENTICATED: u32 = 1244;
pub const ERROR_NOT_LOGGED_ON: u32 = 1245;
pub const ERROR_CONTINUE: u32 = 1246;
pub const ERROR_ALREADY_INITIALIZED: u32 = 1247;
pub const ERROR_NO_MORE_DEVICES: u32 = 1248;
pub const ERROR_NO_SUCH_SITE: u32 = 1249;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS: u32 = 1250;
pub const ERROR_ONLY_IF_CONNECTED: u32 = 1251;
pub const ERROR_OVERRIDE_NOCHANGES: u32 = 1252;
pub const ERROR_BAD_USER_PROFILE: u32 = 1253;
pub const ERROR_NOT_SUPPORTED_ON_SBS: u32 = 1254;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS: u32 = 1255;
pub const ERROR_HOST_DOWN: u32 = 1256;
pub const ERROR_NON_ACCOUNT_SID: u32 = 1257;
pub const ERROR_NON_DOMAIN_SID: u32 = 1258;
pub const ERROR_APPHELP_BLOCK: u32 = 1259;
pub const ERROR_ACCESS_DISABLED_BY_POLICY: u32 = 1260;
pub const ERROR_REG_NAT_CONSUMPTION: u32 = 1261;
pub const ERROR_CSCSHARE_OFFLINE: u32 = 1262;
pub const ERROR_PKINIT_FAILURE: u32 = 1263;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE: u32 = 1264;
pub const ERROR_DOWNGRADE_DETECTED: u32 = 1265;
pub const ERROR_MACHINE_LOCKED: u32 = 1271;
pub const ERROR_SMB_GUEST_LOGON_BLOCKED: u32 = 1272;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA: u32 = 1273;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED: u32 = 1274;
pub const ERROR_DRIVER_BLOCKED: u32 = 1275;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL: u32 = 1276;
pub const ERROR_ACCESS_DISABLED_WEBBLADE: u32 = 1277;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER: u32 = 1278;
pub const ERROR_RECOVERY_FAILURE: u32 = 1279;
pub const ERROR_ALREADY_FIBER: u32 = 1280;
pub const ERROR_ALREADY_THREAD: u32 = 1281;
pub const ERROR_STACK_BUFFER_OVERRUN: u32 = 1282;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED: u32 = 1283;
pub const ERROR_DEBUGGER_INACTIVE: u32 = 1284;
pub const ERROR_DELAY_LOAD_FAILED: u32 = 1285;
pub const ERROR_VDM_DISALLOWED: u32 = 1286;
pub const ERROR_UNIDENTIFIED_ERROR: u32 = 1287;
pub const ERROR_INVALID_CRUNTIME_PARAMETER: u32 = 1288;
pub const ERROR_BEYOND_VDL: u32 = 1289;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE: u32 = 1290;
pub const ERROR_DRIVER_PROCESS_TERMINATED: u32 = 1291;
pub const ERROR_IMPLEMENTATION_LIMIT: u32 = 1292;
pub const ERROR_PROCESS_IS_PROTECTED: u32 = 1293;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING: u32 = 1294;
pub const ERROR_DISK_QUOTA_EXCEEDED: u32 = 1295;
pub const ERROR_CONTENT_BLOCKED: u32 = 1296;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE: u32 = 1297;
pub const ERROR_APP_HANG: u32 = 1298;
pub const ERROR_INVALID_LABEL: u32 = 1299;
pub const ERROR_NOT_ALL_ASSIGNED: u32 = 1300;
pub const ERROR_SOME_NOT_MAPPED: u32 = 1301;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT: u32 = 1302;
pub const ERROR_LOCAL_USER_SESSION_KEY: u32 = 1303;
pub const ERROR_NULL_LM_PASSWORD: u32 = 1304;
pub const ERROR_UNKNOWN_REVISION: u32 = 1305;
pub const ERROR_REVISION_MISMATCH: u32 = 1306;
pub const ERROR_INVALID_OWNER: u32 = 1307;
pub const ERROR_INVALID_PRIMARY_GROUP: u32 = 1308;
pub const ERROR_NO_IMPERSONATION_TOKEN: u32 = 1309;
pub const ERROR_CANT_DISABLE_MANDATORY: u32 = 1310;
pub const ERROR_NO_LOGON_SERVERS: u32 = 1311;
pub const ERROR_NO_SUCH_LOGON_SESSION: u32 = 1312;
pub const ERROR_NO_SUCH_PRIVILEGE: u32 = 1313;
pub const ERROR_PRIVILEGE_NOT_HELD: u32 = 1314;
pub const ERROR_INVALID_ACCOUNT_NAME: u32 = 1315;
pub const ERROR_USER_EXISTS: u32 = 1316;
pub const ERROR_NO_SUCH_USER: u32 = 1317;
pub const ERROR_GROUP_EXISTS: u32 = 1318;
pub const ERROR_NO_SUCH_GROUP: u32 = 1319;
pub const ERROR_MEMBER_IN_GROUP: u32 = 1320;
pub const ERROR_MEMBER_NOT_IN_GROUP: u32 = 1321;
pub const ERROR_LAST_ADMIN: u32 = 1322;
pub const ERROR_WRONG_PASSWORD: u32 = 1323;
pub const ERROR_ILL_FORMED_PASSWORD: u32 = 1324;
pub const ERROR_PASSWORD_RESTRICTION: u32 = 1325;
pub const ERROR_LOGON_FAILURE: u32 = 1326;
pub const ERROR_ACCOUNT_RESTRICTION: u32 = 1327;
pub const ERROR_INVALID_LOGON_HOURS: u32 = 1328;
pub const ERROR_INVALID_WORKSTATION: u32 = 1329;
pub const ERROR_PASSWORD_EXPIRED: u32 = 1330;
pub const ERROR_ACCOUNT_DISABLED: u32 = 1331;
pub const ERROR_NONE_MAPPED: u32 = 1332;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED: u32 = 1333;
pub const ERROR_LUIDS_EXHAUSTED: u32 = 1334;
pub const ERROR_INVALID_SUB_AUTHORITY: u32 = 1335;
pub const ERROR_INVALID_ACL: u32 = 1336;
pub const ERROR_INVALID_SID: u32 = 1337;
pub const ERROR_INVALID_SECURITY_DESCR: u32 = 1338;
pub const ERROR_BAD_INHERITANCE_ACL: u32 = 1340;
pub const ERROR_SERVER_DISABLED: u32 = 1341;
pub const ERROR_SERVER_NOT_DISABLED: u32 = 1342;
pub const ERROR_INVALID_ID_AUTHORITY: u32 = 1343;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED: u32 = 1344;
pub const ERROR_INVALID_GROUP_ATTRIBUTES: u32 = 1345;
pub const ERROR_BAD_IMPERSONATION_LEVEL: u32 = 1346;
pub const ERROR_CANT_OPEN_ANONYMOUS: u32 = 1347;
pub const ERROR_BAD_VALIDATION_CLASS: u32 = 1348;
pub const ERROR_BAD_TOKEN_TYPE: u32 = 1349;
pub const ERROR_NO_SECURITY_ON_OBJECT: u32 = 1350;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO: u32 = 1351;
pub const ERROR_INVALID_SERVER_STATE: u32 = 1352;
pub const ERROR_INVALID_DOMAIN_STATE: u32 = 1353;
pub const ERROR_INVALID_DOMAIN_ROLE: u32 = 1354;
pub const ERROR_NO_SUCH_DOMAIN: u32 = 1355;
pub const ERROR_DOMAIN_EXISTS: u32 = 1356;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED: u32 = 1357;
pub const ERROR_INTERNAL_DB_CORRUPTION: u32 = 1358;
pub const ERROR_INTERNAL_ERROR: u32 = 1359;
pub const ERROR_GENERIC_NOT_MAPPED: u32 = 1360;
pub const ERROR_BAD_DESCRIPTOR_FORMAT: u32 = 1361;
pub const ERROR_NOT_LOGON_PROCESS: u32 = 1362;
pub const ERROR_LOGON_SESSION_EXISTS: u32 = 1363;
pub const ERROR_NO_SUCH_PACKAGE: u32 = 1364;
pub const ERROR_BAD_LOGON_SESSION_STATE: u32 = 1365;
pub const ERROR_LOGON_SESSION_COLLISION: u32 = 1366;
pub const ERROR_INVALID_LOGON_TYPE: u32 = 1367;
pub const ERROR_CANNOT_IMPERSONATE: u32 = 1368;
pub const ERROR_RXACT_INVALID_STATE: u32 = 1369;
pub const ERROR_RXACT_COMMIT_FAILURE: u32 = 1370;
pub const ERROR_SPECIAL_ACCOUNT: u32 = 1371;
pub const ERROR_SPECIAL_GROUP: u32 = 1372;
pub const ERROR_SPECIAL_USER: u32 = 1373;
pub const ERROR_MEMBERS_PRIMARY_GROUP: u32 = 1374;
pub const ERROR_TOKEN_ALREADY_IN_USE: u32 = 1375;
pub const ERROR_NO_SUCH_ALIAS: u32 = 1376;
pub const ERROR_MEMBER_NOT_IN_ALIAS: u32 = 1377;
pub const ERROR_MEMBER_IN_ALIAS: u32 = 1378;
pub const ERROR_ALIAS_EXISTS: u32 = 1379;
pub const ERROR_LOGON_NOT_GRANTED: u32 = 1380;
pub const ERROR_TOO_MANY_SECRETS: u32 = 1381;
pub const ERROR_SECRET_TOO_LONG: u32 = 1382;
pub const ERROR_INTERNAL_DB_ERROR: u32 = 1383;
pub const ERROR_TOO_MANY_CONTEXT_IDS: u32 = 1384;
pub const ERROR_LOGON_TYPE_NOT_GRANTED: u32 = 1385;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED: u32 = 1386;
pub const ERROR_NO_SUCH_MEMBER: u32 = 1387;
pub const ERROR_INVALID_MEMBER: u32 = 1388;
pub const ERROR_TOO_MANY_SIDS: u32 = 1389;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED: u32 = 1390;
pub const ERROR_NO_INHERITANCE: u32 = 1391;
pub const ERROR_FILE_CORRUPT: u32 = 1392;
pub const ERROR_DISK_CORRUPT: u32 = 1393;
pub const ERROR_NO_USER_SESSION_KEY: u32 = 1394;
pub const ERROR_LICENSE_QUOTA_EXCEEDED: u32 = 1395;
pub const ERROR_WRONG_TARGET_NAME: u32 = 1396;
pub const ERROR_MUTUAL_AUTH_FAILED: u32 = 1397;
pub const ERROR_TIME_SKEW: u32 = 1398;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED: u32 = 1399;
pub const ERROR_INVALID_WINDOW_HANDLE: u32 = 1400;
pub const ERROR_INVALID_MENU_HANDLE: u32 = 1401;
pub const ERROR_INVALID_CURSOR_HANDLE: u32 = 1402;
pub const ERROR_INVALID_ACCEL_HANDLE: u32 = 1403;
pub const ERROR_INVALID_HOOK_HANDLE: u32 = 1404;
pub const ERROR_INVALID_DWP_HANDLE: u32 = 1405;
pub const ERROR_TLW_WITH_WSCHILD: u32 = 1406;
pub const ERROR_CANNOT_FIND_WND_CLASS: u32 = 1407;
pub const ERROR_WINDOW_OF_OTHER_THREAD: u32 = 1408;
pub const ERROR_HOTKEY_ALREADY_REGISTERED: u32 = 1409;
pub const ERROR_CLASS_ALREADY_EXISTS: u32 = 1410;
pub const ERROR_CLASS_DOES_NOT_EXIST: u32 = 1411;
pub const ERROR_CLASS_HAS_WINDOWS: u32 = 1412;
pub const ERROR_INVALID_INDEX: u32 = 1413;
pub const ERROR_INVALID_ICON_HANDLE: u32 = 1414;
pub const ERROR_PRIVATE_DIALOG_INDEX: u32 = 1415;
pub const ERROR_LISTBOX_ID_NOT_FOUND: u32 = 1416;
pub const ERROR_NO_WILDCARD_CHARACTERS: u32 = 1417;
pub const ERROR_CLIPBOARD_NOT_OPEN: u32 = 1418;
pub const ERROR_HOTKEY_NOT_REGISTERED: u32 = 1419;
pub const ERROR_WINDOW_NOT_DIALOG: u32 = 1420;
pub const ERROR_CONTROL_ID_NOT_FOUND: u32 = 1421;
pub const ERROR_INVALID_COMBOBOX_MESSAGE: u32 = 1422;
pub const ERROR_WINDOW_NOT_COMBOBOX: u32 = 1423;
pub const ERROR_INVALID_EDIT_HEIGHT: u32 = 1424;
pub const ERROR_DC_NOT_FOUND: u32 = 1425;
pub const ERROR_INVALID_HOOK_FILTER: u32 = 1426;
pub const ERROR_INVALID_FILTER_PROC: u32 = 1427;
pub const ERROR_HOOK_NEEDS_HMOD: u32 = 1428;
pub const ERROR_GLOBAL_ONLY_HOOK: u32 = 1429;
pub const ERROR_JOURNAL_HOOK_SET: u32 = 1430;
pub const ERROR_HOOK_NOT_INSTALLED: u32 = 1431;
pub const ERROR_INVALID_LB_MESSAGE: u32 = 1432;
pub const ERROR_SETCOUNT_ON_BAD_LB: u32 = 1433;
pub const ERROR_LB_WITHOUT_TABSTOPS: u32 = 1434;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD: u32 = 1435;
pub const ERROR_CHILD_WINDOW_MENU: u32 = 1436;
pub const ERROR_NO_SYSTEM_MENU: u32 = 1437;
pub const ERROR_INVALID_MSGBOX_STYLE: u32 = 1438;
pub const ERROR_INVALID_SPI_VALUE: u32 = 1439;
pub const ERROR_SCREEN_ALREADY_LOCKED: u32 = 1440;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT: u32 = 1441;
pub const ERROR_NOT_CHILD_WINDOW: u32 = 1442;
pub const ERROR_INVALID_GW_COMMAND: u32 = 1443;
pub const ERROR_INVALID_THREAD_ID: u32 = 1444;
pub const ERROR_NON_MDICHILD_WINDOW: u32 = 1445;
pub const ERROR_POPUP_ALREADY_ACTIVE: u32 = 1446;
pub const ERROR_NO_SCROLLBARS: u32 = 1447;
pub const ERROR_INVALID_SCROLLBAR_RANGE: u32 = 1448;
pub const ERROR_INVALID_SHOWWIN_COMMAND: u32 = 1449;
pub const ERROR_NO_SYSTEM_RESOURCES: u32 = 1450;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES: u32 = 1451;
pub const ERROR_PAGED_SYSTEM_RESOURCES: u32 = 1452;
pub const ERROR_WORKING_SET_QUOTA: u32 = 1453;
pub const ERROR_PAGEFILE_QUOTA: u32 = 1454;
pub const ERROR_COMMITMENT_LIMIT: u32 = 1455;
pub const ERROR_MENU_ITEM_NOT_FOUND: u32 = 1456;
pub const ERROR_INVALID_KEYBOARD_HANDLE: u32 = 1457;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED: u32 = 1458;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION: u32 = 1459;
pub const ERROR_TIMEOUT: u32 = 1460;
pub const ERROR_INVALID_MONITOR_HANDLE: u32 = 1461;
pub const ERROR_INCORRECT_SIZE: u32 = 1462;
pub const ERROR_SYMLINK_CLASS_DISABLED: u32 = 1463;
pub const ERROR_SYMLINK_NOT_SUPPORTED: u32 = 1464;
pub const ERROR_XML_PARSE_ERROR: u32 = 1465;
pub const ERROR_XMLDSIG_ERROR: u32 = 1466;
pub const ERROR_RESTART_APPLICATION: u32 = 1467;
pub const ERROR_WRONG_COMPARTMENT: u32 = 1468;
pub const ERROR_AUTHIP_FAILURE: u32 = 1469;
pub const ERROR_NO_NVRAM_RESOURCES: u32 = 1470;
pub const ERROR_NOT_GUI_PROCESS: u32 = 1471;
pub const ERROR_EVENTLOG_FILE_CORRUPT: u32 = 1500;
pub const ERROR_EVENTLOG_CANT_START: u32 = 1501;
pub const ERROR_LOG_FILE_FULL: u32 = 1502;
pub const ERROR_EVENTLOG_FILE_CHANGED: u32 = 1503;
pub const ERROR_CONTAINER_ASSIGNED: u32 = 1504;
pub const ERROR_JOB_NO_CONTAINER: u32 = 1505;
pub const ERROR_INVALID_TASK_NAME: u32 = 1550;
pub const ERROR_INVALID_TASK_INDEX: u32 = 1551;
pub const ERROR_THREAD_ALREADY_IN_TASK: u32 = 1552;
pub const ERROR_INSTALL_SERVICE_FAILURE: u32 = 1601;
pub const ERROR_INSTALL_USEREXIT: u32 = 1602;
pub const ERROR_INSTALL_FAILURE: u32 = 1603;
pub const ERROR_INSTALL_SUSPEND: u32 = 1604;
pub const ERROR_UNKNOWN_PRODUCT: u32 = 1605;
pub const ERROR_UNKNOWN_FEATURE: u32 = 1606;
pub const ERROR_UNKNOWN_COMPONENT: u32 = 1607;
pub const ERROR_UNKNOWN_PROPERTY: u32 = 1608;
pub const ERROR_INVALID_HANDLE_STATE: u32 = 1609;
pub const ERROR_BAD_CONFIGURATION: u32 = 1610;
pub const ERROR_INDEX_ABSENT: u32 = 1611;
pub const ERROR_INSTALL_SOURCE_ABSENT: u32 = 1612;
pub const ERROR_INSTALL_PACKAGE_VERSION: u32 = 1613;
pub const ERROR_PRODUCT_UNINSTALLED: u32 = 1614;
pub const ERROR_BAD_QUERY_SYNTAX: u32 = 1615;
pub const ERROR_INVALID_FIELD: u32 = 1616;
pub const ERROR_DEVICE_REMOVED: u32 = 1617;
pub const ERROR_INSTALL_ALREADY_RUNNING: u32 = 1618;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED: u32 = 1619;
pub const ERROR_INSTALL_PACKAGE_INVALID: u32 = 1620;
pub const ERROR_INSTALL_UI_FAILURE: u32 = 1621;
pub const ERROR_INSTALL_LOG_FAILURE: u32 = 1622;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED: u32 = 1623;
pub const ERROR_INSTALL_TRANSFORM_FAILURE: u32 = 1624;
pub const ERROR_INSTALL_PACKAGE_REJECTED: u32 = 1625;
pub const ERROR_FUNCTION_NOT_CALLED: u32 = 1626;
pub const ERROR_FUNCTION_FAILED: u32 = 1627;
pub const ERROR_INVALID_TABLE: u32 = 1628;
pub const ERROR_DATATYPE_MISMATCH: u32 = 1629;
pub const ERROR_UNSUPPORTED_TYPE: u32 = 1630;
pub const ERROR_CREATE_FAILED: u32 = 1631;
pub const ERROR_INSTALL_TEMP_UNWRITABLE: u32 = 1632;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED: u32 = 1633;
pub const ERROR_INSTALL_NOTUSED: u32 = 1634;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED: u32 = 1635;
pub const ERROR_PATCH_PACKAGE_INVALID: u32 = 1636;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED: u32 = 1637;
pub const ERROR_PRODUCT_VERSION: u32 = 1638;
pub const ERROR_INVALID_COMMAND_LINE: u32 = 1639;
pub const ERROR_INSTALL_REMOTE_DISALLOWED: u32 = 1640;
pub const ERROR_SUCCESS_REBOOT_INITIATED: u32 = 1641;
pub const ERROR_PATCH_TARGET_NOT_FOUND: u32 = 1642;
pub const ERROR_PATCH_PACKAGE_REJECTED: u32 = 1643;
pub const ERROR_INSTALL_TRANSFORM_REJECTED: u32 = 1644;
pub const ERROR_INSTALL_REMOTE_PROHIBITED: u32 = 1645;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED: u32 = 1646;
pub const ERROR_UNKNOWN_PATCH: u32 = 1647;
pub const ERROR_PATCH_NO_SEQUENCE: u32 = 1648;
pub const ERROR_PATCH_REMOVAL_DISALLOWED: u32 = 1649;
pub const ERROR_INVALID_PATCH_XML: u32 = 1650;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT: u32 = 1651;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT: u32 = 1652;
pub const ERROR_FAIL_FAST_EXCEPTION: u32 = 1653;
pub const ERROR_INSTALL_REJECTED: u32 = 1654;
pub const ERROR_DYNAMIC_CODE_BLOCKED: u32 = 1655;
pub const ERROR_NOT_SAME_OBJECT: u32 = 1656;
pub const ERROR_STRICT_CFG_VIOLATION: u32 = 1657;
pub const ERROR_SET_CONTEXT_DENIED: u32 = 1660;
pub const ERROR_CROSS_PARTITION_VIOLATION: u32 = 1661;
pub const ERROR_INVALID_USER_BUFFER: u32 = 1784;
pub const ERROR_UNRECOGNIZED_MEDIA: u32 = 1785;
pub const ERROR_NO_TRUST_LSA_SECRET: u32 = 1786;
pub const ERROR_NO_TRUST_SAM_ACCOUNT: u32 = 1787;
pub const ERROR_TRUSTED_DOMAIN_FAILURE: u32 = 1788;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE: u32 = 1789;
pub const ERROR_TRUST_FAILURE: u32 = 1790;
pub const ERROR_NETLOGON_NOT_STARTED: u32 = 1792;
pub const ERROR_ACCOUNT_EXPIRED: u32 = 1793;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES: u32 = 1794;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED: u32 = 1795;
pub const ERROR_UNKNOWN_PORT: u32 = 1796;
pub const ERROR_UNKNOWN_PRINTER_DRIVER: u32 = 1797;
pub const ERROR_UNKNOWN_PRINTPROCESSOR: u32 = 1798;
pub const ERROR_INVALID_SEPARATOR_FILE: u32 = 1799;
pub const ERROR_INVALID_PRIORITY: u32 = 1800;
pub const ERROR_INVALID_PRINTER_NAME: u32 = 1801;
pub const ERROR_PRINTER_ALREADY_EXISTS: u32 = 1802;
pub const ERROR_INVALID_PRINTER_COMMAND: u32 = 1803;
pub const ERROR_INVALID_DATATYPE: u32 = 1804;
pub const ERROR_INVALID_ENVIRONMENT: u32 = 1805;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT: u32 = 1807;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT: u32 = 1808;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT: u32 = 1809;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT: u32 = 1810;
pub const ERROR_SERVER_HAS_OPEN_HANDLES: u32 = 1811;
pub const ERROR_RESOURCE_DATA_NOT_FOUND: u32 = 1812;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND: u32 = 1813;
pub const ERROR_RESOURCE_NAME_NOT_FOUND: u32 = 1814;
pub const ERROR_RESOURCE_LANG_NOT_FOUND: u32 = 1815;
pub const ERROR_NOT_ENOUGH_QUOTA: u32 = 1816;
pub const ERROR_INVALID_TIME: u32 = 1901;
pub const ERROR_INVALID_FORM_NAME: u32 = 1902;
pub const ERROR_INVALID_FORM_SIZE: u32 = 1903;
pub const ERROR_ALREADY_WAITING: u32 = 1904;
pub const ERROR_PRINTER_DELETED: u32 = 1905;
pub const ERROR_INVALID_PRINTER_STATE: u32 = 1906;
pub const ERROR_PASSWORD_MUST_CHANGE: u32 = 1907;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND: u32 = 1908;
pub const ERROR_ACCOUNT_LOCKED_OUT: u32 = 1909;
pub const ERROR_NO_SITENAME: u32 = 1919;
pub const ERROR_CANT_ACCESS_FILE: u32 = 1920;
pub const ERROR_CANT_RESOLVE_FILENAME: u32 = 1921;
pub const ERROR_KM_DRIVER_BLOCKED: u32 = 1930;
pub const ERROR_CONTEXT_EXPIRED: u32 = 1931;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED: u32 = 1932;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED: u32 = 1933;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED: u32 = 1934;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED: u32 = 1935;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED: u32 = 1936;
pub const ERROR_NTLM_BLOCKED: u32 = 1937;
pub const ERROR_PASSWORD_CHANGE_REQUIRED: u32 = 1938;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION: u32 = 1939;
pub const ERROR_INVALID_PIXEL_FORMAT: u32 = 2000;
pub const ERROR_BAD_DRIVER: u32 = 2001;
pub const ERROR_INVALID_WINDOW_STYLE: u32 = 2002;
pub const ERROR_METAFILE_NOT_SUPPORTED: u32 = 2003;
pub const ERROR_TRANSFORM_NOT_SUPPORTED: u32 = 2004;
pub const ERROR_CLIPPING_NOT_SUPPORTED: u32 = 2005;
pub const ERROR_INVALID_CMM: u32 = 2010;
pub const ERROR_INVALID_PROFILE: u32 = 2011;
pub const ERROR_TAG_NOT_FOUND: u32 = 2012;
pub const ERROR_TAG_NOT_PRESENT: u32 = 2013;
pub const ERROR_DUPLICATE_TAG: u32 = 2014;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE: u32 = 2015;
pub const ERROR_PROFILE_NOT_FOUND: u32 = 2016;
pub const ERROR_INVALID_COLORSPACE: u32 = 2017;
pub const ERROR_ICM_NOT_ENABLED: u32 = 2018;
pub const ERROR_DELETING_ICM_XFORM: u32 = 2019;
pub const ERROR_INVALID_TRANSFORM: u32 = 2020;
pub const ERROR_COLORSPACE_MISMATCH: u32 = 2021;
pub const ERROR_INVALID_COLORINDEX: u32 = 2022;
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE: u32 = 2023;
pub const ERROR_CONNECTED_OTHER_PASSWORD: u32 = 2108;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT: u32 = 2109;
pub const ERROR_BAD_USERNAME: u32 = 2202;
pub const ERROR_NOT_CONNECTED: u32 = 2250;
pub const ERROR_OPEN_FILES: u32 = 2401;
pub const ERROR_ACTIVE_CONNECTIONS: u32 = 2402;
pub const ERROR_DEVICE_IN_USE: u32 = 2404;
pub const ERROR_UNKNOWN_PRINT_MONITOR: u32 = 3000;
pub const ERROR_PRINTER_DRIVER_IN_USE: u32 = 3001;
pub const ERROR_SPOOL_FILE_NOT_FOUND: u32 = 3002;
pub const ERROR_SPL_NO_STARTDOC: u32 = 3003;
pub const ERROR_SPL_NO_ADDJOB: u32 = 3004;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED: u32 = 3005;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED: u32 = 3006;
pub const ERROR_INVALID_PRINT_MONITOR: u32 = 3007;
pub const ERROR_PRINT_MONITOR_IN_USE: u32 = 3008;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED: u32 = 3009;
pub const ERROR_SUCCESS_REBOOT_REQUIRED: u32 = 3010;
pub const ERROR_SUCCESS_RESTART_REQUIRED: u32 = 3011;
pub const ERROR_PRINTER_NOT_FOUND: u32 = 3012;
pub const ERROR_PRINTER_DRIVER_WARNED: u32 = 3013;
pub const ERROR_PRINTER_DRIVER_BLOCKED: u32 = 3014;
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE: u32 = 3015;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND: u32 = 3016;
pub const ERROR_FAIL_REBOOT_REQUIRED: u32 = 3017;
pub const ERROR_FAIL_REBOOT_INITIATED: u32 = 3018;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED: u32 = 3019;
pub const ERROR_PRINT_JOB_RESTART_REQUIRED: u32 = 3020;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST: u32 = 3021;
pub const ERROR_PRINTER_NOT_SHAREABLE: u32 = 3022;
pub const ERROR_REQUEST_PAUSED: u32 = 3050;
pub const ERROR_APPEXEC_CONDITION_NOT_SATISFIED: u32 = 3060;
pub const ERROR_APPEXEC_HANDLE_INVALIDATED: u32 = 3061;
pub const ERROR_APPEXEC_INVALID_HOST_GENERATION: u32 = 3062;
pub const ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION: u32 = 3063;
pub const ERROR_APPEXEC_INVALID_HOST_STATE: u32 = 3064;
pub const ERROR_APPEXEC_NO_DONOR: u32 = 3065;
pub const ERROR_APPEXEC_HOST_ID_MISMATCH: u32 = 3066;
pub const ERROR_APPEXEC_UNKNOWN_USER: u32 = 3067;
pub const ERROR_IO_REISSUE_AS_CACHED: u32 = 3950;
pub const ERROR_WINS_INTERNAL: u32 = 4000;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS: u32 = 4001;
pub const ERROR_STATIC_INIT: u32 = 4002;
pub const ERROR_INC_BACKUP: u32 = 4003;
pub const ERROR_FULL_BACKUP: u32 = 4004;
pub const ERROR_REC_NON_EXISTENT: u32 = 4005;
pub const ERROR_RPL_NOT_ALLOWED: u32 = 4006;
pub const ERROR_DHCP_ADDRESS_CONFLICT: u32 = 4100;
pub const ERROR_WMI_GUID_NOT_FOUND: u32 = 4200;
pub const ERROR_WMI_INSTANCE_NOT_FOUND: u32 = 4201;
pub const ERROR_WMI_ITEMID_NOT_FOUND: u32 = 4202;
pub const ERROR_WMI_TRY_AGAIN: u32 = 4203;
pub const ERROR_WMI_DP_NOT_FOUND: u32 = 4204;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF: u32 = 4205;
pub const ERROR_WMI_ALREADY_ENABLED: u32 = 4206;
pub const ERROR_WMI_GUID_DISCONNECTED: u32 = 4207;
pub const ERROR_WMI_SERVER_UNAVAILABLE: u32 = 4208;
pub const ERROR_WMI_DP_FAILED: u32 = 4209;
pub const ERROR_WMI_INVALID_MOF: u32 = 4210;
pub const ERROR_WMI_INVALID_REGINFO: u32 = 4211;
pub const ERROR_WMI_ALREADY_DISABLED: u32 = 4212;
pub const ERROR_WMI_READ_ONLY: u32 = 4213;
pub const ERROR_WMI_SET_FAILURE: u32 = 4214;
pub const ERROR_NOT_APPCONTAINER: u32 = 4250;
pub const ERROR_APPCONTAINER_REQUIRED: u32 = 4251;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER: u32 = 4252;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH: u32 = 4253;
pub const ERROR_INVALID_MEDIA: u32 = 4300;
pub const ERROR_INVALID_LIBRARY: u32 = 4301;
pub const ERROR_INVALID_MEDIA_POOL: u32 = 4302;
pub const ERROR_DRIVE_MEDIA_MISMATCH: u32 = 4303;
pub const ERROR_MEDIA_OFFLINE: u32 = 4304;
pub const ERROR_LIBRARY_OFFLINE: u32 = 4305;
pub const ERROR_EMPTY: u32 = 4306;
pub const ERROR_NOT_EMPTY: u32 = 4307;
pub const ERROR_MEDIA_UNAVAILABLE: u32 = 4308;
pub const ERROR_RESOURCE_DISABLED: u32 = 4309;
pub const ERROR_INVALID_CLEANER: u32 = 4310;
pub const ERROR_UNABLE_TO_CLEAN: u32 = 4311;
pub const ERROR_OBJECT_NOT_FOUND: u32 = 4312;
pub const ERROR_DATABASE_FAILURE: u32 = 4313;
pub const ERROR_DATABASE_FULL: u32 = 4314;
pub const ERROR_MEDIA_INCOMPATIBLE: u32 = 4315;
pub const ERROR_RESOURCE_NOT_PRESENT: u32 = 4316;
pub const ERROR_INVALID_OPERATION: u32 = 4317;
pub const ERROR_MEDIA_NOT_AVAILABLE: u32 = 4318;
pub const ERROR_DEVICE_NOT_AVAILABLE: u32 = 4319;
pub const ERROR_REQUEST_REFUSED: u32 = 4320;
pub const ERROR_INVALID_DRIVE_OBJECT: u32 = 4321;
pub const ERROR_LIBRARY_FULL: u32 = 4322;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE: u32 = 4323;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM: u32 = 4324;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE: u32 = 4325;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT: u32 = 4326;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT: u32 = 4327;
pub const ERROR_TRANSPORT_FULL: u32 = 4328;
pub const ERROR_CONTROLLING_IEPORT: u32 = 4329;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA: u32 = 4330;
pub const ERROR_CLEANER_SLOT_SET: u32 = 4331;
pub const ERROR_CLEANER_SLOT_NOT_SET: u32 = 4332;
pub const ERROR_CLEANER_CARTRIDGE_SPENT: u32 = 4333;
pub const ERROR_UNEXPECTED_OMID: u32 = 4334;
pub const ERROR_CANT_DELETE_LAST_ITEM: u32 = 4335;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE: u32 = 4336;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES: u32 = 4337;
pub const ERROR_INDIGENOUS_TYPE: u32 = 4338;
pub const ERROR_NO_SUPPORTING_DRIVES: u32 = 4339;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED: u32 = 4340;
pub const ERROR_IEPORT_FULL: u32 = 4341;
pub const ERROR_FILE_OFFLINE: u32 = 4350;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE: u32 = 4351;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR: u32 = 4352;
pub const ERROR_NOT_A_REPARSE_POINT: u32 = 4390;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT: u32 = 4391;
pub const ERROR_INVALID_REPARSE_DATA: u32 = 4392;
pub const ERROR_REPARSE_TAG_INVALID: u32 = 4393;
pub const ERROR_REPARSE_TAG_MISMATCH: u32 = 4394;
pub const ERROR_REPARSE_POINT_ENCOUNTERED: u32 = 4395;
pub const ERROR_APP_DATA_NOT_FOUND: u32 = 4400;
pub const ERROR_APP_DATA_EXPIRED: u32 = 4401;
pub const ERROR_APP_DATA_CORRUPT: u32 = 4402;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED: u32 = 4403;
pub const ERROR_APP_DATA_REBOOT_REQUIRED: u32 = 4404;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED: u32 = 4420;
pub const ERROR_SECUREBOOT_POLICY_VIOLATION: u32 = 4421;
pub const ERROR_SECUREBOOT_INVALID_POLICY: u32 = 4422;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND: u32 = 4423;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED: u32 = 4424;
pub const ERROR_SECUREBOOT_NOT_ENABLED: u32 = 4425;
pub const ERROR_SECUREBOOT_FILE_REPLACED: u32 = 4426;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED: u32 = 4427;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN: u32 = 4428;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION: u32 = 4429;
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH: u32 = 4430;
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED: u32 = 4431;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH: u32 = 4432;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING: u32 = 4433;
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY: u32 = 4434;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY: u32 = 4435;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED: u32 = 4440;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED: u32 = 4441;
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED: u32 = 4442;
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED: u32 = 4443;
pub const ERROR_ALREADY_HAS_STREAM_ID: u32 = 4444;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED: u32 = 4445;
pub const ERROR_WOF_WIM_HEADER_CORRUPT: u32 = 4446;
pub const ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT: u32 = 4447;
pub const ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT: u32 = 4448;
pub const ERROR_VOLUME_NOT_SIS_ENABLED: u32 = 4500;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED: u32 = 4550;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION: u32 = 4551;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY: u32 = 4552;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED: u32 = 4553;
pub const ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES: u32 = 4554;
pub const ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED: u32 = 4555;
pub const ERROR_VSM_NOT_INITIALIZED: u32 = 4560;
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE: u32 = 4561;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED: u32 = 4570;
pub const ERROR_PLATFORM_MANIFEST_INVALID: u32 = 4571;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED: u32 = 4572;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED: u32 = 4573;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND: u32 = 4574;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE: u32 = 4575;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED: u32 = 4576;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS: u32 = 5001;
pub const ERROR_DEPENDENCY_NOT_FOUND: u32 = 5002;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS: u32 = 5003;
pub const ERROR_RESOURCE_NOT_ONLINE: u32 = 5004;
pub const ERROR_HOST_NODE_NOT_AVAILABLE: u32 = 5005;
pub const ERROR_RESOURCE_NOT_AVAILABLE: u32 = 5006;
pub const ERROR_RESOURCE_NOT_FOUND: u32 = 5007;
pub const ERROR_SHUTDOWN_CLUSTER: u32 = 5008;
pub const ERROR_CANT_EVICT_ACTIVE_NODE: u32 = 5009;
pub const ERROR_OBJECT_ALREADY_EXISTS: u32 = 5010;
pub const ERROR_OBJECT_IN_LIST: u32 = 5011;
pub const ERROR_GROUP_NOT_AVAILABLE: u32 = 5012;
pub const ERROR_GROUP_NOT_FOUND: u32 = 5013;
pub const ERROR_GROUP_NOT_ONLINE: u32 = 5014;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER: u32 = 5015;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER: u32 = 5016;
pub const ERROR_RESMON_CREATE_FAILED: u32 = 5017;
pub const ERROR_RESMON_ONLINE_FAILED: u32 = 5018;
pub const ERROR_RESOURCE_ONLINE: u32 = 5019;
pub const ERROR_QUORUM_RESOURCE: u32 = 5020;
pub const ERROR_NOT_QUORUM_CAPABLE: u32 = 5021;
pub const ERROR_CLUSTER_SHUTTING_DOWN: u32 = 5022;
pub const ERROR_INVALID_STATE: u32 = 5023;
pub const ERROR_RESOURCE_PROPERTIES_STORED: u32 = 5024;
pub const ERROR_NOT_QUORUM_CLASS: u32 = 5025;
pub const ERROR_CORE_RESOURCE: u32 = 5026;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED: u32 = 5027;
pub const ERROR_QUORUMLOG_OPEN_FAILED: u32 = 5028;
pub const ERROR_CLUSTERLOG_CORRUPT: u32 = 5029;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE: u32 = 5030;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE: u32 = 5031;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND: u32 = 5032;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE: u32 = 5033;
pub const ERROR_QUORUM_OWNER_ALIVE: u32 = 5034;
pub const ERROR_NETWORK_NOT_AVAILABLE: u32 = 5035;
pub const ERROR_NODE_NOT_AVAILABLE: u32 = 5036;
pub const ERROR_ALL_NODES_NOT_AVAILABLE: u32 = 5037;
pub const ERROR_RESOURCE_FAILED: u32 = 5038;
pub const ERROR_CLUSTER_INVALID_NODE: u32 = 5039;
pub const ERROR_CLUSTER_NODE_EXISTS: u32 = 5040;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS: u32 = 5041;
pub const ERROR_CLUSTER_NODE_NOT_FOUND: u32 = 5042;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND: u32 = 5043;
pub const ERROR_CLUSTER_NETWORK_EXISTS: u32 = 5044;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND: u32 = 5045;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS: u32 = 5046;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND: u32 = 5047;
pub const ERROR_CLUSTER_INVALID_REQUEST: u32 = 5048;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER: u32 = 5049;
pub const ERROR_CLUSTER_NODE_DOWN: u32 = 5050;
pub const ERROR_CLUSTER_NODE_UNREACHABLE: u32 = 5051;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER: u32 = 5052;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS: u32 = 5053;
pub const ERROR_CLUSTER_INVALID_NETWORK: u32 = 5054;
pub const ERROR_CLUSTER_NODE_UP: u32 = 5056;
pub const ERROR_CLUSTER_IPADDR_IN_USE: u32 = 5057;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED: u32 = 5058;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT: u32 = 5059;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL: u32 = 5060;
pub const ERROR_CLUSTER_NODE_ALREADY_UP: u32 = 5061;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN: u32 = 5062;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE: u32 = 5063;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE: u32 = 5064;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER: u32 = 5065;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK: u32 = 5066;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS: u32 = 5067;
pub const ERROR_INVALID_OPERATION_ON_QUORUM: u32 = 5068;
pub const ERROR_DEPENDENCY_NOT_ALLOWED: u32 = 5069;
pub const ERROR_CLUSTER_NODE_PAUSED: u32 = 5070;
pub const ERROR_NODE_CANT_HOST_RESOURCE: u32 = 5071;
pub const ERROR_CLUSTER_NODE_NOT_READY: u32 = 5072;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN: u32 = 5073;
pub const ERROR_CLUSTER_JOIN_ABORTED: u32 = 5074;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS: u32 = 5075;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED: u32 = 5076;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED: u32 = 5077;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND: u32 = 5078;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED: u32 = 5079;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND: u32 = 5080;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED: u32 = 5081;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST: u32 = 5082;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH: u32 = 5083;
pub const ERROR_RESMON_INVALID_STATE: u32 = 5084;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER: u32 = 5085;
pub const ERROR_QUORUM_DISK_NOT_FOUND: u32 = 5086;
pub const ERROR_DATABASE_BACKUP_CORRUPT: u32 = 5087;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT: u32 = 5088;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE: u32 = 5089;
pub const ERROR_NO_ADMIN_ACCESS_POINT: u32 = 5090;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE: u32 = 5890;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND: u32 = 5891;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT: u32 = 5892;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH: u32 = 5893;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP: u32 = 5894;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH: u32 = 5895;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP: u32 = 5896;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH: u32 = 5897;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED: u32 = 5898;
pub const ERROR_CLUSTER_WRONG_OS_VERSION: u32 = 5899;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME: u32 = 5900;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED: u32 = 5901;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED: u32 = 5902;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT: u32 = 5903;
pub const ERROR_CLUSTER_OLD_VERSION: u32 = 5904;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME: u32 = 5905;
pub const ERROR_CLUSTER_NO_NET_ADAPTERS: u32 = 5906;
pub const ERROR_CLUSTER_POISONED: u32 = 5907;
pub const ERROR_CLUSTER_GROUP_MOVING: u32 = 5908;
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY: u32 = 5909;
pub const ERROR_RESOURCE_CALL_TIMED_OUT: u32 = 5910;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS: u32 = 5911;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION: u32 = 5912;
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS: u32 = 5913;
pub const ERROR_CLUSTER_PARTIAL_SEND: u32 = 5914;
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION: u32 = 5915;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION: u32 = 5916;
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT: u32 = 5917;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS: u32 = 5918;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS: u32 = 5919;
pub const ERROR_CLUSTER_NULL_DATA: u32 = 5920;
pub const ERROR_CLUSTER_PARTIAL_READ: u32 = 5921;
pub const ERROR_CLUSTER_PARTIAL_WRITE: u32 = 5922;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA: u32 = 5923;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT: u32 = 5924;
pub const ERROR_CLUSTER_NO_QUORUM: u32 = 5925;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK: u32 = 5926;
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK: u32 = 5927;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP: u32 = 5928;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX: u32 = 5929;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL: u32 = 5930;
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION: u32 = 5931;
pub const ERROR_CLUSTER_NOT_INSTALLED: u32 = 5932;
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE: u32 = 5933;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER: u32 = 5934;
pub const ERROR_CLUSTER_TOO_MANY_NODES: u32 = 5935;
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED: u32 = 5936;
pub const ERROR_NONCORE_GROUPS_FOUND: u32 = 5937;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT: u32 = 5938;
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST: u32 = 5939;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE: u32 = 5940;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE: u32 = 5941;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED: u32 = 5942;
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR: u32 = 5943;
pub const ERROR_CLUSTER_GROUP_BUSY: u32 = 5944;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME: u32 = 5945;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR: u32 = 5946;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE: u32 = 5947;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API: u32 = 5948;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS: u32 = 5949;
pub const ERROR_NON_CSV_PATH: u32 = 5950;
pub const ERROR_CSV_VOLUME_NOT_LOCAL: u32 = 5951;
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING: u32 = 5952;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES: u32 = 5953;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT: u32 = 5954;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL: u32 = 5955;
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING: u32 = 5956;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION: u32 = 5957;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE: u32 = 5958;
pub const ERROR_CLUSTER_GROUP_QUEUED: u32 = 5959;
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS: u32 = 5960;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED: u32 = 5961;
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS: u32 = 5962;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED: u32 = 5963;
pub const ERROR_DISK_NOT_CSV_CAPABLE: u32 = 5964;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE: u32 = 5965;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED: u32 = 5966;
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED: u32 = 5967;
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES: u32 = 5968;
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES: u32 = 5969;
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE: u32 = 5970;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT: u32 = 5971;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE: u32 = 5972;
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS: u32 = 5973;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED: u32 = 5974;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED: u32 = 5975;
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS: u32 = 5976;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE: u32 = 5977;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD: u32 = 5978;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT: u32 = 5979;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER: u32 = 5980;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED: u32 = 5981;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED: u32 = 5982;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED: u32 = 5983;
pub const ERROR_CLUSTER_NODE_ISOLATED: u32 = 5984;
pub const ERROR_CLUSTER_NODE_QUARANTINED: u32 = 5985;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED: u32 = 5986;
pub const ERROR_CLUSTER_SPACE_DEGRADED: u32 = 5987;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED: u32 = 5988;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE: u32 = 5989;
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR: u32 = 5990;
pub const ERROR_GROUPSET_NOT_AVAILABLE: u32 = 5991;
pub const ERROR_GROUPSET_NOT_FOUND: u32 = 5992;
pub const ERROR_GROUPSET_CANT_PROVIDE: u32 = 5993;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND: u32 = 5994;
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY: u32 = 5995;
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION: u32 = 5996;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS: u32 = 5997;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME: u32 = 5998;
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE: u32 = 5999;
pub const ERROR_ENCRYPTION_FAILED: u32 = 6000;
pub const ERROR_DECRYPTION_FAILED: u32 = 6001;
pub const ERROR_FILE_ENCRYPTED: u32 = 6002;
pub const ERROR_NO_RECOVERY_POLICY: u32 = 6003;
pub const ERROR_NO_EFS: u32 = 6004;
pub const ERROR_WRONG_EFS: u32 = 6005;
pub const ERROR_NO_USER_KEYS: u32 = 6006;
pub const ERROR_FILE_NOT_ENCRYPTED: u32 = 6007;
pub const ERROR_NOT_EXPORT_FORMAT: u32 = 6008;
pub const ERROR_FILE_READ_ONLY: u32 = 6009;
pub const ERROR_DIR_EFS_DISALLOWED: u32 = 6010;
pub const ERROR_EFS_SERVER_NOT_TRUSTED: u32 = 6011;
pub const ERROR_BAD_RECOVERY_POLICY: u32 = 6012;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG: u32 = 6013;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS: u32 = 6014;
pub const ERROR_EFS_DISABLED: u32 = 6015;
pub const ERROR_EFS_VERSION_NOT_SUPPORT: u32 = 6016;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE: u32 = 6017;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER: u32 = 6018;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE: u32 = 6019;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE: u32 = 6020;
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE: u32 = 6021;
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION: u32 = 6022;
pub const ERROR_WIP_ENCRYPTION_FAILED: u32 = 6023;
pub const ERROR_NO_BROWSER_SERVERS_FOUND: u32 = 6118;
pub const ERROR_LOG_SECTOR_INVALID: u32 = 6600;
pub const ERROR_LOG_SECTOR_PARITY_INVALID: u32 = 6601;
pub const ERROR_LOG_SECTOR_REMAPPED: u32 = 6602;
pub const ERROR_LOG_BLOCK_INCOMPLETE: u32 = 6603;
pub const ERROR_LOG_INVALID_RANGE: u32 = 6604;
pub const ERROR_LOG_BLOCKS_EXHAUSTED: u32 = 6605;
pub const ERROR_LOG_READ_CONTEXT_INVALID: u32 = 6606;
pub const ERROR_LOG_RESTART_INVALID: u32 = 6607;
pub const ERROR_LOG_BLOCK_VERSION: u32 = 6608;
pub const ERROR_LOG_BLOCK_INVALID: u32 = 6609;
pub const ERROR_LOG_READ_MODE_INVALID: u32 = 6610;
pub const ERROR_LOG_NO_RESTART: u32 = 6611;
pub const ERROR_LOG_METADATA_CORRUPT: u32 = 6612;
pub const ERROR_LOG_METADATA_INVALID: u32 = 6613;
pub const ERROR_LOG_METADATA_INCONSISTENT: u32 = 6614;
pub const ERROR_LOG_RESERVATION_INVALID: u32 = 6615;
pub const ERROR_LOG_CANT_DELETE: u32 = 6616;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED: u32 = 6617;
pub const ERROR_LOG_START_OF_LOG: u32 = 6618;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED: u32 = 6619;
pub const ERROR_LOG_POLICY_NOT_INSTALLED: u32 = 6620;
pub const ERROR_LOG_POLICY_INVALID: u32 = 6621;
pub const ERROR_LOG_POLICY_CONFLICT: u32 = 6622;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL: u32 = 6623;
pub const ERROR_LOG_RECORD_NONEXISTENT: u32 = 6624;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID: u32 = 6625;
pub const ERROR_LOG_SPACE_RESERVED_INVALID: u32 = 6626;
pub const ERROR_LOG_TAIL_INVALID: u32 = 6627;
pub const ERROR_LOG_FULL: u32 = 6628;
pub const ERROR_COULD_NOT_RESIZE_LOG: u32 = 6629;
pub const ERROR_LOG_MULTIPLEXED: u32 = 6630;
pub const ERROR_LOG_DEDICATED: u32 = 6631;
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS: u32 = 6632;
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS: u32 = 6633;
pub const ERROR_LOG_EPHEMERAL: u32 = 6634;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS: u32 = 6635;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED: u32 = 6636;
pub const ERROR_LOG_CLIENT_NOT_REGISTERED: u32 = 6637;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS: u32 = 6638;
pub const ERROR_LOG_CONTAINER_READ_FAILED: u32 = 6639;
pub const ERROR_LOG_CONTAINER_WRITE_FAILED: u32 = 6640;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED: u32 = 6641;
pub const ERROR_LOG_CONTAINER_STATE_INVALID: u32 = 6642;
pub const ERROR_LOG_STATE_INVALID: u32 = 6643;
pub const ERROR_LOG_PINNED: u32 = 6644;
pub const ERROR_LOG_METADATA_FLUSH_FAILED: u32 = 6645;
pub const ERROR_LOG_INCONSISTENT_SECURITY: u32 = 6646;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED: u32 = 6647;
pub const ERROR_LOG_PINNED_RESERVATION: u32 = 6648;
pub const ERROR_INVALID_TRANSACTION: u32 = 6700;
pub const ERROR_TRANSACTION_NOT_ACTIVE: u32 = 6701;
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID: u32 = 6702;
pub const ERROR_TRANSACTION_NOT_REQUESTED: u32 = 6703;
pub const ERROR_TRANSACTION_ALREADY_ABORTED: u32 = 6704;
pub const ERROR_TRANSACTION_ALREADY_COMMITTED: u32 = 6705;
pub const ERROR_TM_INITIALIZATION_FAILED: u32 = 6706;
pub const ERROR_RESOURCEMANAGER_READ_ONLY: u32 = 6707;
pub const ERROR_TRANSACTION_NOT_JOINED: u32 = 6708;
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS: u32 = 6709;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS: u32 = 6710;
pub const ERROR_TRANSACTION_PROPAGATION_FAILED: u32 = 6711;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND: u32 = 6712;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER: u32 = 6713;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID: u32 = 6714;
pub const ERROR_TRANSACTION_NOT_FOUND: u32 = 6715;
pub const ERROR_RESOURCEMANAGER_NOT_FOUND: u32 = 6716;
pub const ERROR_ENLISTMENT_NOT_FOUND: u32 = 6717;
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND: u32 = 6718;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE: u32 = 6719;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION: u32 = 6720;
pub const ERROR_TRANSACTION_NOT_ROOT: u32 = 6721;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED: u32 = 6722;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED: u32 = 6723;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG: u32 = 6724;
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED: u32 = 6725;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED: u32 = 6726;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH: u32 = 6727;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT: u32 = 6728;
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH: u32 = 6729;
pub const ERROR_TRANSACTION_NO_SUPERIOR: u32 = 6730;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE: u32 = 6731;
pub const ERROR_TRANSACTIONAL_CONFLICT: u32 = 6800;
pub const ERROR_RM_NOT_ACTIVE: u32 = 6801;
pub const ERROR_RM_METADATA_CORRUPT: u32 = 6802;
pub const ERROR_DIRECTORY_NOT_RM: u32 = 6803;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE: u32 = 6805;
pub const ERROR_LOG_RESIZE_INVALID_SIZE: u32 = 6806;
pub const ERROR_OBJECT_NO_LONGER_EXISTS: u32 = 6807;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND: u32 = 6808;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID: u32 = 6809;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION: u32 = 6810;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT: u32 = 6811;
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS: u32 = 6812;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH: u32 = 6814;
pub const ERROR_HANDLE_NO_LONGER_VALID: u32 = 6815;
pub const ERROR_NO_TXF_METADATA: u32 = 6816;
pub const ERROR_LOG_CORRUPTION_DETECTED: u32 = 6817;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN: u32 = 6818;
pub const ERROR_RM_DISCONNECTED: u32 = 6819;
pub const ERROR_ENLISTMENT_NOT_SUPERIOR: u32 = 6820;
pub const ERROR_RECOVERY_NOT_NEEDED: u32 = 6821;
pub const ERROR_RM_ALREADY_STARTED: u32 = 6822;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT: u32 = 6823;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY: u32 = 6824;
pub const ERROR_CANT_CROSS_RM_BOUNDARY: u32 = 6825;
pub const ERROR_TXF_DIR_NOT_EMPTY: u32 = 6826;
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST: u32 = 6827;
pub const ERROR_TM_VOLATILE: u32 = 6828;
pub const ERROR_ROLLBACK_TIMER_EXPIRED: u32 = 6829;
pub const ERROR_TXF_ATTRIBUTE_CORRUPT: u32 = 6830;
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION: u32 = 6831;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED: u32 = 6832;
pub const ERROR_LOG_GROWTH_FAILED: u32 = 6833;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE: u32 = 6834;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT: u32 = 6835;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET: u32 = 6836;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION: u32 = 6837;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION: u32 = 6838;
pub const ERROR_TRANSACTIONS_NOT_FROZEN: u32 = 6839;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS: u32 = 6840;
pub const ERROR_NOT_SNAPSHOT_VOLUME: u32 = 6841;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES: u32 = 6842;
pub const ERROR_DATA_LOST_REPAIR: u32 = 6843;
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION: u32 = 6844;
pub const ERROR_TM_IDENTITY_MISMATCH: u32 = 6845;
pub const ERROR_FLOATED_SECTION: u32 = 6846;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK: u32 = 6847;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS: u32 = 6848;
pub const ERROR_BAD_CLUSTERS: u32 = 6849;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION: u32 = 6850;
pub const ERROR_VOLUME_DIRTY: u32 = 6851;
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION: u32 = 6852;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION: u32 = 6853;
pub const ERROR_EXPIRED_HANDLE: u32 = 6854;
pub const ERROR_TRANSACTION_NOT_ENLISTED: u32 = 6855;
pub const ERROR_CTX_WINSTATION_NAME_INVALID: u32 = 7001;
pub const ERROR_CTX_INVALID_PD: u32 = 7002;
pub const ERROR_CTX_PD_NOT_FOUND: u32 = 7003;
pub const ERROR_CTX_WD_NOT_FOUND: u32 = 7004;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY: u32 = 7005;
pub const ERROR_CTX_SERVICE_NAME_COLLISION: u32 = 7006;
pub const ERROR_CTX_CLOSE_PENDING: u32 = 7007;
pub const ERROR_CTX_NO_OUTBUF: u32 = 7008;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND: u32 = 7009;
pub const ERROR_CTX_INVALID_MODEMNAME: u32 = 7010;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR: u32 = 7011;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT: u32 = 7012;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER: u32 = 7013;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE: u32 = 7014;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY: u32 = 7015;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE: u32 = 7016;
pub const ERROR_CTX_TD_ERROR: u32 = 7017;
pub const ERROR_CTX_WINSTATION_NOT_FOUND: u32 = 7022;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS: u32 = 7023;
pub const ERROR_CTX_WINSTATION_BUSY: u32 = 7024;
pub const ERROR_CTX_BAD_VIDEO_MODE: u32 = 7025;
pub const ERROR_CTX_GRAPHICS_INVALID: u32 = 7035;
pub const ERROR_CTX_LOGON_DISABLED: u32 = 7037;
pub const ERROR_CTX_NOT_CONSOLE: u32 = 7038;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT: u32 = 7040;
pub const ERROR_CTX_CONSOLE_DISCONNECT: u32 = 7041;
pub const ERROR_CTX_CONSOLE_CONNECT: u32 = 7042;
pub const ERROR_CTX_SHADOW_DENIED: u32 = 7044;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED: u32 = 7045;
pub const ERROR_CTX_INVALID_WD: u32 = 7049;
pub const ERROR_CTX_SHADOW_INVALID: u32 = 7050;
pub const ERROR_CTX_SHADOW_DISABLED: u32 = 7051;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE: u32 = 7052;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET: u32 = 7053;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE: u32 = 7054;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID: u32 = 7055;
pub const ERROR_CTX_LICENSE_EXPIRED: u32 = 7056;
pub const ERROR_CTX_SHADOW_NOT_RUNNING: u32 = 7057;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE: u32 = 7058;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED: u32 = 7059;
pub const ERROR_CTX_WINSTATIONS_DISABLED: u32 = 7060;
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED: u32 = 7061;
pub const ERROR_CTX_SESSION_IN_USE: u32 = 7062;
pub const ERROR_CTX_NO_FORCE_LOGOFF: u32 = 7063;
pub const ERROR_CTX_ACCOUNT_RESTRICTION: u32 = 7064;
pub const ERROR_RDP_PROTOCOL_ERROR: u32 = 7065;
pub const ERROR_CTX_CDM_CONNECT: u32 = 7066;
pub const ERROR_CTX_CDM_DISCONNECT: u32 = 7067;
pub const ERROR_CTX_SECURITY_LAYER_ERROR: u32 = 7068;
pub const ERROR_TS_INCOMPATIBLE_SESSIONS: u32 = 7069;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR: u32 = 7070;
pub const ERROR_DS_NOT_INSTALLED: u32 = 8200;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY: u32 = 8201;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE: u32 = 8202;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX: u32 = 8203;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED: u32 = 8204;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS: u32 = 8205;
pub const ERROR_DS_BUSY: u32 = 8206;
pub const ERROR_DS_UNAVAILABLE: u32 = 8207;
pub const ERROR_DS_NO_RIDS_ALLOCATED: u32 = 8208;
pub const ERROR_DS_NO_MORE_RIDS: u32 = 8209;
pub const ERROR_DS_INCORRECT_ROLE_OWNER: u32 = 8210;
pub const ERROR_DS_RIDMGR_INIT_ERROR: u32 = 8211;
pub const ERROR_DS_OBJ_CLASS_VIOLATION: u32 = 8212;
pub const ERROR_DS_CANT_ON_NON_LEAF: u32 = 8213;
pub const ERROR_DS_CANT_ON_RDN: u32 = 8214;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS: u32 = 8215;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR: u32 = 8216;
pub const ERROR_DS_GC_NOT_AVAILABLE: u32 = 8217;
pub const ERROR_SHARED_POLICY: u32 = 8218;
pub const ERROR_POLICY_OBJECT_NOT_FOUND: u32 = 8219;
pub const ERROR_POLICY_ONLY_IN_DS: u32 = 8220;
pub const ERROR_PROMOTION_ACTIVE: u32 = 8221;
pub const ERROR_NO_PROMOTION_ACTIVE: u32 = 8222;
pub const ERROR_DS_OPERATIONS_ERROR: u32 = 8224;
pub const ERROR_DS_PROTOCOL_ERROR: u32 = 8225;
pub const ERROR_DS_TIMELIMIT_EXCEEDED: u32 = 8226;
pub const ERROR_DS_SIZELIMIT_EXCEEDED: u32 = 8227;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED: u32 = 8228;
pub const ERROR_DS_COMPARE_FALSE: u32 = 8229;
pub const ERROR_DS_COMPARE_TRUE: u32 = 8230;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED: u32 = 8231;
pub const ERROR_DS_STRONG_AUTH_REQUIRED: u32 = 8232;
pub const ERROR_DS_INAPPROPRIATE_AUTH: u32 = 8233;
pub const ERROR_DS_AUTH_UNKNOWN: u32 = 8234;
pub const ERROR_DS_REFERRAL: u32 = 8235;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION: u32 = 8236;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED: u32 = 8237;
pub const ERROR_DS_INAPPROPRIATE_MATCHING: u32 = 8238;
pub const ERROR_DS_CONSTRAINT_VIOLATION: u32 = 8239;
pub const ERROR_DS_NO_SUCH_OBJECT: u32 = 8240;
pub const ERROR_DS_ALIAS_PROBLEM: u32 = 8241;
pub const ERROR_DS_INVALID_DN_SYNTAX: u32 = 8242;
pub const ERROR_DS_IS_LEAF: u32 = 8243;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM: u32 = 8244;
pub const ERROR_DS_UNWILLING_TO_PERFORM: u32 = 8245;
pub const ERROR_DS_LOOP_DETECT: u32 = 8246;
pub const ERROR_DS_NAMING_VIOLATION: u32 = 8247;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE: u32 = 8248;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS: u32 = 8249;
pub const ERROR_DS_SERVER_DOWN: u32 = 8250;
pub const ERROR_DS_LOCAL_ERROR: u32 = 8251;
pub const ERROR_DS_ENCODING_ERROR: u32 = 8252;
pub const ERROR_DS_DECODING_ERROR: u32 = 8253;
pub const ERROR_DS_FILTER_UNKNOWN: u32 = 8254;
pub const ERROR_DS_PARAM_ERROR: u32 = 8255;
pub const ERROR_DS_NOT_SUPPORTED: u32 = 8256;
pub const ERROR_DS_NO_RESULTS_RETURNED: u32 = 8257;
pub const ERROR_DS_CONTROL_NOT_FOUND: u32 = 8258;
pub const ERROR_DS_CLIENT_LOOP: u32 = 8259;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED: u32 = 8260;
pub const ERROR_DS_SORT_CONTROL_MISSING: u32 = 8261;
pub const ERROR_DS_OFFSET_RANGE_ERROR: u32 = 8262;
pub const ERROR_DS_RIDMGR_DISABLED: u32 = 8263;
pub const ERROR_DS_ROOT_MUST_BE_NC: u32 = 8301;
pub const ERROR_DS_ADD_REPLICA_INHIBITED: u32 = 8302;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA: u32 = 8303;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED: u32 = 8304;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS: u32 = 8305;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA: u32 = 8306;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA: u32 = 8307;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND: u32 = 8308;
pub const ERROR_DS_USER_BUFFER_TO_SMALL: u32 = 8309;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ: u32 = 8310;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION: u32 = 8311;
pub const ERROR_DS_OBJ_TOO_LARGE: u32 = 8312;
pub const ERROR_DS_BAD_INSTANCE_TYPE: u32 = 8313;
pub const ERROR_DS_MASTERDSA_REQUIRED: u32 = 8314;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED: u32 = 8315;
pub const ERROR_DS_MISSING_REQUIRED_ATT: u32 = 8316;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS: u32 = 8317;
pub const ERROR_DS_ATT_ALREADY_EXISTS: u32 = 8318;
pub const ERROR_DS_CANT_ADD_ATT_VALUES: u32 = 8320;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT: u32 = 8321;
pub const ERROR_DS_RANGE_CONSTRAINT: u32 = 8322;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS: u32 = 8323;
pub const ERROR_DS_CANT_REM_MISSING_ATT: u32 = 8324;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL: u32 = 8325;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF: u32 = 8326;
pub const ERROR_DS_NO_CHAINING: u32 = 8327;
pub const ERROR_DS_NO_CHAINED_EVAL: u32 = 8328;
pub const ERROR_DS_NO_PARENT_OBJECT: u32 = 8329;
pub const ERROR_DS_PARENT_IS_AN_ALIAS: u32 = 8330;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS: u32 = 8331;
pub const ERROR_DS_CHILDREN_EXIST: u32 = 8332;
pub const ERROR_DS_OBJ_NOT_FOUND: u32 = 8333;
pub const ERROR_DS_ALIASED_OBJ_MISSING: u32 = 8334;
pub const ERROR_DS_BAD_NAME_SYNTAX: u32 = 8335;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS: u32 = 8336;
pub const ERROR_DS_CANT_DEREF_ALIAS: u32 = 8337;
pub const ERROR_DS_OUT_OF_SCOPE: u32 = 8338;
pub const ERROR_DS_OBJECT_BEING_REMOVED: u32 = 8339;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ: u32 = 8340;
pub const ERROR_DS_GENERIC_ERROR: u32 = 8341;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER: u32 = 8342;
pub const ERROR_DS_CLASS_NOT_DSA: u32 = 8343;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS: u32 = 8344;
pub const ERROR_DS_ILLEGAL_SUPERIOR: u32 = 8345;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM: u32 = 8346;
pub const ERROR_DS_NAME_TOO_MANY_PARTS: u32 = 8347;
pub const ERROR_DS_NAME_TOO_LONG: u32 = 8348;
pub const ERROR_DS_NAME_VALUE_TOO_LONG: u32 = 8349;
pub const ERROR_DS_NAME_UNPARSEABLE: u32 = 8350;
pub const ERROR_DS_NAME_TYPE_UNKNOWN: u32 = 8351;
pub const ERROR_DS_NOT_AN_OBJECT: u32 = 8352;
pub const ERROR_DS_SEC_DESC_TOO_SHORT: u32 = 8353;
pub const ERROR_DS_SEC_DESC_INVALID: u32 = 8354;
pub const ERROR_DS_NO_DELETED_NAME: u32 = 8355;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT: u32 = 8356;
pub const ERROR_DS_NCNAME_MUST_BE_NC: u32 = 8357;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY: u32 = 8358;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE: u32 = 8359;
pub const ERROR_DS_INVALID_DMD: u32 = 8360;
pub const ERROR_DS_OBJ_GUID_EXISTS: u32 = 8361;
pub const ERROR_DS_NOT_ON_BACKLINK: u32 = 8362;
pub const ERROR_DS_NO_CROSSREF_FOR_NC: u32 = 8363;
pub const ERROR_DS_SHUTTING_DOWN: u32 = 8364;
pub const ERROR_DS_UNKNOWN_OPERATION: u32 = 8365;
pub const ERROR_DS_INVALID_ROLE_OWNER: u32 = 8366;
pub const ERROR_DS_COULDNT_CONTACT_FSMO: u32 = 8367;
pub const ERROR_DS_CROSS_NC_DN_RENAME: u32 = 8368;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY: u32 = 8369;
pub const ERROR_DS_REPLICATOR_ONLY: u32 = 8370;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED: u32 = 8371;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS: u32 = 8372;
pub const ERROR_DS_NAME_REFERENCE_INVALID: u32 = 8373;
pub const ERROR_DS_CROSS_REF_EXISTS: u32 = 8374;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF: u32 = 8375;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD: u32 = 8376;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX: u32 = 8377;
pub const ERROR_DS_DUP_RDN: u32 = 8378;
pub const ERROR_DS_DUP_OID: u32 = 8379;
pub const ERROR_DS_DUP_MAPI_ID: u32 = 8380;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID: u32 = 8381;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME: u32 = 8382;
pub const ERROR_DS_SEMANTIC_ATT_TEST: u32 = 8383;
pub const ERROR_DS_SYNTAX_MISMATCH: u32 = 8384;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE: u32 = 8385;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE: u32 = 8386;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE: u32 = 8387;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE: u32 = 8388;
pub const ERROR_DS_AUX_CLS_TEST_FAIL: u32 = 8389;
pub const ERROR_DS_NONEXISTENT_POSS_SUP: u32 = 8390;
pub const ERROR_DS_SUB_CLS_TEST_FAIL: u32 = 8391;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX: u32 = 8392;
pub const ERROR_DS_EXISTS_IN_AUX_CLS: u32 = 8393;
pub const ERROR_DS_EXISTS_IN_SUB_CLS: u32 = 8394;
pub const ERROR_DS_EXISTS_IN_POSS_SUP: u32 = 8395;
pub const ERROR_DS_RECALCSCHEMA_FAILED: u32 = 8396;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED: u32 = 8397;
pub const ERROR_DS_CANT_DELETE: u32 = 8398;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID: u32 = 8399;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX: u32 = 8400;
pub const ERROR_DS_CANT_CACHE_ATT: u32 = 8401;
pub const ERROR_DS_CANT_CACHE_CLASS: u32 = 8402;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE: u32 = 8403;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE: u32 = 8404;
pub const ERROR_DS_CANT_RETRIEVE_DN: u32 = 8405;
pub const ERROR_DS_MISSING_SUPREF: u32 = 8406;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE: u32 = 8407;
pub const ERROR_DS_CODE_INCONSISTENCY: u32 = 8408;
pub const ERROR_DS_DATABASE_ERROR: u32 = 8409;
pub const ERROR_DS_GOVERNSID_MISSING: u32 = 8410;
pub const ERROR_DS_MISSING_EXPECTED_ATT: u32 = 8411;
pub const ERROR_DS_NCNAME_MISSING_CR_REF: u32 = 8412;
pub const ERROR_DS_SECURITY_CHECKING_ERROR: u32 = 8413;
pub const ERROR_DS_SCHEMA_NOT_LOADED: u32 = 8414;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED: u32 = 8415;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX: u32 = 8416;
pub const ERROR_DS_GCVERIFY_ERROR: u32 = 8417;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH: u32 = 8418;
pub const ERROR_DS_CANT_FIND_DSA_OBJ: u32 = 8419;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC: u32 = 8420;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE: u32 = 8421;
pub const ERROR_DS_CANT_RETRIEVE_CHILD: u32 = 8422;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY: u32 = 8423;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC: u32 = 8424;
pub const ERROR_DS_BAD_HIERARCHY_FILE: u32 = 8425;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED: u32 = 8426;
pub const ERROR_DS_CONFIG_PARAM_MISSING: u32 = 8427;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED: u32 = 8428;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED: u32 = 8429;
pub const ERROR_DS_INTERNAL_FAILURE: u32 = 8430;
pub const ERROR_DS_UNKNOWN_ERROR: u32 = 8431;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP: u32 = 8432;
pub const ERROR_DS_REFUSING_FSMO_ROLES: u32 = 8433;
pub const ERROR_DS_MISSING_FSMO_SETTINGS: u32 = 8434;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES: u32 = 8435;
pub const ERROR_DS_DRA_GENERIC: u32 = 8436;
pub const ERROR_DS_DRA_INVALID_PARAMETER: u32 = 8437;
pub const ERROR_DS_DRA_BUSY: u32 = 8438;
pub const ERROR_DS_DRA_BAD_DN: u32 = 8439;
pub const ERROR_DS_DRA_BAD_NC: u32 = 8440;
pub const ERROR_DS_DRA_DN_EXISTS: u32 = 8441;
pub const ERROR_DS_DRA_INTERNAL_ERROR: u32 = 8442;
pub const ERROR_DS_DRA_INCONSISTENT_DIT: u32 = 8443;
pub const ERROR_DS_DRA_CONNECTION_FAILED: u32 = 8444;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE: u32 = 8445;
pub const ERROR_DS_DRA_OUT_OF_MEM: u32 = 8446;
pub const ERROR_DS_DRA_MAIL_PROBLEM: u32 = 8447;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS: u32 = 8448;
pub const ERROR_DS_DRA_REF_NOT_FOUND: u32 = 8449;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE: u32 = 8450;
pub const ERROR_DS_DRA_DB_ERROR: u32 = 8451;
pub const ERROR_DS_DRA_NO_REPLICA: u32 = 8452;
pub const ERROR_DS_DRA_ACCESS_DENIED: u32 = 8453;
pub const ERROR_DS_DRA_NOT_SUPPORTED: u32 = 8454;
pub const ERROR_DS_DRA_RPC_CANCELLED: u32 = 8455;
pub const ERROR_DS_DRA_SOURCE_DISABLED: u32 = 8456;
pub const ERROR_DS_DRA_SINK_DISABLED: u32 = 8457;
pub const ERROR_DS_DRA_NAME_COLLISION: u32 = 8458;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED: u32 = 8459;
pub const ERROR_DS_DRA_MISSING_PARENT: u32 = 8460;
pub const ERROR_DS_DRA_PREEMPTED: u32 = 8461;
pub const ERROR_DS_DRA_ABANDON_SYNC: u32 = 8462;
pub const ERROR_DS_DRA_SHUTDOWN: u32 = 8463;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET: u32 = 8464;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA: u32 = 8465;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED: u32 = 8466;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH: u32 = 8467;
pub const ERROR_DS_DUP_LINK_ID: u32 = 8468;
pub const ERROR_DS_NAME_ERROR_RESOLVING: u32 = 8469;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND: u32 = 8470;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE: u32 = 8471;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING: u32 = 8472;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY: u32 = 8473;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING: u32 = 8474;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD: u32 = 8475;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS: u32 = 8476;
pub const ERROR_DS_DRA_REPL_PENDING: u32 = 8477;
pub const ERROR_DS_DS_REQUIRED: u32 = 8478;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME: u32 = 8479;
pub const ERROR_DS_NON_BASE_SEARCH: u32 = 8480;
pub const ERROR_DS_CANT_RETRIEVE_ATTS: u32 = 8481;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK: u32 = 8482;
pub const ERROR_DS_EPOCH_MISMATCH: u32 = 8483;
pub const ERROR_DS_SRC_NAME_MISMATCH: u32 = 8484;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL: u32 = 8485;
pub const ERROR_DS_DST_NC_MISMATCH: u32 = 8486;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC: u32 = 8487;
pub const ERROR_DS_SRC_GUID_MISMATCH: u32 = 8488;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT: u32 = 8489;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS: u32 = 8490;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD: u32 = 8491;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION: u32 = 8492;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS: u32 = 8493;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT: u32 = 8494;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE: u32 = 8495;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE: u32 = 8496;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER: u32 = 8497;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP: u32 = 8498;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP: u32 = 8499;
pub const ERROR_DS_INVALID_SEARCH_FLAG: u32 = 8500;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC: u32 = 8501;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE: u32 = 8502;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE: u32 = 8503;
pub const ERROR_DS_SAM_INIT_FAILURE: u32 = 8504;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION: u32 = 8505;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID: u32 = 8506;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD: u32 = 8507;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE: u32 = 8508;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED: u32 = 8509;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA: u32 = 8510;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION: u32 = 8511;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE: u32 = 8512;
pub const ERROR_DS_INVALID_GROUP_TYPE: u32 = 8513;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN: u32 = 8514;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN: u32 = 8515;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8516;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8517;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8518;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER: u32 = 8519;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER: u32 = 8520;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS: u32 = 8521;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED: u32 = 8522;
pub const ERROR_DS_NAMING_MASTER_GC: u32 = 8523;
pub const ERROR_DS_DNS_LOOKUP_FAILURE: u32 = 8524;
pub const ERROR_DS_COULDNT_UPDATE_SPNS: u32 = 8525;
pub const ERROR_DS_CANT_RETRIEVE_SD: u32 = 8526;
pub const ERROR_DS_KEY_NOT_UNIQUE: u32 = 8527;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX: u32 = 8528;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD: u32 = 8529;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY: u32 = 8530;
pub const ERROR_DS_CANT_START: u32 = 8531;
pub const ERROR_DS_INIT_FAILURE: u32 = 8532;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION: u32 = 8533;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST: u32 = 8534;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST: u32 = 8535;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED: u32 = 8536;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN: u32 = 8537;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER: u32 = 8538;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST: u32 = 8539;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH: u32 = 8540;
pub const ERROR_SAM_INIT_FAILURE: u32 = 8541;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP: u32 = 8542;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT: u32 = 8543;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT: u32 = 8544;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH: u32 = 8545;
pub const ERROR_DS_NC_STILL_HAS_DSAS: u32 = 8546;
pub const ERROR_DS_GC_REQUIRED: u32 = 8547;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY: u32 = 8548;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS: u32 = 8549;
pub const ERROR_DS_CANT_ADD_TO_GC: u32 = 8550;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC: u32 = 8551;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED: u32 = 8552;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC: u32 = 8553;
pub const ERROR_DS_INVALID_NAME_FOR_SPN: u32 = 8554;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: u32 = 8555;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES: u32 = 8556;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED: u32 = 8557;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC: u32 = 8558;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER: u32 = 8559;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ: u32 = 8560;
pub const ERROR_DS_INIT_FAILURE_CONSOLE: u32 = 8561;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE: u32 = 8562;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH: u32 = 8563;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH: u32 = 8564;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW: u32 = 8565;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW: u32 = 8566;
pub const ERROR_DS_INCOMPATIBLE_VERSION: u32 = 8567;
pub const ERROR_DS_LOW_DSA_VERSION: u32 = 8568;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN: u32 = 8569;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER: u32 = 8570;
pub const ERROR_DS_NAME_NOT_UNIQUE: u32 = 8571;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4: u32 = 8572;
pub const ERROR_DS_OUT_OF_VERSION_STORE: u32 = 8573;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED: u32 = 8574;
pub const ERROR_DS_NO_REF_DOMAIN: u32 = 8575;
pub const ERROR_DS_RESERVED_LINK_ID: u32 = 8576;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE: u32 = 8577;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8578;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE: u32 = 8579;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC: u32 = 8580;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG: u32 = 8581;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT: u32 = 8582;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL: u32 = 8583;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER: u32 = 8584;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD: u32 = 8585;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2: u32 = 8586;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED: u32 = 8587;
pub const ERROR_DS_NOT_CLOSEST: u32 = 8588;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF: u32 = 8589;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED: u32 = 8590;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR: u32 = 8591;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR: u32 = 8592;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS: u32 = 8593;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED: u32 = 8594;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR: u32 = 8595;
pub const ERROR_DS_NO_MSDS_INTID: u32 = 8596;
pub const ERROR_DS_DUP_MSDS_INTID: u32 = 8597;
pub const ERROR_DS_EXISTS_IN_RDNATTID: u32 = 8598;
pub const ERROR_DS_AUTHORIZATION_FAILED: u32 = 8599;
pub const ERROR_DS_INVALID_SCRIPT: u32 = 8600;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED: u32 = 8601;
pub const ERROR_DS_CROSS_REF_BUSY: u32 = 8602;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN: u32 = 8603;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC: u32 = 8604;
pub const ERROR_DS_DUPLICATE_ID_FOUND: u32 = 8605;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT: u32 = 8606;
pub const ERROR_DS_GROUP_CONVERSION_ERROR: u32 = 8607;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP: u32 = 8608;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP: u32 = 8609;
pub const ERROR_DS_ROLE_NOT_VERIFIED: u32 = 8610;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL: u32 = 8611;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS: u32 = 8612;
pub const ERROR_DS_EXISTING_AD_CHILD_NC: u32 = 8613;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED: u32 = 8614;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER: u32 = 8615;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL: u32 = 8616;
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW: u32 = 8617;
pub const ERROR_DS_POLICY_NOT_KNOWN: u32 = 8618;
pub const ERROR_NO_SITE_SETTINGS_OBJECT: u32 = 8619;
pub const ERROR_NO_SECRETS: u32 = 8620;
pub const ERROR_NO_WRITABLE_DC_FOUND: u32 = 8621;
pub const ERROR_DS_NO_SERVER_OBJECT: u32 = 8622;
pub const ERROR_DS_NO_NTDSA_OBJECT: u32 = 8623;
pub const ERROR_DS_NON_ASQ_SEARCH: u32 = 8624;
pub const ERROR_DS_AUDIT_FAILURE: u32 = 8625;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE: u32 = 8626;
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE: u32 = 8627;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP: u32 = 8628;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR: u32 = 8629;
pub const ERROR_DS_DRA_SECRETS_DENIED: u32 = 8630;
pub const ERROR_DS_RESERVED_MAPI_ID: u32 = 8631;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE: u32 = 8632;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET: u32 = 8633;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST: u32 = 8634;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST: u32 = 8635;
pub const ERROR_INVALID_USER_PRINCIPAL_NAME: u32 = 8636;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS: u32 = 8637;
pub const ERROR_DS_OID_NOT_FOUND: u32 = 8638;
pub const ERROR_DS_DRA_RECYCLED_TARGET: u32 = 8639;
pub const ERROR_DS_DISALLOWED_NC_REDIRECT: u32 = 8640;
pub const ERROR_DS_HIGH_ADLDS_FFL: u32 = 8641;
pub const ERROR_DS_HIGH_DSA_VERSION: u32 = 8642;
pub const ERROR_DS_LOW_ADLDS_FFL: u32 = 8643;
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION: u32 = 8644;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED: u32 = 8645;
pub const ERROR_INCORRECT_ACCOUNT_TYPE: u32 = 8646;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 8647;
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 8648;
pub const ERROR_DS_MISSING_FOREST_TRUST: u32 = 8649;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE: u32 = 8650;
pub const ERROR_IPSEC_QM_POLICY_EXISTS: u32 = 13000;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND: u32 = 13001;
pub const ERROR_IPSEC_QM_POLICY_IN_USE: u32 = 13002;
pub const ERROR_IPSEC_MM_POLICY_EXISTS: u32 = 13003;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND: u32 = 13004;
pub const ERROR_IPSEC_MM_POLICY_IN_USE: u32 = 13005;
pub const ERROR_IPSEC_MM_FILTER_EXISTS: u32 = 13006;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND: u32 = 13007;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS: u32 = 13008;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND: u32 = 13009;
pub const ERROR_IPSEC_MM_AUTH_EXISTS: u32 = 13010;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND: u32 = 13011;
pub const ERROR_IPSEC_MM_AUTH_IN_USE: u32 = 13012;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND: u32 = 13013;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND: u32 = 13014;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND: u32 = 13015;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS: u32 = 13016;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND: u32 = 13017;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION: u32 = 13018;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION: u32 = 13019;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION: u32 = 13020;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION: u32 = 13021;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION: u32 = 13022;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION: u32 = 13023;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN: u32 = 13800;
pub const ERROR_IPSEC_IKE_AUTH_FAIL: u32 = 13801;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL: u32 = 13802;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING: u32 = 13803;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR: u32 = 13804;
pub const ERROR_IPSEC_IKE_TIMED_OUT: u32 = 13805;
pub const ERROR_IPSEC_IKE_NO_CERT: u32 = 13806;
pub const ERROR_IPSEC_IKE_SA_DELETED: u32 = 13807;
pub const ERROR_IPSEC_IKE_SA_REAPED: u32 = 13808;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP: u32 = 13809;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP: u32 = 13810;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM: u32 = 13811;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM: u32 = 13812;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE: u32 = 13813;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP: u32 = 13814;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP: u32 = 13815;
pub const ERROR_IPSEC_IKE_ERROR: u32 = 13816;
pub const ERROR_IPSEC_IKE_CRL_FAILED: u32 = 13817;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE: u32 = 13818;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE: u32 = 13819;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY: u32 = 13820;
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY: u32 = 13821;
pub const ERROR_IPSEC_IKE_DH_FAIL: u32 = 13822;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED: u32 = 13823;
pub const ERROR_IPSEC_IKE_INVALID_HEADER: u32 = 13824;
pub const ERROR_IPSEC_IKE_NO_POLICY: u32 = 13825;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE: u32 = 13826;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR: u32 = 13827;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY: u32 = 13828;
pub const ERROR_IPSEC_IKE_PROCESS_ERR: u32 = 13829;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA: u32 = 13830;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP: u32 = 13831;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS: u32 = 13832;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE: u32 = 13833;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID: u32 = 13834;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT: u32 = 13835;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ: u32 = 13836;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH: u32 = 13837;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG: u32 = 13838;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE: u32 = 13839;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY: u32 = 13840;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE: u32 = 13841;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR: u32 = 13842;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD: u32 = 13843;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA: u32 = 13844;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN: u32 = 13845;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE: u32 = 13846;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT: u32 = 13847;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED: u32 = 13848;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE: u32 = 13849;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY: u32 = 13850;
pub const ERROR_IPSEC_IKE_NOTCBPRIV: u32 = 13851;
pub const ERROR_IPSEC_IKE_SECLOADFAIL: u32 = 13852;
pub const ERROR_IPSEC_IKE_FAILSSPINIT: u32 = 13853;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP: u32 = 13854;
pub const ERROR_IPSEC_IKE_SRVACQFAIL: u32 = 13855;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED: u32 = 13856;
pub const ERROR_IPSEC_IKE_GETSPIFAIL: u32 = 13857;
pub const ERROR_IPSEC_IKE_INVALID_FILTER: u32 = 13858;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY: u32 = 13859;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED: u32 = 13860;
pub const ERROR_IPSEC_IKE_INVALID_POLICY: u32 = 13861;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI: u32 = 13862;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION: u32 = 13863;
pub const ERROR_IPSEC_IKE_DH_FAILURE: u32 = 13864;
pub const ERROR_IPSEC_IKE_INVALID_GROUP: u32 = 13865;
pub const ERROR_IPSEC_IKE_ENCRYPT: u32 = 13866;
pub const ERROR_IPSEC_IKE_DECRYPT: u32 = 13867;
pub const ERROR_IPSEC_IKE_POLICY_MATCH: u32 = 13868;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID: u32 = 13869;
pub const ERROR_IPSEC_IKE_INVALID_HASH: u32 = 13870;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG: u32 = 13871;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE: u32 = 13872;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG: u32 = 13873;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG: u32 = 13874;
pub const ERROR_IPSEC_IKE_INVALID_SIG: u32 = 13875;
pub const ERROR_IPSEC_IKE_LOAD_FAILED: u32 = 13876;
pub const ERROR_IPSEC_IKE_RPC_DELETE: u32 = 13877;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT: u32 = 13878;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY: u32 = 13879;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION: u32 = 13880;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN: u32 = 13881;
pub const ERROR_IPSEC_IKE_MM_LIMIT: u32 = 13882;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED: u32 = 13883;
pub const ERROR_IPSEC_IKE_QM_LIMIT: u32 = 13884;
pub const ERROR_IPSEC_IKE_MM_EXPIRED: u32 = 13885;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID: u32 = 13886;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH: u32 = 13887;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID: u32 = 13888;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD: u32 = 13889;
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT: u32 = 13890;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN: u32 = 13891;
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED: u32 = 13892;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA: u32 = 13893;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM: u32 = 13894;
pub const ERROR_IPSEC_IKE_QM_EXPIRED: u32 = 13895;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS: u32 = 13896;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END: u32 = 13897;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL: u32 = 13898;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE: u32 = 13899;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING: u32 = 13900;
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING: u32 = 13901;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS: u32 = 13902;
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP: u32 = 13903;
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE: u32 = 13904;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE: u32 = 13905;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE: u32 = 13906;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY: u32 = 13907;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE: u32 = 13908;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END: u32 = 13909;
pub const ERROR_IPSEC_BAD_SPI: u32 = 13910;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED: u32 = 13911;
pub const ERROR_IPSEC_WRONG_SA: u32 = 13912;
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED: u32 = 13913;
pub const ERROR_IPSEC_INVALID_PACKET: u32 = 13914;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED: u32 = 13915;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP: u32 = 13916;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP: u32 = 13917;
pub const ERROR_IPSEC_THROTTLE_DROP: u32 = 13918;
pub const ERROR_IPSEC_DOSP_BLOCK: u32 = 13925;
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST: u32 = 13926;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET: u32 = 13927;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED: u32 = 13928;
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES: u32 = 13929;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED: u32 = 13930;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED: u32 = 13931;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES: u32 = 13932;
pub const ERROR_SXS_SECTION_NOT_FOUND: u32 = 14000;
pub const ERROR_SXS_CANT_GEN_ACTCTX: u32 = 14001;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT: u32 = 14002;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND: u32 = 14003;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR: u32 = 14004;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR: u32 = 14005;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED: u32 = 14006;
pub const ERROR_SXS_KEY_NOT_FOUND: u32 = 14007;
pub const ERROR_SXS_VERSION_CONFLICT: u32 = 14008;
pub const ERROR_SXS_WRONG_SECTION_TYPE: u32 = 14009;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED: u32 = 14010;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET: u32 = 14011;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP: u32 = 14012;
pub const ERROR_SXS_UNKNOWN_ENCODING: u32 = 14013;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI: u32 = 14014;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14015;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14016;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14017;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE: u32 = 14018;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE: u32 = 14019;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT: u32 = 14020;
pub const ERROR_SXS_DUPLICATE_DLL_NAME: u32 = 14021;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME: u32 = 14022;
pub const ERROR_SXS_DUPLICATE_CLSID: u32 = 14023;
pub const ERROR_SXS_DUPLICATE_IID: u32 = 14024;
pub const ERROR_SXS_DUPLICATE_TLBID: u32 = 14025;
pub const ERROR_SXS_DUPLICATE_PROGID: u32 = 14026;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME: u32 = 14027;
pub const ERROR_SXS_FILE_HASH_MISMATCH: u32 = 14028;
pub const ERROR_SXS_POLICY_PARSE_ERROR: u32 = 14029;
pub const ERROR_SXS_XML_E_MISSINGQUOTE: u32 = 14030;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX: u32 = 14031;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR: u32 = 14032;
pub const ERROR_SXS_XML_E_BADNAMECHAR: u32 = 14033;
pub const ERROR_SXS_XML_E_BADCHARINSTRING: u32 = 14034;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX: u32 = 14035;
pub const ERROR_SXS_XML_E_BADCHARDATA: u32 = 14036;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE: u32 = 14037;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND: u32 = 14038;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON: u32 = 14039;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN: u32 = 14040;
pub const ERROR_SXS_XML_E_INTERNALERROR: u32 = 14041;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE: u32 = 14042;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING: u32 = 14043;
pub const ERROR_SXS_XML_E_MISSING_PAREN: u32 = 14044;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE: u32 = 14045;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS: u32 = 14046;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL: u32 = 14047;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL: u32 = 14048;
pub const ERROR_SXS_XML_E_INVALID_UNICODE: u32 = 14049;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK: u32 = 14050;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG: u32 = 14051;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG: u32 = 14052;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE: u32 = 14053;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS: u32 = 14054;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL: u32 = 14055;
pub const ERROR_SXS_XML_E_BADXMLDECL: u32 = 14056;
pub const ERROR_SXS_XML_E_MISSINGROOT: u32 = 14057;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF: u32 = 14058;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET: u32 = 14059;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG: u32 = 14060;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG: u32 = 14061;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING: u32 = 14062;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT: u32 = 14063;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL: u32 = 14064;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA: u32 = 14065;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE: u32 = 14066;
pub const ERROR_SXS_XML_E_INVALIDENCODING: u32 = 14067;
pub const ERROR_SXS_XML_E_INVALIDSWITCH: u32 = 14068;
pub const ERROR_SXS_XML_E_BADXMLCASE: u32 = 14069;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE: u32 = 14070;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE: u32 = 14071;
pub const ERROR_SXS_XML_E_INVALID_VERSION: u32 = 14072;
pub const ERROR_SXS_XML_E_MISSINGEQUALS: u32 = 14073;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED: u32 = 14074;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT: u32 = 14075;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID: u32 = 14076;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT: u32 = 14077;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING: u32 = 14078;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14079;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME: u32 = 14080;
pub const ERROR_SXS_ASSEMBLY_MISSING: u32 = 14081;
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK: u32 = 14082;
pub const ERROR_SXS_CORRUPTION: u32 = 14083;
pub const ERROR_SXS_EARLY_DEACTIVATION: u32 = 14084;
pub const ERROR_SXS_INVALID_DEACTIVATION: u32 = 14085;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION: u32 = 14086;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED: u32 = 14087;
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT: u32 = 14088;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY: u32 = 14089;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE: u32 = 14090;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME: u32 = 14091;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE: u32 = 14092;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR: u32 = 14093;
pub const ERROR_MALFORMED_SUBSTITUTION_STRING: u32 = 14094;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN: u32 = 14095;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING: u32 = 14096;
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED: u32 = 14097;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT: u32 = 14098;
pub const ERROR_ADVANCED_INSTALLER_FAILED: u32 = 14099;
pub const ERROR_XML_ENCODING_MISMATCH: u32 = 14100;
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT: u32 = 14101;
pub const ERROR_SXS_IDENTITIES_DIFFERENT: u32 = 14102;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT: u32 = 14103;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY: u32 = 14104;
pub const ERROR_SXS_MANIFEST_TOO_BIG: u32 = 14105;
pub const ERROR_SXS_SETTING_NOT_REGISTERED: u32 = 14106;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE: u32 = 14107;
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED: u32 = 14108;
pub const ERROR_GENERIC_COMMAND_FAILED: u32 = 14109;
pub const ERROR_SXS_FILE_HASH_MISSING: u32 = 14110;
pub const ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS: u32 = 14111;
pub const ERROR_EVT_INVALID_CHANNEL_PATH: u32 = 15000;
pub const ERROR_EVT_INVALID_QUERY: u32 = 15001;
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND: u32 = 15002;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND: u32 = 15003;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME: u32 = 15004;
pub const ERROR_EVT_INVALID_EVENT_DATA: u32 = 15005;
pub const ERROR_EVT_CHANNEL_NOT_FOUND: u32 = 15007;
pub const ERROR_EVT_MALFORMED_XML_TEXT: u32 = 15008;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL: u32 = 15009;
pub const ERROR_EVT_CONFIGURATION_ERROR: u32 = 15010;
pub const ERROR_EVT_QUERY_RESULT_STALE: u32 = 15011;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION: u32 = 15012;
pub const ERROR_EVT_NON_VALIDATING_MSXML: u32 = 15013;
pub const ERROR_EVT_FILTER_ALREADYSCOPED: u32 = 15014;
pub const ERROR_EVT_FILTER_NOTELTSET: u32 = 15015;
pub const ERROR_EVT_FILTER_INVARG: u32 = 15016;
pub const ERROR_EVT_FILTER_INVTEST: u32 = 15017;
pub const ERROR_EVT_FILTER_INVTYPE: u32 = 15018;
pub const ERROR_EVT_FILTER_PARSEERR: u32 = 15019;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP: u32 = 15020;
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN: u32 = 15021;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL: u32 = 15022;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE: u32 = 15023;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE: u32 = 15024;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE: u32 = 15025;
pub const ERROR_EVT_FILTER_TOO_COMPLEX: u32 = 15026;
pub const ERROR_EVT_MESSAGE_NOT_FOUND: u32 = 15027;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND: u32 = 15028;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT: u32 = 15029;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT: u32 = 15030;
pub const ERROR_EVT_MAX_INSERTS_REACHED: u32 = 15031;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND: u32 = 15032;
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND: u32 = 15033;
pub const ERROR_EVT_VERSION_TOO_OLD: u32 = 15034;
pub const ERROR_EVT_VERSION_TOO_NEW: u32 = 15035;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY: u32 = 15036;
pub const ERROR_EVT_PUBLISHER_DISABLED: u32 = 15037;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE: u32 = 15038;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE: u32 = 15080;
pub const ERROR_EC_LOG_DISABLED: u32 = 15081;
pub const ERROR_EC_CIRCULAR_FORWARDING: u32 = 15082;
pub const ERROR_EC_CREDSTORE_FULL: u32 = 15083;
pub const ERROR_EC_CRED_NOT_FOUND: u32 = 15084;
pub const ERROR_EC_NO_ACTIVE_CHANNEL: u32 = 15085;
pub const ERROR_MUI_FILE_NOT_FOUND: u32 = 15100;
pub const ERROR_MUI_INVALID_FILE: u32 = 15101;
pub const ERROR_MUI_INVALID_RC_CONFIG: u32 = 15102;
pub const ERROR_MUI_INVALID_LOCALE_NAME: u32 = 15103;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME: u32 = 15104;
pub const ERROR_MUI_FILE_NOT_LOADED: u32 = 15105;
pub const ERROR_RESOURCE_ENUM_USER_STOP: u32 = 15106;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED: u32 = 15107;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME: u32 = 15108;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE: u32 = 15110;
pub const ERROR_MRM_INVALID_PRICONFIG: u32 = 15111;
pub const ERROR_MRM_INVALID_FILE_TYPE: u32 = 15112;
pub const ERROR_MRM_UNKNOWN_QUALIFIER: u32 = 15113;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE: u32 = 15114;
pub const ERROR_MRM_NO_CANDIDATE: u32 = 15115;
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE: u32 = 15116;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH: u32 = 15117;
pub const ERROR_MRM_DUPLICATE_MAP_NAME: u32 = 15118;
pub const ERROR_MRM_DUPLICATE_ENTRY: u32 = 15119;
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER: u32 = 15120;
pub const ERROR_MRM_FILEPATH_TOO_LONG: u32 = 15121;
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE: u32 = 15122;
pub const ERROR_MRM_INVALID_PRI_FILE: u32 = 15126;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND: u32 = 15127;
pub const ERROR_MRM_MAP_NOT_FOUND: u32 = 15135;
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE: u32 = 15136;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR: u32 = 15137;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE: u32 = 15138;
pub const ERROR_MRM_AUTOMERGE_ENABLED: u32 = 15139;
pub const ERROR_MRM_TOO_MANY_RESOURCES: u32 = 15140;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE: u32 = 15141;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE: u32 = 15142;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD: u32 = 15143;
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST: u32 = 15144;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT: u32 = 15145;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE: u32 = 15146;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH: u32 = 15147;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH: u32 = 15148;
pub const ERROR_PRI_MERGE_MISSING_SCHEMA: u32 = 15149;
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED: u32 = 15150;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED: u32 = 15151;
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED: u32 = 15152;
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED: u32 = 15153;
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED: u32 = 15154;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED: u32 = 15155;
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED: u32 = 15156;
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED: u32 = 15157;
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME: u32 = 15158;
pub const ERROR_MRM_PACKAGE_NOT_FOUND: u32 = 15159;
pub const ERROR_MRM_MISSING_DEFAULT_LANGUAGE: u32 = 15160;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING: u32 = 15200;
pub const ERROR_MCA_INVALID_VCP_VERSION: u32 = 15201;
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION: u32 = 15202;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH: u32 = 15203;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION: u32 = 15204;
pub const ERROR_MCA_INTERNAL_ERROR: u32 = 15205;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED: u32 = 15206;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE: u32 = 15207;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE: u32 = 15250;
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND: u32 = 15299;
pub const ERROR_HASH_NOT_SUPPORTED: u32 = 15300;
pub const ERROR_HASH_NOT_PRESENT: u32 = 15301;
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED: u32 = 15321;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID: u32 = 15322;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED: u32 = 15323;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET: u32 = 15324;
pub const ERROR_GPIO_OPERATION_DENIED: u32 = 15325;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE: u32 = 15326;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED: u32 = 15327;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL: u32 = 15400;
pub const ERROR_INVALID_RUNLEVEL_SETTING: u32 = 15401;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT: u32 = 15402;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT: u32 = 15403;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS: u32 = 15404;
pub const ERROR_SERVICES_FAILED_AUTOSTART: u32 = 15405;
pub const ERROR_COM_TASK_STOP_PENDING: u32 = 15501;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED: u32 = 15600;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND: u32 = 15601;
pub const ERROR_INSTALL_INVALID_PACKAGE: u32 = 15602;
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED: u32 = 15603;
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE: u32 = 15604;
pub const ERROR_INSTALL_NETWORK_FAILURE: u32 = 15605;
pub const ERROR_INSTALL_REGISTRATION_FAILURE: u32 = 15606;
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE: u32 = 15607;
pub const ERROR_INSTALL_CANCEL: u32 = 15608;
pub const ERROR_INSTALL_FAILED: u32 = 15609;
pub const ERROR_REMOVE_FAILED: u32 = 15610;
pub const ERROR_PACKAGE_ALREADY_EXISTS: u32 = 15611;
pub const ERROR_NEEDS_REMEDIATION: u32 = 15612;
pub const ERROR_INSTALL_PREREQUISITE_FAILED: u32 = 15613;
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED: u32 = 15614;
pub const ERROR_INSTALL_POLICY_FAILURE: u32 = 15615;
pub const ERROR_PACKAGE_UPDATING: u32 = 15616;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY: u32 = 15617;
pub const ERROR_PACKAGES_IN_USE: u32 = 15618;
pub const ERROR_RECOVERY_FILE_CORRUPT: u32 = 15619;
pub const ERROR_INVALID_STAGED_SIGNATURE: u32 = 15620;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED: u32 = 15621;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE: u32 = 15622;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION: u32 = 15623;
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN: u32 = 15624;
pub const ERROR_RESILIENCY_FILE_CORRUPT: u32 = 15625;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING: u32 = 15626;
pub const ERROR_PACKAGE_MOVE_FAILED: u32 = 15627;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY: u32 = 15628;
pub const ERROR_INSTALL_VOLUME_OFFLINE: u32 = 15629;
pub const ERROR_INSTALL_VOLUME_CORRUPT: u32 = 15630;
pub const ERROR_NEEDS_REGISTRATION: u32 = 15631;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE: u32 = 15632;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED: u32 = 15633;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE: u32 = 15634;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM: u32 = 15635;
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING: u32 = 15636;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE: u32 = 15637;
pub const ERROR_PACKAGE_STAGING_ONHOLD: u32 = 15638;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE: u32 = 15639;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY: u32 = 15640;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF: u32 = 15641;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED: u32 = 15642;
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED: u32 = 15643;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT: u32 = 15644;
pub const ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED: u32 = 15645;
pub const ERROR_APPINSTALLER_ACTIVATION_BLOCKED: u32 = 15646;
pub const ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED: u32 = 15647;
pub const ERROR_APPX_RAW_DATA_WRITE_FAILED: u32 = 15648;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE: u32 = 15649;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE: u32 = 15650;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY: u32 = 15651;
pub const ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY: u32 = 15652;
pub const ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER: u32 = 15653;
pub const ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED: u32 = 15654;
pub const ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE: u32 = 15655;
pub const ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES: u32 = 15656;
pub const ERROR_STATE_LOAD_STORE_FAILED: u32 = 15800;
pub const ERROR_STATE_GET_VERSION_FAILED: u32 = 15801;
pub const ERROR_STATE_SET_VERSION_FAILED: u32 = 15802;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED: u32 = 15803;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED: u32 = 15804;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED: u32 = 15805;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED: u32 = 15806;
pub const ERROR_STATE_READ_SETTING_FAILED: u32 = 15807;
pub const ERROR_STATE_WRITE_SETTING_FAILED: u32 = 15808;
pub const ERROR_STATE_DELETE_SETTING_FAILED: u32 = 15809;
pub const ERROR_STATE_QUERY_SETTING_FAILED: u32 = 15810;
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED: u32 = 15811;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED: u32 = 15812;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED: u32 = 15813;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED: u32 = 15814;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 15815;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 15816;
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED: u32 = 15817;
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED: u32 = 15818;
pub const ERROR_API_UNAVAILABLE: u32 = 15841;
pub const ERROR_LABEL_UNREADABLE: u32 = 1;
pub const ERROR_LABEL_QUESTIONABLE: u32 = 2;
pub const ERROR_SLOT_NOT_PRESENT: u32 = 4;
pub const ERROR_DRIVE_NOT_INSTALLED: u32 = 8;
pub const ERROR_TRAY_MALFUNCTION: u32 = 16;
pub const ERROR_INIT_STATUS_NEEDED: u32 = 17;
pub const ERROR_UNHANDLED_ERROR: u32 = 4294967295;
pub const ERROR_BIDI_STATUS_OK: u32 = 0;
pub const ERROR_BIDI_NOT_SUPPORTED: u32 = 50;
pub const ERROR_BIDI_ERROR_BASE: u32 = 13000;
pub const ERROR_BIDI_STATUS_WARNING: u32 = 13001;
pub const ERROR_BIDI_SCHEMA_READ_ONLY: u32 = 13002;
pub const ERROR_BIDI_SERVER_OFFLINE: u32 = 13003;
pub const ERROR_BIDI_DEVICE_OFFLINE: u32 = 13004;
pub const ERROR_BIDI_SCHEMA_NOT_SUPPORTED: u32 = 13005;
pub const ERROR_BIDI_SET_DIFFERENT_TYPE: u32 = 13006;
pub const ERROR_BIDI_SET_MULTIPLE_SCHEMAPATH: u32 = 13007;
pub const ERROR_BIDI_SET_INVALID_SCHEMAPATH: u32 = 13008;
pub const ERROR_BIDI_SET_UNKNOWN_FAILURE: u32 = 13009;
pub const ERROR_BIDI_SCHEMA_WRITE_ONLY: u32 = 13010;
pub const ERROR_BIDI_GET_REQUIRES_ARGUMENT: u32 = 13011;
pub const ERROR_BIDI_GET_ARGUMENT_NOT_SUPPORTED: u32 = 13012;
pub const ERROR_BIDI_GET_MISSING_ARGUMENT: u32 = 13013;
pub const ERROR_BIDI_DEVICE_CONFIG_UNCHANGED: u32 = 13014;
pub const ERROR_BIDI_NO_LOCALIZED_RESOURCES: u32 = 13015;
pub const ERROR_BIDI_NO_BIDI_SCHEMA_EXTENSIONS: u32 = 13016;
pub const ERROR_BIDI_UNSUPPORTED_CLIENT_LANGUAGE: u32 = 13017;
pub const ERROR_BIDI_UNSUPPORTED_RESOURCE_FORMAT: u32 = 13018;
pub const ERROR_INTERNET_OUT_OF_HANDLES: u32 = 12001;
pub const ERROR_INTERNET_TIMEOUT: u32 = 12002;
pub const ERROR_INTERNET_EXTENDED_ERROR: u32 = 12003;
pub const ERROR_INTERNET_INTERNAL_ERROR: u32 = 12004;
pub const ERROR_INTERNET_INVALID_URL: u32 = 12005;
pub const ERROR_INTERNET_UNRECOGNIZED_SCHEME: u32 = 12006;
pub const ERROR_INTERNET_NAME_NOT_RESOLVED: u32 = 12007;
pub const ERROR_INTERNET_PROTOCOL_NOT_FOUND: u32 = 12008;
pub const ERROR_INTERNET_INVALID_OPTION: u32 = 12009;
pub const ERROR_INTERNET_BAD_OPTION_LENGTH: u32 = 12010;
pub const ERROR_INTERNET_OPTION_NOT_SETTABLE: u32 = 12011;
pub const ERROR_INTERNET_SHUTDOWN: u32 = 12012;
pub const ERROR_INTERNET_INCORRECT_USER_NAME: u32 = 12013;
pub const ERROR_INTERNET_INCORRECT_PASSWORD: u32 = 12014;
pub const ERROR_INTERNET_LOGIN_FAILURE: u32 = 12015;
pub const ERROR_INTERNET_INVALID_OPERATION: u32 = 12016;
pub const ERROR_INTERNET_OPERATION_CANCELLED: u32 = 12017;
pub const ERROR_INTERNET_INCORRECT_HANDLE_TYPE: u32 = 12018;
pub const ERROR_INTERNET_INCORRECT_HANDLE_STATE: u32 = 12019;
pub const ERROR_INTERNET_NOT_PROXY_REQUEST: u32 = 12020;
pub const ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND: u32 = 12021;
pub const ERROR_INTERNET_BAD_REGISTRY_PARAMETER: u32 = 12022;
pub const ERROR_INTERNET_NO_DIRECT_ACCESS: u32 = 12023;
pub const ERROR_INTERNET_NO_CONTEXT: u32 = 12024;
pub const ERROR_INTERNET_NO_CALLBACK: u32 = 12025;
pub const ERROR_INTERNET_REQUEST_PENDING: u32 = 12026;
pub const ERROR_INTERNET_INCORRECT_FORMAT: u32 = 12027;
pub const ERROR_INTERNET_ITEM_NOT_FOUND: u32 = 12028;
pub const ERROR_INTERNET_CANNOT_CONNECT: u32 = 12029;
pub const ERROR_INTERNET_CONNECTION_ABORTED: u32 = 12030;
pub const ERROR_INTERNET_CONNECTION_RESET: u32 = 12031;
pub const ERROR_INTERNET_FORCE_RETRY: u32 = 12032;
pub const ERROR_INTERNET_INVALID_PROXY_REQUEST: u32 = 12033;
pub const ERROR_INTERNET_NEED_UI: u32 = 12034;
pub const ERROR_INTERNET_HANDLE_EXISTS: u32 = 12036;
pub const ERROR_INTERNET_SEC_CERT_DATE_INVALID: u32 = 12037;
pub const ERROR_INTERNET_SEC_CERT_CN_INVALID: u32 = 12038;
pub const ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR: u32 = 12039;
pub const ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR: u32 = 12040;
pub const ERROR_INTERNET_MIXED_SECURITY: u32 = 12041;
pub const ERROR_INTERNET_CHG_POST_IS_NON_SECURE: u32 = 12042;
pub const ERROR_INTERNET_POST_IS_NON_SECURE: u32 = 12043;
pub const ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED: u32 = 12044;
pub const ERROR_INTERNET_INVALID_CA: u32 = 12045;
pub const ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP: u32 = 12046;
pub const ERROR_INTERNET_ASYNC_THREAD_FAILED: u32 = 12047;
pub const ERROR_INTERNET_REDIRECT_SCHEME_CHANGE: u32 = 12048;
pub const ERROR_INTERNET_DIALOG_PENDING: u32 = 12049;
pub const ERROR_INTERNET_RETRY_DIALOG: u32 = 12050;
pub const ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR: u32 = 12052;
pub const ERROR_INTERNET_INSERT_CDROM: u32 = 12053;
pub const ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED: u32 = 12054;
pub const ERROR_INTERNET_SEC_CERT_ERRORS: u32 = 12055;
pub const ERROR_INTERNET_SEC_CERT_NO_REV: u32 = 12056;
pub const ERROR_INTERNET_SEC_CERT_REV_FAILED: u32 = 12057;
pub const ERROR_HTTP_HSTS_REDIRECT_REQUIRED: u32 = 12060;
pub const ERROR_INTERNET_SEC_CERT_WEAK_SIGNATURE: u32 = 12062;
pub const ERROR_FTP_TRANSFER_IN_PROGRESS: u32 = 12110;
pub const ERROR_FTP_DROPPED: u32 = 12111;
pub const ERROR_FTP_NO_PASSIVE_MODE: u32 = 12112;
pub const ERROR_GOPHER_PROTOCOL_ERROR: u32 = 12130;
pub const ERROR_GOPHER_NOT_FILE: u32 = 12131;
pub const ERROR_GOPHER_DATA_ERROR: u32 = 12132;
pub const ERROR_GOPHER_END_OF_DATA: u32 = 12133;
pub const ERROR_GOPHER_INVALID_LOCATOR: u32 = 12134;
pub const ERROR_GOPHER_INCORRECT_LOCATOR_TYPE: u32 = 12135;
pub const ERROR_GOPHER_NOT_GOPHER_PLUS: u32 = 12136;
pub const ERROR_GOPHER_ATTRIBUTE_NOT_FOUND: u32 = 12137;
pub const ERROR_GOPHER_UNKNOWN_LOCATOR: u32 = 12138;
pub const ERROR_HTTP_HEADER_NOT_FOUND: u32 = 12150;
pub const ERROR_HTTP_DOWNLEVEL_SERVER: u32 = 12151;
pub const ERROR_HTTP_INVALID_SERVER_RESPONSE: u32 = 12152;
pub const ERROR_HTTP_INVALID_HEADER: u32 = 12153;
pub const ERROR_HTTP_INVALID_QUERY_REQUEST: u32 = 12154;
pub const ERROR_HTTP_HEADER_ALREADY_EXISTS: u32 = 12155;
pub const ERROR_HTTP_REDIRECT_FAILED: u32 = 12156;
pub const ERROR_HTTP_NOT_REDIRECTED: u32 = 12160;
pub const ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION: u32 = 12161;
pub const ERROR_HTTP_COOKIE_DECLINED: u32 = 12162;
pub const ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION: u32 = 12168;
pub const ERROR_INTERNET_SECURITY_CHANNEL_ERROR: u32 = 12157;
pub const ERROR_INTERNET_UNABLE_TO_CACHE_FILE: u32 = 12158;
pub const ERROR_INTERNET_TCPIP_NOT_INSTALLED: u32 = 12159;
pub const ERROR_INTERNET_DISCONNECTED: u32 = 12163;
pub const ERROR_INTERNET_SERVER_UNREACHABLE: u32 = 12164;
pub const ERROR_INTERNET_PROXY_SERVER_UNREACHABLE: u32 = 12165;
pub const ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT: u32 = 12166;
pub const ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT: u32 = 12167;
pub const ERROR_INTERNET_SEC_INVALID_CERT: u32 = 12169;
pub const ERROR_INTERNET_SEC_CERT_REVOKED: u32 = 12170;
pub const ERROR_INTERNET_FAILED_DUETOSECURITYCHECK: u32 = 12171;
pub const ERROR_INTERNET_NOT_INITIALIZED: u32 = 12172;
pub const ERROR_INTERNET_NEED_MSN_SSPI_PKG: u32 = 12173;
pub const ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY: u32 = 12174;
pub const ERROR_INTERNET_DECODING_FAILED: u32 = 12175;
pub const ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED_PROXY: u32 = 12187;
pub const ERROR_INTERNET_SECURE_FAILURE_PROXY: u32 = 12188;
pub const ERROR_INTERNET_HTTP_PROTOCOL_MISMATCH: u32 = 12190;
pub const STORMLIB_VERSION: u32 = 2326;
pub const STORMLIB_VERSION_STRING: &'static [u8; 5usize] = b"9.22\0";
pub const ID_MPQ: u32 = 441536589;
pub const ID_MPQ_USERDATA: u32 = 458313805;
pub const ID_MPK: u32 = 441143373;
pub const ERROR_AVI_FILE: u32 = 10000;
pub const ERROR_UNKNOWN_FILE_KEY: u32 = 10001;
pub const ERROR_CHECKSUM_ERROR: u32 = 10002;
pub const ERROR_INTERNAL_FILE: u32 = 10003;
pub const ERROR_BASE_FILE_MISSING: u32 = 10004;
pub const ERROR_MARKED_FOR_DELETE: u32 = 10005;
pub const ERROR_FILE_INCOMPLETE: u32 = 10006;
pub const ERROR_UNKNOWN_FILE_NAMES: u32 = 10007;
pub const ERROR_CANT_FIND_PATCH_PREFIX: u32 = 10008;
pub const HASH_TABLE_SIZE_MIN: u32 = 4;
pub const HASH_TABLE_SIZE_DEFAULT: u32 = 4096;
pub const HASH_TABLE_SIZE_MAX: u32 = 524288;
pub const HASH_ENTRY_DELETED: u32 = 4294967294;
pub const HASH_ENTRY_FREE: u32 = 4294967295;
pub const HET_ENTRY_DELETED: u32 = 128;
pub const HET_ENTRY_FREE: u32 = 0;
pub const HASH_STATE_SIZE: u32 = 96;
pub const SFILE_OPEN_HARD_DISK_FILE: u32 = 2;
pub const SFILE_OPEN_CDROM_FILE: u32 = 3;
pub const SFILE_OPEN_FROM_MPQ: u32 = 0;
pub const SFILE_OPEN_CHECK_EXISTS: u32 = 4294967292;
pub const SFILE_OPEN_BASE_FILE: u32 = 4294967293;
pub const SFILE_OPEN_ANY_LOCALE: u32 = 4294967294;
pub const SFILE_OPEN_LOCAL_FILE: u32 = 4294967295;
pub const MPQ_FLAG_READ_ONLY: u32 = 1;
pub const MPQ_FLAG_CHANGED: u32 = 2;
pub const MPQ_FLAG_MALFORMED: u32 = 4;
pub const MPQ_FLAG_HASH_TABLE_CUT: u32 = 8;
pub const MPQ_FLAG_BLOCK_TABLE_CUT: u32 = 16;
pub const MPQ_FLAG_CHECK_SECTOR_CRC: u32 = 32;
pub const MPQ_FLAG_SAVING_TABLES: u32 = 64;
pub const MPQ_FLAG_PATCH: u32 = 128;
pub const MPQ_FLAG_WAR3_MAP: u32 = 256;
pub const MPQ_FLAG_LISTFILE_NONE: u32 = 512;
pub const MPQ_FLAG_LISTFILE_NEW: u32 = 1024;
pub const MPQ_FLAG_LISTFILE_FORCE: u32 = 2048;
pub const MPQ_FLAG_ATTRIBUTES_NONE: u32 = 4096;
pub const MPQ_FLAG_ATTRIBUTES_NEW: u32 = 8192;
pub const MPQ_FLAG_SIGNATURE_NONE: u32 = 16384;
pub const MPQ_FLAG_SIGNATURE_NEW: u32 = 32768;
pub const MPQ_SUBTYPE_MPQ: u32 = 0;
pub const MPQ_SUBTYPE_SQP: u32 = 1;
pub const MPQ_SUBTYPE_MPK: u32 = 2;
pub const SFILE_INVALID_SIZE: u32 = 4294967295;
pub const SFILE_INVALID_POS: u32 = 4294967295;
pub const SFILE_INVALID_ATTRIBUTES: u32 = 4294967295;
pub const MPQ_FILE_IMPLODE: u32 = 256;
pub const MPQ_FILE_COMPRESS: u32 = 512;
pub const MPQ_FILE_ENCRYPTED: u32 = 65536;
pub const MPQ_FILE_FIX_KEY: u32 = 131072;
pub const MPQ_FILE_PATCH_FILE: u32 = 1048576;
pub const MPQ_FILE_SINGLE_UNIT: u32 = 16777216;
pub const MPQ_FILE_DELETE_MARKER: u32 = 33554432;
pub const MPQ_FILE_SECTOR_CRC: u32 = 67108864;
pub const MPQ_FILE_SIGNATURE: u32 = 268435456;
pub const MPQ_FILE_EXISTS: u32 = 2147483648;
pub const MPQ_FILE_REPLACEEXISTING: u32 = 2147483648;
pub const MPQ_FILE_COMPRESS_MASK: u32 = 65280;
pub const MPQ_FILE_DEFAULT_INTERNAL: u32 = 4294967295;
pub const MPQ_FILE_VALID_FLAGS: u32 = 2534605568;
pub const MPQ_FILE_VALID_FLAGS_W3X: u32 = 2516779776;
pub const BLOCK_INDEX_MASK: u32 = 268435455;
pub const MPQ_COMPRESSION_HUFFMANN: u32 = 1;
pub const MPQ_COMPRESSION_ZLIB: u32 = 2;
pub const MPQ_COMPRESSION_PKWARE: u32 = 8;
pub const MPQ_COMPRESSION_BZIP2: u32 = 16;
pub const MPQ_COMPRESSION_SPARSE: u32 = 32;
pub const MPQ_COMPRESSION_ADPCM_MONO: u32 = 64;
pub const MPQ_COMPRESSION_ADPCM_STEREO: u32 = 128;
pub const MPQ_COMPRESSION_LZMA: u32 = 18;
pub const MPQ_COMPRESSION_NEXT_SAME: u32 = 4294967295;
pub const MPQ_WAVE_QUALITY_HIGH: u32 = 0;
pub const MPQ_WAVE_QUALITY_MEDIUM: u32 = 1;
pub const MPQ_WAVE_QUALITY_LOW: u32 = 2;
pub const HET_TABLE_SIGNATURE: u32 = 441730376;
pub const BET_TABLE_SIGNATURE: u32 = 441730370;
pub const MPQ_KEY_HASH_TABLE: u32 = 3283040112;
pub const MPQ_KEY_BLOCK_TABLE: u32 = 3968054179;
pub const LISTFILE_NAME: &'static [u8; 11usize] = b"(listfile)\0";
pub const SIGNATURE_NAME: &'static [u8; 12usize] = b"(signature)\0";
pub const ATTRIBUTES_NAME: &'static [u8; 13usize] = b"(attributes)\0";
pub const PATCH_METADATA_NAME: &'static [u8; 17usize] = b"(patch_metadata)\0";
pub const MPQ_FORMAT_VERSION_1: u32 = 0;
pub const MPQ_FORMAT_VERSION_2: u32 = 1;
pub const MPQ_FORMAT_VERSION_3: u32 = 2;
pub const MPQ_FORMAT_VERSION_4: u32 = 3;
pub const MPQ_ATTRIBUTE_CRC32: u32 = 1;
pub const MPQ_ATTRIBUTE_FILETIME: u32 = 2;
pub const MPQ_ATTRIBUTE_MD5: u32 = 4;
pub const MPQ_ATTRIBUTE_PATCH_BIT: u32 = 8;
pub const MPQ_ATTRIBUTE_ALL: u32 = 15;
pub const MPQ_ATTRIBUTES_V1: u32 = 100;
pub const BASE_PROVIDER_FILE: u32 = 0;
pub const BASE_PROVIDER_MAP: u32 = 1;
pub const BASE_PROVIDER_HTTP: u32 = 2;
pub const BASE_PROVIDER_MASK: u32 = 15;
pub const STREAM_PROVIDER_FLAT: u32 = 0;
pub const STREAM_PROVIDER_PARTIAL: u32 = 16;
pub const STREAM_PROVIDER_MPQE: u32 = 32;
pub const STREAM_PROVIDER_BLOCK4: u32 = 48;
pub const STREAM_PROVIDER_MASK: u32 = 240;
pub const STREAM_FLAG_READ_ONLY: u32 = 256;
pub const STREAM_FLAG_WRITE_SHARE: u32 = 512;
pub const STREAM_FLAG_USE_BITMAP: u32 = 1024;
pub const STREAM_OPTIONS_MASK: u32 = 65280;
pub const STREAM_PROVIDERS_MASK: u32 = 255;
pub const STREAM_FLAGS_MASK: u32 = 65535;
pub const MPQ_OPEN_NO_LISTFILE: u32 = 65536;
pub const MPQ_OPEN_NO_ATTRIBUTES: u32 = 131072;
pub const MPQ_OPEN_NO_HEADER_SEARCH: u32 = 262144;
pub const MPQ_OPEN_FORCE_MPQ_V1: u32 = 524288;
pub const MPQ_OPEN_CHECK_SECTOR_CRC: u32 = 1048576;
pub const MPQ_OPEN_PATCH: u32 = 2097152;
pub const MPQ_OPEN_FORCE_LISTFILE: u32 = 4194304;
pub const MPQ_OPEN_READ_ONLY: u32 = 256;
pub const MPQ_CREATE_LISTFILE: u32 = 1048576;
pub const MPQ_CREATE_ATTRIBUTES: u32 = 2097152;
pub const MPQ_CREATE_SIGNATURE: u32 = 4194304;
pub const MPQ_CREATE_ARCHIVE_V1: u32 = 0;
pub const MPQ_CREATE_ARCHIVE_V2: u32 = 16777216;
pub const MPQ_CREATE_ARCHIVE_V3: u32 = 33554432;
pub const MPQ_CREATE_ARCHIVE_V4: u32 = 50331648;
pub const MPQ_CREATE_ARCHIVE_VMASK: u32 = 251658240;
pub const FLAGS_TO_FORMAT_SHIFT: u32 = 24;
pub const SFILE_VERIFY_SECTOR_CRC: u32 = 1;
pub const SFILE_VERIFY_FILE_CRC: u32 = 2;
pub const SFILE_VERIFY_FILE_MD5: u32 = 4;
pub const SFILE_VERIFY_RAW_MD5: u32 = 8;
pub const SFILE_VERIFY_ALL: u32 = 15;
pub const VERIFY_OPEN_ERROR: u32 = 1;
pub const VERIFY_READ_ERROR: u32 = 2;
pub const VERIFY_FILE_HAS_SECTOR_CRC: u32 = 4;
pub const VERIFY_FILE_SECTOR_CRC_ERROR: u32 = 8;
pub const VERIFY_FILE_HAS_CHECKSUM: u32 = 16;
pub const VERIFY_FILE_CHECKSUM_ERROR: u32 = 32;
pub const VERIFY_FILE_HAS_MD5: u32 = 64;
pub const VERIFY_FILE_MD5_ERROR: u32 = 128;
pub const VERIFY_FILE_HAS_RAW_MD5: u32 = 256;
pub const VERIFY_FILE_RAW_MD5_ERROR: u32 = 512;
pub const VERIFY_FILE_ERROR_MASK: u32 = 683;
pub const SFILE_VERIFY_MPQ_HEADER: u32 = 1;
pub const SFILE_VERIFY_HET_TABLE: u32 = 2;
pub const SFILE_VERIFY_BET_TABLE: u32 = 3;
pub const SFILE_VERIFY_HASH_TABLE: u32 = 4;
pub const SFILE_VERIFY_BLOCK_TABLE: u32 = 5;
pub const SFILE_VERIFY_HIBLOCK_TABLE: u32 = 6;
pub const SFILE_VERIFY_FILE: u32 = 7;
pub const SIGNATURE_TYPE_NONE: u32 = 0;
pub const SIGNATURE_TYPE_WEAK: u32 = 1;
pub const SIGNATURE_TYPE_STRONG: u32 = 2;
pub const ERROR_NO_SIGNATURE: u32 = 0;
pub const ERROR_VERIFY_FAILED: u32 = 1;
pub const ERROR_WEAK_SIGNATURE_OK: u32 = 2;
pub const ERROR_WEAK_SIGNATURE_ERROR: u32 = 3;
pub const ERROR_STRONG_SIGNATURE_OK: u32 = 4;
pub const ERROR_STRONG_SIGNATURE_ERROR: u32 = 5;
pub const MD5_DIGEST_SIZE: u32 = 16;
pub const SHA1_DIGEST_SIZE: u32 = 20;
pub const CCB_CHECKING_FILES: u32 = 1;
pub const CCB_CHECKING_HASH_TABLE: u32 = 2;
pub const CCB_COPYING_NON_MPQ_DATA: u32 = 3;
pub const CCB_COMPACTING_FILES: u32 = 4;
pub const CCB_CLOSING_ARCHIVE: u32 = 5;
pub const MPQ_HEADER_SIZE_V1: u32 = 32;
pub const MPQ_HEADER_SIZE_V2: u32 = 44;
pub const MPQ_HEADER_SIZE_V3: u32 = 68;
pub const MPQ_HEADER_SIZE_V4: u32 = 208;
pub const MPQ_HEADER_DWORDS: u32 = 52;
pub type size_t = ::std::os::raw::c_ulonglong;
pub type TCHAR = u16;
pub type ULONG = ::std::os::raw::c_ulong;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type FLOAT = f32;
pub type PBYTE = *mut BYTE;
pub type LPBYTE = *mut BYTE;
pub type PDWORD = *mut DWORD;
pub type LPDWORD = *mut DWORD;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type LPCVOID = *const ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SHANDLE_PTR = ::std::os::raw::c_longlong;
pub type SIZE_T = ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type LPSTR = *mut CHAR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PCZZSTR = *const CHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY {
  pub Mask: KAFFINITY,
  pub Group: WORD,
  pub Reserved: [WORD; 3usize],
}
#[test]
fn bindgen_test_layout__GROUP_AFFINITY() {
  assert_eq!(
    ::std::mem::size_of::<_GROUP_AFFINITY>(),
    16usize,
    concat!("Size of: ", stringify!(_GROUP_AFFINITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_GROUP_AFFINITY>(),
    8usize,
    concat!("Alignment of ", stringify!(_GROUP_AFFINITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Mask as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Group as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Reserved as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type HRESULT = ::std::os::raw::c_long;
pub type LCID = DWORD;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
  pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
  pub u: _LARGE_INTEGER__bindgen_ty_2,
  pub QuadPart: LONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(HighPart)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(HighPart)
    )
  );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
  assert_eq!(
    ::std::mem::size_of::<_LARGE_INTEGER>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER))
  );
  assert_eq!(
    ::std::mem::align_of::<_LARGE_INTEGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER),
      "::",
      stringify!(u)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).QuadPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER),
      "::",
      stringify!(QuadPart)
    )
  );
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
  pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
  pub u: _ULARGE_INTEGER__bindgen_ty_2,
  pub QuadPart: ULONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
  pub LowPart: DWORD,
  pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(HighPart)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
  pub LowPart: DWORD,
  pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(HighPart)
    )
  );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
  assert_eq!(
    ::std::mem::size_of::<_ULARGE_INTEGER>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER))
  );
  assert_eq!(
    ::std::mem::align_of::<_ULARGE_INTEGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ULARGE_INTEGER>())).u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER),
      "::",
      stringify!(u)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ULARGE_INTEGER>())).QuadPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER),
      "::",
      stringify!(QuadPart)
    )
  );
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
  assert_eq!(
    ::std::mem::size_of::<_LUID>(),
    8usize,
    concat!("Size of: ", stringify!(_LUID))
  );
  assert_eq!(
    ::std::mem::align_of::<_LUID>(),
    4usize,
    concat!("Alignment of ", stringify!(_LUID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID>())).LowPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID>())).HighPart as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID),
      "::",
      stringify!(HighPart)
    )
  );
}
pub type LUID = _LUID;
pub type DWORDLONG = ULONGLONG;
pub type BOOLEAN = BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
  pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_SINGLE_LIST_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SINGLE_LIST_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SINGLE_LIST_ENTRY>())).Next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SINGLE_LIST_ENTRY),
      "::",
      stringify!(Next)
    )
  );
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
  pub Data1: ::std::os::raw::c_ulong,
  pub Data2: ::std::os::raw::c_ushort,
  pub Data3: ::std::os::raw::c_ushort,
  pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
  assert_eq!(
    ::std::mem::size_of::<_GUID>(),
    16usize,
    concat!("Size of: ", stringify!(_GUID))
  );
  assert_eq!(
    ::std::mem::align_of::<_GUID>(),
    4usize,
    concat!("Alignment of ", stringify!(_GUID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data3 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data4 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data4)
    )
  );
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type CLSID = GUID;
pub type FMTID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64 {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_AMD64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).BeginAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).HandlerAddress as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_AMD64>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_AMD64>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_AMD64))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64;
pub type SCOPE_TABLE = SCOPE_TABLE_AMD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_ARM__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).BeginAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).HandlerAddress as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_ARM = _SCOPE_TABLE_ARM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64 {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_ARM64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).BeginAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).HandlerAddress as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM64>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM64>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM64))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_ARM64 = _SCOPE_TABLE_ARM64;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
  pub GenericRead: ACCESS_MASK,
  pub GenericWrite: ACCESS_MASK,
  pub GenericExecute: ACCESS_MASK,
  pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
  assert_eq!(
    ::std::mem::size_of::<_GENERIC_MAPPING>(),
    16usize,
    concat!("Size of: ", stringify!(_GENERIC_MAPPING))
  );
  assert_eq!(
    ::std::mem::align_of::<_GENERIC_MAPPING>(),
    4usize,
    concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericRead as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericRead)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericWrite as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericWrite)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericExecute as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericExecute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericAll as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericAll)
    )
  );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
  pub Luid: LUID,
  pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__LUID_AND_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_LUID_AND_ATTRIBUTES>(),
    12usize,
    concat!("Size of: ", stringify!(_LUID_AND_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_LUID_AND_ATTRIBUTES>(),
    4usize,
    concat!("Alignment of ", stringify!(_LUID_AND_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID_AND_ATTRIBUTES>())).Luid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID_AND_ATTRIBUTES),
      "::",
      stringify!(Luid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID_AND_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
  pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
  assert_eq!(
    ::std::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
    6usize,
    concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
    1usize,
    concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_IDENTIFIER_AUTHORITY>())).Value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_IDENTIFIER_AUTHORITY),
      "::",
      stringify!(Value)
    )
  );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
  pub Revision: BYTE,
  pub SubAuthorityCount: BYTE,
  pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
  pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
  assert_eq!(
    ::std::mem::size_of::<_SID>(),
    12usize,
    concat!("Size of: ", stringify!(_SID))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID>(),
    4usize,
    concat!("Alignment of ", stringify!(_SID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).SubAuthorityCount as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(SubAuthorityCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).IdentifierAuthority as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(IdentifierAuthority)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).SubAuthority as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(SubAuthority)
    )
  );
}
pub type SID = _SID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_SID {
  pub Sid: SID,
  pub Buffer: [BYTE; 68usize],
  _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_SID() {
  assert_eq!(
    ::std::mem::size_of::<_SE_SID>(),
    68usize,
    concat!("Size of: ", stringify!(_SE_SID))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_SID>(),
    4usize,
    concat!("Alignment of ", stringify!(_SE_SID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SID>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SID),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SID>())).Buffer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SID),
      "::",
      stringify!(Buffer)
    )
  );
}
pub type SE_SID = _SE_SID;
pub const _SID_NAME_USE_SidTypeUser: _SID_NAME_USE = 1;
pub const _SID_NAME_USE_SidTypeGroup: _SID_NAME_USE = 2;
pub const _SID_NAME_USE_SidTypeDomain: _SID_NAME_USE = 3;
pub const _SID_NAME_USE_SidTypeAlias: _SID_NAME_USE = 4;
pub const _SID_NAME_USE_SidTypeWellKnownGroup: _SID_NAME_USE = 5;
pub const _SID_NAME_USE_SidTypeDeletedAccount: _SID_NAME_USE = 6;
pub const _SID_NAME_USE_SidTypeInvalid: _SID_NAME_USE = 7;
pub const _SID_NAME_USE_SidTypeUnknown: _SID_NAME_USE = 8;
pub const _SID_NAME_USE_SidTypeComputer: _SID_NAME_USE = 9;
pub const _SID_NAME_USE_SidTypeLabel: _SID_NAME_USE = 10;
pub const _SID_NAME_USE_SidTypeLogonSession: _SID_NAME_USE = 11;
pub type _SID_NAME_USE = ::std::os::raw::c_int;
pub use self::_SID_NAME_USE as SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
  pub Sid: PSID,
  pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_SID_AND_ATTRIBUTES>(),
    16usize,
    concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID_AND_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_AND_ATTRIBUTES_ARRAY = [SID_AND_ATTRIBUTES; 1usize];
pub type SID_HASH_ENTRY = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
  pub SidCount: DWORD,
  pub SidAttr: PSID_AND_ATTRIBUTES,
  pub Hash: [SID_HASH_ENTRY; 32usize],
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES_HASH() {
  assert_eq!(
    ::std::mem::size_of::<_SID_AND_ATTRIBUTES_HASH>(),
    272usize,
    concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES_HASH))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID_AND_ATTRIBUTES_HASH>(),
    8usize,
    concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES_HASH))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(SidCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidAttr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(SidAttr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).Hash as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(Hash)
    )
  );
}
pub type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL {
  pub AclRevision: BYTE,
  pub Sbz1: BYTE,
  pub AclSize: WORD,
  pub AceCount: WORD,
  pub Sbz2: WORD,
}
#[test]
fn bindgen_test_layout__ACL() {
  assert_eq!(
    ::std::mem::size_of::<_ACL>(),
    8usize,
    concat!("Size of: ", stringify!(_ACL))
  );
  assert_eq!(
    ::std::mem::align_of::<_ACL>(),
    2usize,
    concat!("Alignment of ", stringify!(_ACL))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).AclRevision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AclRevision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).AclSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AclSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).AceCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).Sbz2 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(Sbz2)
    )
  );
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACE_HEADER {
  pub AceType: BYTE,
  pub AceFlags: BYTE,
  pub AceSize: WORD,
}
#[test]
fn bindgen_test_layout__ACE_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_ACE_HEADER>(),
    4usize,
    concat!("Size of: ", stringify!(_ACE_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_ACE_HEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(_ACE_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceFlags as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceSize)
    )
  );
}
pub type ACE_HEADER = _ACE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_RESOURCE_ATTRIBUTE_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SCOPED_POLICY_ID_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_SCOPED_POLICY_ID_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_MANDATORY_LABEL_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_MANDATORY_LABEL_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESS_TRUST_LABEL_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACCESS_FILTER_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ACCESS_FILTER_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).ObjectType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).InheritedObjectType as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).SidStart as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).ObjectType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).InheritedObjectType as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).SidStart as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
  pub Revision: BYTE,
  pub Sbz1: BYTE,
  pub Control: SECURITY_DESCRIPTOR_CONTROL,
  pub Owner: DWORD,
  pub Group: DWORD,
  pub Sacl: DWORD,
  pub Dacl: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR_RELATIVE() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
    20usize,
    concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Revision as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Control as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Owner as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Group as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sacl as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Sacl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Dacl as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Dacl)
    )
  );
}
pub type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR {
  pub Revision: BYTE,
  pub Sbz1: BYTE,
  pub Control: SECURITY_DESCRIPTOR_CONTROL,
  pub Owner: PSID,
  pub Group: PSID,
  pub Sacl: PACL,
  pub Dacl: PACL,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_DESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Control as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Owner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Group as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Sacl as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Sacl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Dacl as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Dacl)
    )
  );
}
pub type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_OBJECT_AI_PARAMS {
  pub Size: DWORD,
  pub ConstraintMask: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_OBJECT_AI_PARAMS() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_OBJECT_AI_PARAMS>(),
    8usize,
    concat!("Size of: ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_OBJECT_AI_PARAMS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_OBJECT_AI_PARAMS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).ConstraintMask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_OBJECT_AI_PARAMS),
      "::",
      stringify!(ConstraintMask)
    )
  );
}
pub type SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
  pub Level: WORD,
  pub Sbz: WORD,
  pub ObjectType: *mut GUID,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE_LIST() {
  assert_eq!(
    ::std::mem::size_of::<_OBJECT_TYPE_LIST>(),
    16usize,
    concat!("Size of: ", stringify!(_OBJECT_TYPE_LIST))
  );
  assert_eq!(
    ::std::mem::align_of::<_OBJECT_TYPE_LIST>(),
    8usize,
    concat!("Alignment of ", stringify!(_OBJECT_TYPE_LIST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).Sbz as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(Sbz)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).ObjectType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(ObjectType)
    )
  );
}
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
  pub PrivilegeCount: DWORD,
  pub Control: DWORD,
  pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
  assert_eq!(
    ::std::mem::size_of::<_PRIVILEGE_SET>(),
    20usize,
    concat!("Size of: ", stringify!(_PRIVILEGE_SET))
  );
  assert_eq!(
    ::std::mem::align_of::<_PRIVILEGE_SET>(),
    4usize,
    concat!("Alignment of ", stringify!(_PRIVILEGE_SET))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).PrivilegeCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(PrivilegeCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).Control as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).Privilege as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(Privilege)
    )
  );
}
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub type ACCESS_REASON = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_REASONS {
  pub Data: [ACCESS_REASON; 32usize],
}
#[test]
fn bindgen_test_layout__ACCESS_REASONS() {
  assert_eq!(
    ::std::mem::size_of::<_ACCESS_REASONS>(),
    128usize,
    concat!("Size of: ", stringify!(_ACCESS_REASONS))
  );
  assert_eq!(
    ::std::mem::align_of::<_ACCESS_REASONS>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_REASONS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACCESS_REASONS>())).Data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_REASONS),
      "::",
      stringify!(Data)
    )
  );
}
pub type PACCESS_REASONS = *mut _ACCESS_REASONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SECURITY_DESCRIPTOR {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__SE_SECURITY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_SE_SECURITY_DESCRIPTOR>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_SECURITY_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).SecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(SecurityDescriptor)
    )
  );
}
pub type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR;
pub type PSE_SECURITY_DESCRIPTOR = *mut _SE_SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REQUEST {
  pub Size: DWORD,
  pub SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
  pub DesiredAccess: ACCESS_MASK,
  pub PreviouslyGrantedAccess: ACCESS_MASK,
  pub PrincipalSelfSid: PSID,
  pub GenericMapping: PGENERIC_MAPPING,
  pub ObjectTypeListCount: DWORD,
  pub ObjectTypeList: POBJECT_TYPE_LIST,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SE_ACCESS_REQUEST>(),
    56usize,
    concat!("Size of: ", stringify!(_SE_ACCESS_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_ACCESS_REQUEST>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_ACCESS_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).SeSecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(SeSecurityDescriptor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).DesiredAccess as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(DesiredAccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).PreviouslyGrantedAccess as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(PreviouslyGrantedAccess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).PrincipalSelfSid as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(PrincipalSelfSid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).GenericMapping as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(GenericMapping)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeListCount as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(ObjectTypeListCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeList as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(ObjectTypeList)
    )
  );
}
pub type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REPLY {
  pub Size: DWORD,
  pub ResultListCount: DWORD,
  pub GrantedAccess: PACCESS_MASK,
  pub AccessStatus: PDWORD,
  pub AccessReason: PACCESS_REASONS,
  pub Privileges: *mut PPRIVILEGE_SET,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REPLY() {
  assert_eq!(
    ::std::mem::size_of::<_SE_ACCESS_REPLY>(),
    40usize,
    concat!("Size of: ", stringify!(_SE_ACCESS_REPLY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_ACCESS_REPLY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_ACCESS_REPLY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).ResultListCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(ResultListCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).GrantedAccess as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(GrantedAccess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).AccessStatus as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(AccessStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).AccessReason as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(AccessReason)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).Privileges as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(Privileges)
    )
  );
}
pub type SE_ACCESS_REPLY = _SE_ACCESS_REPLY;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous: _SECURITY_IMPERSONATION_LEVEL = 0;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification: _SECURITY_IMPERSONATION_LEVEL = 1;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation: _SECURITY_IMPERSONATION_LEVEL = 2;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation: _SECURITY_IMPERSONATION_LEVEL = 3;
pub type _SECURITY_IMPERSONATION_LEVEL = ::std::os::raw::c_int;
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
  pub User: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_USER() {
  assert_eq!(
    ::std::mem::size_of::<_TOKEN_USER>(),
    16usize,
    concat!("Size of: ", stringify!(_TOKEN_USER))
  );
  assert_eq!(
    ::std::mem::align_of::<_TOKEN_USER>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_USER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_TOKEN_USER>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_USER),
      "::",
      stringify!(User)
    )
  );
}
pub type TOKEN_USER = _TOKEN_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SE_TOKEN_USER {
  pub __bindgen_anon_1: _SE_TOKEN_USER__bindgen_ty_1,
  pub __bindgen_anon_2: _SE_TOKEN_USER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_1 {
  pub TokenUser: TOKEN_USER,
  pub User: SID_AND_ATTRIBUTES,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).TokenUser as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_1),
      "::",
      stringify!(TokenUser)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_1),
      "::",
      stringify!(User)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_2 {
  pub Sid: SID,
  pub Buffer: [BYTE; 68usize],
  _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
    68usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_2),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Buffer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_2),
      "::",
      stringify!(Buffer)
    )
  );
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER() {
  assert_eq!(
    ::std::mem::size_of::<_SE_TOKEN_USER>(),
    88usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_TOKEN_USER>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER))
  );
}
pub type SE_TOKEN_USER = _SE_TOKEN_USER;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
  pub Length: DWORD,
  pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
  pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
  pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>(),
    12usize,
    concat!("Size of: ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).Length as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ImpersonationLevel as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(ImpersonationLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ContextTrackingMode as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(ContextTrackingMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).EffectiveOnly as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(EffectiveOnly)
    )
  );
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_IMPERSONATION_STATE {
  pub Token: PACCESS_TOKEN,
  pub CopyOnOpen: BOOLEAN,
  pub EffectiveOnly: BOOLEAN,
  pub Level: SECURITY_IMPERSONATION_LEVEL,
}
#[test]
fn bindgen_test_layout__SE_IMPERSONATION_STATE() {
  assert_eq!(
    ::std::mem::size_of::<_SE_IMPERSONATION_STATE>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_IMPERSONATION_STATE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_IMPERSONATION_STATE>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_IMPERSONATION_STATE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).Token as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(Token)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).CopyOnOpen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(CopyOnOpen)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).EffectiveOnly as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(EffectiveOnly)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).Level as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(Level)
    )
  );
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureNone: _SE_IMAGE_SIGNATURE_TYPE = 0;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureEmbedded: _SE_IMAGE_SIGNATURE_TYPE = 1;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCache: _SE_IMAGE_SIGNATURE_TYPE = 2;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogCached: _SE_IMAGE_SIGNATURE_TYPE = 3;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogNotCached: _SE_IMAGE_SIGNATURE_TYPE = 4;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogHint: _SE_IMAGE_SIGNATURE_TYPE = 5;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePackageCatalog: _SE_IMAGE_SIGNATURE_TYPE = 6;
pub type _SE_IMAGE_SIGNATURE_TYPE = ::std::os::raw::c_int;
pub use self::_SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeInvalidType: _SE_LEARNING_MODE_DATA_TYPE = 0;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeSettings: _SE_LEARNING_MODE_DATA_TYPE = 1;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeMax: _SE_LEARNING_MODE_DATA_TYPE = 2;
pub type _SE_LEARNING_MODE_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_SE_LEARNING_MODE_DATA_TYPE as SE_LEARNING_MODE_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_CAPABILITIES {
  pub AppContainerSid: PSID,
  pub Capabilities: PSID_AND_ATTRIBUTES,
  pub CapabilityCount: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_CAPABILITIES() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_CAPABILITIES>(),
    24usize,
    concat!("Size of: ", stringify!(_SECURITY_CAPABILITIES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_CAPABILITIES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_CAPABILITIES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).AppContainerSid as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(AppContainerSid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).Capabilities as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(Capabilities)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).CapabilityCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(CapabilityCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).Reserved as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SILOOBJECT_BASIC_INFORMATION {
  pub SiloId: DWORD,
  pub SiloParentId: DWORD,
  pub NumberOfProcesses: DWORD,
  pub IsInServerSilo: BOOLEAN,
  pub Reserved: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__SILOOBJECT_BASIC_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SILOOBJECT_BASIC_INFORMATION>(),
    16usize,
    concat!("Size of: ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SILOOBJECT_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(SiloId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloParentId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(SiloParentId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).NumberOfProcesses as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(NumberOfProcesses)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).IsInServerSilo as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(IsInServerSilo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).Reserved as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type SILOOBJECT_BASIC_INFORMATION = _SILOOBJECT_BASIC_INFORMATION;
pub const _SERVERSILO_STATE_SERVERSILO_INITING: _SERVERSILO_STATE = 0;
pub const _SERVERSILO_STATE_SERVERSILO_STARTED: _SERVERSILO_STATE = 1;
pub const _SERVERSILO_STATE_SERVERSILO_SHUTTING_DOWN: _SERVERSILO_STATE = 2;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATING: _SERVERSILO_STATE = 3;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATED: _SERVERSILO_STATE = 4;
pub type _SERVERSILO_STATE = ::std::os::raw::c_int;
pub use self::_SERVERSILO_STATE as SERVERSILO_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVERSILO_BASIC_INFORMATION {
  pub ServiceSessionId: DWORD,
  pub State: SERVERSILO_STATE,
  pub ExitStatus: DWORD,
}
#[test]
fn bindgen_test_layout__SERVERSILO_BASIC_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SERVERSILO_BASIC_INFORMATION>(),
    12usize,
    concat!("Size of: ", stringify!(_SERVERSILO_BASIC_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVERSILO_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVERSILO_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ServiceSessionId as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(ServiceSessionId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).State as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ExitStatus as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(ExitStatus)
    )
  );
}
pub type SERVERSILO_BASIC_INFORMATION = _SERVERSILO_BASIC_INFORMATION;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorCore: _LOGICAL_PROCESSOR_RELATIONSHIP =
  0;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNode: _LOGICAL_PROCESSOR_RELATIONSHIP = 1;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationCache: _LOGICAL_PROCESSOR_RELATIONSHIP = 2;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorPackage:
  _LOGICAL_PROCESSOR_RELATIONSHIP = 3;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationGroup: _LOGICAL_PROCESSOR_RELATIONSHIP = 4;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationAll: _LOGICAL_PROCESSOR_RELATIONSHIP = 65535;
pub type _LOGICAL_PROCESSOR_RELATIONSHIP = ::std::os::raw::c_int;
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP;
pub const _PROCESSOR_CACHE_TYPE_CacheUnified: _PROCESSOR_CACHE_TYPE = 0;
pub const _PROCESSOR_CACHE_TYPE_CacheInstruction: _PROCESSOR_CACHE_TYPE = 1;
pub const _PROCESSOR_CACHE_TYPE_CacheData: _PROCESSOR_CACHE_TYPE = 2;
pub const _PROCESSOR_CACHE_TYPE_CacheTrace: _PROCESSOR_CACHE_TYPE = 3;
pub type _PROCESSOR_CACHE_TYPE = ::std::os::raw::c_int;
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
  pub Level: BYTE,
  pub Associativity: BYTE,
  pub LineSize: WORD,
  pub Size: DWORD,
  pub Type: PROCESSOR_CACHE_TYPE,
}
#[test]
fn bindgen_test_layout__CACHE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_CACHE_DESCRIPTOR>(),
    12usize,
    concat!("Size of: ", stringify!(_CACHE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_CACHE_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_CACHE_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Associativity as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Associativity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).LineSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(LineSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Type as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Type)
    )
  );
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
  pub ProcessorMask: ULONG_PTR,
  pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
  pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
  pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
  pub Cache: CACHE_DESCRIPTOR,
  pub Reserved: [ULONGLONG; 2usize],
  _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub Flags: BYTE,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
  pub NodeNumber: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>()))
        .NodeNumber as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(NodeNumber)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).ProcessorCore
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(ProcessorCore)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).NumaNode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(NumaNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Cache
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Cache)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Reserved
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).ProcessorMask as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
      "::",
      stringify!(ProcessorMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).Relationship as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
      "::",
      stringify!(Relationship)
    )
  );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_RELATIONSHIP {
  pub Flags: BYTE,
  pub EfficiencyClass: BYTE,
  pub Reserved: [BYTE; 20usize],
  pub GroupCount: WORD,
  pub GroupMask: [GROUP_AFFINITY; 1usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_PROCESSOR_RELATIONSHIP>(),
    40usize,
    concat!("Size of: ", stringify!(_PROCESSOR_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_PROCESSOR_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).EfficiencyClass as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(EfficiencyClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupCount as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(GroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NUMA_NODE_RELATIONSHIP {
  pub NodeNumber: DWORD,
  pub Reserved: [BYTE; 20usize],
  pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__NUMA_NODE_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_NUMA_NODE_RELATIONSHIP>(),
    40usize,
    concat!("Size of: ", stringify!(_NUMA_NODE_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_NUMA_NODE_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_NUMA_NODE_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).NodeNumber as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(NodeNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).GroupMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_RELATIONSHIP {
  pub Level: BYTE,
  pub Associativity: BYTE,
  pub LineSize: WORD,
  pub CacheSize: DWORD,
  pub Type: PROCESSOR_CACHE_TYPE,
  pub Reserved: [BYTE; 20usize],
  pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__CACHE_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_CACHE_RELATIONSHIP>(),
    48usize,
    concat!("Size of: ", stringify!(_CACHE_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_CACHE_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_CACHE_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Associativity as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Associativity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).LineSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(LineSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).CacheSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(CacheSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Type as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Reserved as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).GroupMask as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
  pub MaximumProcessorCount: BYTE,
  pub ActiveProcessorCount: BYTE,
  pub Reserved: [BYTE; 38usize],
  pub ActiveProcessorMask: KAFFINITY,
}
#[test]
fn bindgen_test_layout__PROCESSOR_GROUP_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_PROCESSOR_GROUP_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_PROCESSOR_GROUP_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_PROCESSOR_GROUP_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_GROUP_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).MaximumProcessorCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(MaximumProcessorCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorCount as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(ActiveProcessorCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).Reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorMask as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(ActiveProcessorMask)
    )
  );
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
  pub MaximumGroupCount: WORD,
  pub ActiveGroupCount: WORD,
  pub Reserved: [BYTE; 20usize],
  pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__GROUP_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_GROUP_RELATIONSHIP>(),
    72usize,
    concat!("Size of: ", stringify!(_GROUP_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_GROUP_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_GROUP_RELATIONSHIP))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).MaximumGroupCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(MaximumGroupCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).ActiveGroupCount as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(ActiveGroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).GroupInfo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(GroupInfo)
    )
  );
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
  pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
  pub Size: DWORD,
  pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
  pub Processor: PROCESSOR_RELATIONSHIP,
  pub NumaNode: NUMA_NODE_RELATIONSHIP,
  pub Cache: CACHE_RELATIONSHIP,
  pub Group: GROUP_RELATIONSHIP,
  _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Processor
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Processor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).NumaNode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(NumaNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Cache
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Cache)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Group
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Group)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
    80usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Relationship as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
      "::",
      stringify!(Relationship)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
      "::",
      stringify!(Size)
    )
  );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const _CPU_SET_INFORMATION_TYPE_CpuSetInformation: _CPU_SET_INFORMATION_TYPE = 0;
pub type _CPU_SET_INFORMATION_TYPE = ::std::os::raw::c_int;
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
  pub Size: DWORD,
  pub Type: CPU_SET_INFORMATION_TYPE,
  pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
  pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub Id: DWORD,
  pub Group: WORD,
  pub LogicalProcessorIndex: BYTE,
  pub CoreIndex: BYTE,
  pub LastLevelCacheIndex: BYTE,
  pub NumaNodeIndex: BYTE,
  pub EfficiencyClass: BYTE,
  pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  pub __bindgen_anon_2: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
  pub AllocationTag: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub AllFlags: BYTE,
  pub __bindgen_anon_1:
    _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
  assert_eq!(
    ::std::mem::size_of::<
      _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
      )
    )
  );
  assert_eq!(
    ::std::mem::align_of::<
      _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
      )
    )
  );
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn Parked(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_Parked(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Allocated(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_Allocated(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AllocatedToTargetProcess(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_AllocatedToTargetProcess(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn RealTime(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_RealTime(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(4usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Parked: BYTE,
    Allocated: BYTE,
    AllocatedToTargetProcess: BYTE,
    RealTime: BYTE,
    ReservedFlags: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Parked: u8 = unsafe { ::std::mem::transmute(Parked) };
      Parked as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let Allocated: u8 = unsafe { ::std::mem::transmute(Allocated) };
      Allocated as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let AllocatedToTargetProcess: u8 = unsafe { ::std::mem::transmute(AllocatedToTargetProcess) };
      AllocatedToTargetProcess as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let RealTime: u8 = unsafe { ::std::mem::transmute(RealTime) };
      RealTime as u64
    });
    __bindgen_bitfield_unit.set(4usize, 4u8, {
      let ReservedFlags: u8 = unsafe { ::std::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
      )))
      .AllFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AllFlags)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
  pub Reserved: DWORD,
  pub SchedulingClass: BYTE,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
      )))
      .Reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
      )))
      .SchedulingClass as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(SchedulingClass)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Id
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Id)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Group
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .LogicalProcessorIndex as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LogicalProcessorIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).CoreIndex
        as *const _ as usize
    },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(CoreIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .LastLevelCacheIndex as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LastLevelCacheIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .NumaNodeIndex as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(NumaNodeIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .EfficiencyClass as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(EfficiencyClass)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .AllocationTag as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AllocationTag)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>())).CpuSet as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(CpuSet)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION>(),
    32usize,
    concat!("Size of: ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Type as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION),
      "::",
      stringify!(Type)
    )
  );
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
  pub CycleTime: DWORD64,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>())).CycleTime as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION),
      "::",
      stringify!(CycleTime)
    )
  );
}
pub type SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_INPUT {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub MaximumIos: DWORD,
  pub ObjectId: [DWORD; 4usize],
  pub Reserved: [DWORD; 25usize],
  pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_DATA_INPUT>(),
    944usize,
    concat!("Size of: ", stringify!(_SCRUB_DATA_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_DATA_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCRUB_DATA_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).MaximumIos as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(MaximumIos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).ObjectId as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(ObjectId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Reserved as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).ResumeContext as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(ResumeContext)
    )
  );
}
pub type SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT {
  pub Offset: LONGLONG,
  pub Length: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_PARITY_EXTENT>(),
    16usize,
    concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_PARITY_EXTENT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT>())).Offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT>())).Length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT),
      "::",
      stringify!(Length)
    )
  );
}
pub type SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT_DATA {
  pub Size: WORD,
  pub Flags: WORD,
  pub NumberOfParityExtents: WORD,
  pub MaximumNumberOfParityExtents: WORD,
  pub ParityExtents: [SCRUB_PARITY_EXTENT; 1usize],
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_PARITY_EXTENT_DATA>(),
    24usize,
    concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_PARITY_EXTENT_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Flags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).NumberOfParityExtents as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(NumberOfParityExtents)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).MaximumNumberOfParityExtents as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(MaximumNumberOfParityExtents)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).ParityExtents as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(ParityExtents)
    )
  );
}
pub type SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_OUTPUT {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Status: DWORD,
  pub ErrorFileOffset: ULONGLONG,
  pub ErrorLength: ULONGLONG,
  pub NumberOfBytesRepaired: ULONGLONG,
  pub NumberOfBytesFailed: ULONGLONG,
  pub InternalFileReference: ULONGLONG,
  pub ResumeContextLength: WORD,
  pub ParityExtentDataOffset: WORD,
  pub Reserved: [DWORD; 9usize],
  pub NumberOfMetadataBytesProcessed: ULONGLONG,
  pub NumberOfDataBytesProcessed: ULONGLONG,
  pub TotalNumberOfMetadataBytesInUse: ULONGLONG,
  pub TotalNumberOfDataBytesInUse: ULONGLONG,
  pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_DATA_OUTPUT>(),
    944usize,
    concat!("Size of: ", stringify!(_SCRUB_DATA_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_DATA_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_DATA_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Status as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Status)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorFileOffset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ErrorFileOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ErrorLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesRepaired as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfBytesRepaired)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesFailed as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfBytesFailed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).InternalFileReference as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(InternalFileReference)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContextLength as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ResumeContextLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ParityExtentDataOffset as *const _ as usize
    },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ParityExtentDataOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Reserved as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfMetadataBytesProcessed as *const _
        as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfMetadataBytesProcessed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfDataBytesProcessed as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfDataBytesProcessed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).TotalNumberOfMetadataBytesInUse as *const _
        as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(TotalNumberOfMetadataBytesInUse)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).TotalNumberOfDataBytesInUse as *const _
        as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(TotalNumberOfDataBytesInUse)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContext as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ResumeContext)
    )
  );
}
pub type SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksUnsupported:
  _SharedVirtualDiskSupportType = 0;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksSupported: _SharedVirtualDiskSupportType =
  1;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskSnapshotsSupported:
  _SharedVirtualDiskSupportType = 3;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskCDPSnapshotsSupported:
  _SharedVirtualDiskSupportType = 7;
pub type _SharedVirtualDiskSupportType = ::std::os::raw::c_int;
pub use self::_SharedVirtualDiskSupportType as SharedVirtualDiskSupportType;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateNone:
  _SharedVirtualDiskHandleState = 0;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateFileShared:
  _SharedVirtualDiskHandleState = 1;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateHandleShared:
  _SharedVirtualDiskHandleState = 3;
pub type _SharedVirtualDiskHandleState = ::std::os::raw::c_int;
pub use self::_SharedVirtualDiskHandleState as SharedVirtualDiskHandleState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARED_VIRTUAL_DISK_SUPPORT {
  pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
  pub HandleState: SharedVirtualDiskHandleState,
}
#[test]
fn bindgen_test_layout__SHARED_VIRTUAL_DISK_SUPPORT() {
  assert_eq!(
    ::std::mem::size_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
    8usize,
    concat!("Size of: ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).SharedVirtualDiskSupport as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
      "::",
      stringify!(SharedVirtualDiskSupport)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).HandleState as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
      "::",
      stringify!(HandleState)
    )
  );
}
pub type SHARED_VIRTUAL_DISK_SUPPORT = _SHARED_VIRTUAL_DISK_SUPPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHUFFLE_FILE_DATA {
  pub StartingOffset: LONGLONG,
  pub Length: LONGLONG,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__SHUFFLE_FILE_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SHUFFLE_FILE_DATA>(),
    24usize,
    concat!("Size of: ", stringify!(_SHUFFLE_FILE_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHUFFLE_FILE_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHUFFLE_FILE_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).StartingOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHUFFLE_FILE_DATA),
      "::",
      stringify!(StartingOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).Length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHUFFLE_FILE_DATA),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).Flags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHUFFLE_FILE_DATA),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SHUFFLE_FILE_DATA = _SHUFFLE_FILE_DATA;
pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified: _SYSTEM_POWER_STATE = 0;
pub const _SYSTEM_POWER_STATE_PowerSystemWorking: _SYSTEM_POWER_STATE = 1;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1: _SYSTEM_POWER_STATE = 2;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2: _SYSTEM_POWER_STATE = 3;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3: _SYSTEM_POWER_STATE = 4;
pub const _SYSTEM_POWER_STATE_PowerSystemHibernate: _SYSTEM_POWER_STATE = 5;
pub const _SYSTEM_POWER_STATE_PowerSystemShutdown: _SYSTEM_POWER_STATE = 6;
pub const _SYSTEM_POWER_STATE_PowerSystemMaximum: _SYSTEM_POWER_STATE = 7;
pub type _SYSTEM_POWER_STATE = ::std::os::raw::c_int;
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub const POWER_ACTION_PowerActionNone: POWER_ACTION = 0;
pub const POWER_ACTION_PowerActionReserved: POWER_ACTION = 1;
pub const POWER_ACTION_PowerActionSleep: POWER_ACTION = 2;
pub const POWER_ACTION_PowerActionHibernate: POWER_ACTION = 3;
pub const POWER_ACTION_PowerActionShutdown: POWER_ACTION = 4;
pub const POWER_ACTION_PowerActionShutdownReset: POWER_ACTION = 5;
pub const POWER_ACTION_PowerActionShutdownOff: POWER_ACTION = 6;
pub const POWER_ACTION_PowerActionWarmEject: POWER_ACTION = 7;
pub const POWER_ACTION_PowerActionDisplayOff: POWER_ACTION = 8;
pub type POWER_ACTION = ::std::os::raw::c_int;
pub const SYSTEM_POWER_CONDITION_PoAc: SYSTEM_POWER_CONDITION = 0;
pub const SYSTEM_POWER_CONDITION_PoDc: SYSTEM_POWER_CONDITION = 1;
pub const SYSTEM_POWER_CONDITION_PoHot: SYSTEM_POWER_CONDITION = 2;
pub const SYSTEM_POWER_CONDITION_PoConditionMaximum: SYSTEM_POWER_CONDITION = 3;
pub type SYSTEM_POWER_CONDITION = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SET_POWER_SETTING_VALUE {
  pub Version: DWORD,
  pub Guid: GUID,
  pub PowerCondition: SYSTEM_POWER_CONDITION,
  pub DataLength: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_SET_POWER_SETTING_VALUE() {
  assert_eq!(
    ::std::mem::size_of::<SET_POWER_SETTING_VALUE>(),
    32usize,
    concat!("Size of: ", stringify!(SET_POWER_SETTING_VALUE))
  );
  assert_eq!(
    ::std::mem::align_of::<SET_POWER_SETTING_VALUE>(),
    4usize,
    concat!("Alignment of ", stringify!(SET_POWER_SETTING_VALUE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Guid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Guid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).PowerCondition as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(PowerCondition)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).DataLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(DataLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Data)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
  pub Granularity: DWORD,
  pub Capacity: DWORD,
}
#[test]
fn bindgen_test_layout_BATTERY_REPORTING_SCALE() {
  assert_eq!(
    ::std::mem::size_of::<BATTERY_REPORTING_SCALE>(),
    8usize,
    concat!("Size of: ", stringify!(BATTERY_REPORTING_SCALE))
  );
  assert_eq!(
    ::std::mem::align_of::<BATTERY_REPORTING_SCALE>(),
    4usize,
    concat!("Alignment of ", stringify!(BATTERY_REPORTING_SCALE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<BATTERY_REPORTING_SCALE>())).Granularity as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(BATTERY_REPORTING_SCALE),
      "::",
      stringify!(Granularity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<BATTERY_REPORTING_SCALE>())).Capacity as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(BATTERY_REPORTING_SCALE),
      "::",
      stringify!(Capacity)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POWER_ACTION_POLICY {
  pub Action: POWER_ACTION,
  pub Flags: DWORD,
  pub EventCode: DWORD,
}
#[test]
fn bindgen_test_layout_POWER_ACTION_POLICY() {
  assert_eq!(
    ::std::mem::size_of::<POWER_ACTION_POLICY>(),
    12usize,
    concat!("Size of: ", stringify!(POWER_ACTION_POLICY))
  );
  assert_eq!(
    ::std::mem::align_of::<POWER_ACTION_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(POWER_ACTION_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).Action as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(Action)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).EventCode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(EventCode)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_LEVEL {
  pub Enable: BOOLEAN,
  pub Spare: [BYTE; 3usize],
  pub BatteryLevel: DWORD,
  pub PowerPolicy: POWER_ACTION_POLICY,
  pub MinSystemState: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_LEVEL() {
  assert_eq!(
    ::std::mem::size_of::<SYSTEM_POWER_LEVEL>(),
    24usize,
    concat!("Size of: ", stringify!(SYSTEM_POWER_LEVEL))
  );
  assert_eq!(
    ::std::mem::align_of::<SYSTEM_POWER_LEVEL>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_POWER_LEVEL))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).Enable as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(Enable)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).Spare as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(Spare)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).BatteryLevel as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(BatteryLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).PowerPolicy as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(PowerPolicy)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).MinSystemState as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(MinSystemState)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_POLICY {
  pub Revision: DWORD,
  pub PowerButton: POWER_ACTION_POLICY,
  pub SleepButton: POWER_ACTION_POLICY,
  pub LidClose: POWER_ACTION_POLICY,
  pub LidOpenWake: SYSTEM_POWER_STATE,
  pub Reserved: DWORD,
  pub Idle: POWER_ACTION_POLICY,
  pub IdleTimeout: DWORD,
  pub IdleSensitivity: BYTE,
  pub DynamicThrottle: BYTE,
  pub Spare2: [BYTE; 2usize],
  pub MinSleep: SYSTEM_POWER_STATE,
  pub MaxSleep: SYSTEM_POWER_STATE,
  pub ReducedLatencySleep: SYSTEM_POWER_STATE,
  pub WinLogonFlags: DWORD,
  pub Spare3: DWORD,
  pub DozeS4Timeout: DWORD,
  pub BroadcastCapacityResolution: DWORD,
  pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
  pub VideoTimeout: DWORD,
  pub VideoDimDisplay: BOOLEAN,
  pub VideoReserved: [DWORD; 3usize],
  pub SpindownTimeout: DWORD,
  pub OptimizeForPower: BOOLEAN,
  pub FanThrottleTolerance: BYTE,
  pub ForcedThrottle: BYTE,
  pub MinThrottle: BYTE,
  pub OverThrottled: POWER_ACTION_POLICY,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_POLICY() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_POWER_POLICY>(),
    232usize,
    concat!("Size of: ", stringify!(_SYSTEM_POWER_POLICY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_POWER_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_POWER_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).PowerButton as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(PowerButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).SleepButton as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(SleepButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).LidClose as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(LidClose)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).LidOpenWake as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(LidOpenWake)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Reserved as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Idle as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Idle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleTimeout as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(IdleTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleSensitivity as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(IdleSensitivity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DynamicThrottle as *const _ as usize
    },
    65usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DynamicThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Spare2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MinSleep as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MinSleep)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MaxSleep as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MaxSleep)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).ReducedLatencySleep as *const _ as usize
    },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(ReducedLatencySleep)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).WinLogonFlags as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(WinLogonFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare3 as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Spare3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DozeS4Timeout as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DozeS4Timeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).BroadcastCapacityResolution as *const _
        as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(BroadcastCapacityResolution)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DischargePolicy as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DischargePolicy)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoTimeout as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoDimDisplay as *const _ as usize
    },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoDimDisplay)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoReserved as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).SpindownTimeout as *const _ as usize
    },
    212usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(SpindownTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).OptimizeForPower as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(OptimizeForPower)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).FanThrottleTolerance as *const _ as usize
    },
    217usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(FanThrottleTolerance)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).ForcedThrottle as *const _ as usize },
    218usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(ForcedThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MinThrottle as *const _ as usize },
    219usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MinThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).OverThrottled as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(OverThrottled)
    )
  );
}
pub type SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_CAPABILITIES {
  pub PowerButtonPresent: BOOLEAN,
  pub SleepButtonPresent: BOOLEAN,
  pub LidPresent: BOOLEAN,
  pub SystemS1: BOOLEAN,
  pub SystemS2: BOOLEAN,
  pub SystemS3: BOOLEAN,
  pub SystemS4: BOOLEAN,
  pub SystemS5: BOOLEAN,
  pub HiberFilePresent: BOOLEAN,
  pub FullWake: BOOLEAN,
  pub VideoDimPresent: BOOLEAN,
  pub ApmPresent: BOOLEAN,
  pub UpsPresent: BOOLEAN,
  pub ThermalControl: BOOLEAN,
  pub ProcessorThrottle: BOOLEAN,
  pub ProcessorMinThrottle: BYTE,
  pub ProcessorMaxThrottle: BYTE,
  pub FastSystemS4: BOOLEAN,
  pub Hiberboot: BOOLEAN,
  pub WakeAlarmPresent: BOOLEAN,
  pub AoAc: BOOLEAN,
  pub DiskSpinDown: BOOLEAN,
  pub HiberFileType: BYTE,
  pub AoAcConnectivitySupported: BOOLEAN,
  pub spare3: [BYTE; 6usize],
  pub SystemBatteriesPresent: BOOLEAN,
  pub BatteriesAreShortTerm: BOOLEAN,
  pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
  pub AcOnLineWake: SYSTEM_POWER_STATE,
  pub SoftLidWake: SYSTEM_POWER_STATE,
  pub RtcWake: SYSTEM_POWER_STATE,
  pub MinDeviceWakeState: SYSTEM_POWER_STATE,
  pub DefaultLowLatencyWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_CAPABILITIES() {
  assert_eq!(
    ::std::mem::size_of::<SYSTEM_POWER_CAPABILITIES>(),
    76usize,
    concat!("Size of: ", stringify!(SYSTEM_POWER_CAPABILITIES))
  );
  assert_eq!(
    ::std::mem::align_of::<SYSTEM_POWER_CAPABILITIES>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_POWER_CAPABILITIES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).PowerButtonPresent as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(PowerButtonPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SleepButtonPresent as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SleepButtonPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).LidPresent as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(LidPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS1 as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS3 as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS4 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS5 as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFilePresent as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(HiberFilePresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FullWake as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(FullWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).VideoDimPresent as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(VideoDimPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ApmPresent as *const _ as usize
    },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ApmPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).UpsPresent as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(UpsPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ThermalControl as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ThermalControl)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorThrottle as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMinThrottle as *const _
        as usize
    },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorMinThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMaxThrottle as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorMaxThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FastSystemS4 as *const _ as usize
    },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(FastSystemS4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).Hiberboot as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(Hiberboot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).WakeAlarmPresent as *const _ as usize
    },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(WakeAlarmPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAc as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AoAc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DiskSpinDown as *const _ as usize
    },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(DiskSpinDown)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFileType as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(HiberFileType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAcConnectivitySupported as *const _
        as usize
    },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AoAcConnectivitySupported)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).spare3 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(spare3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemBatteriesPresent as *const _
        as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemBatteriesPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteriesAreShortTerm as *const _
        as usize
    },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(BatteriesAreShortTerm)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteryScale as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(BatteryScale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AcOnLineWake as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AcOnLineWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SoftLidWake as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SoftLidWake)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).RtcWake as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(RtcWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).MinDeviceWakeState as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(MinDeviceWakeState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DefaultLowLatencyWake as *const _
        as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(DefaultLowLatencyWake)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_BATTERY_STATE {
  pub AcOnLine: BOOLEAN,
  pub BatteryPresent: BOOLEAN,
  pub Charging: BOOLEAN,
  pub Discharging: BOOLEAN,
  pub Spare1: [BOOLEAN; 3usize],
  pub Tag: BYTE,
  pub MaxCapacity: DWORD,
  pub RemainingCapacity: DWORD,
  pub Rate: DWORD,
  pub EstimatedTime: DWORD,
  pub DefaultAlert1: DWORD,
  pub DefaultAlert2: DWORD,
}
#[test]
fn bindgen_test_layout_SYSTEM_BATTERY_STATE() {
  assert_eq!(
    ::std::mem::size_of::<SYSTEM_BATTERY_STATE>(),
    32usize,
    concat!("Size of: ", stringify!(SYSTEM_BATTERY_STATE))
  );
  assert_eq!(
    ::std::mem::align_of::<SYSTEM_BATTERY_STATE>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_BATTERY_STATE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).AcOnLine as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(AcOnLine)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).BatteryPresent as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(BatteryPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Charging as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Charging)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Discharging as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Discharging)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Spare1 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Spare1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Tag as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Tag)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).MaxCapacity as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(MaxCapacity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).RemainingCapacity as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(RemainingCapacity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Rate as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Rate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).EstimatedTime as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(EstimatedTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert1 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(DefaultAlert1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert2 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(DefaultAlert2)
    )
  );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
  pub Next: *mut _SLIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SLIST_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_ENTRY>(),
    16usize,
    concat!("Alignment of ", stringify!(_SLIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SLIST_ENTRY>())).Next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_ENTRY),
      "::",
      stringify!(Next)
    )
  );
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
  pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
  pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
  _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
  pub Alignment: ULONGLONG,
  pub Region: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Alignment as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER__bindgen_ty_1),
      "::",
      stringify!(Alignment)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Region as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER__bindgen_ty_1),
      "::",
      stringify!(Region)
    )
  );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize], u64>,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_2>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_2>(),
    8usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_2))
  );
}
impl _SLIST_HEADER__bindgen_ty_2 {
  #[inline]
  pub fn Depth(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
  }
  #[inline]
  pub fn set_Depth(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn Sequence(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
  }
  #[inline]
  pub fn set_Sequence(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(16usize, 48u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(64usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn NextEntry(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
  }
  #[inline]
  pub fn set_NextEntry(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(68usize, 60u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Depth: ULONGLONG,
    Sequence: ULONGLONG,
    Reserved: ULONGLONG,
    NextEntry: ULONGLONG,
  ) -> __BindgenBitfieldUnit<[u8; 16usize], u64> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize], u64> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
      Depth as u64
    });
    __bindgen_bitfield_unit.set(16usize, 48u8, {
      let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
      Sequence as u64
    });
    __bindgen_bitfield_unit.set(64usize, 4u8, {
      let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit.set(68usize, 60u8, {
      let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
      NextEntry as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_HEADER>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_HEADER>(),
    16usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SLIST_HEADER>())).HeaderX64 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER),
      "::",
      stringify!(HeaderX64)
    )
  );
}
pub type SLIST_HEADER = _SLIST_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BARRIER {
  pub Reserved1: DWORD,
  pub Reserved2: DWORD,
  pub Reserved3: [ULONG_PTR; 2usize],
  pub Reserved4: DWORD,
  pub Reserved5: DWORD,
}
#[test]
fn bindgen_test_layout__RTL_BARRIER() {
  assert_eq!(
    ::std::mem::size_of::<_RTL_BARRIER>(),
    32usize,
    concat!("Size of: ", stringify!(_RTL_BARRIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_RTL_BARRIER>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_BARRIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved3 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved4 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved5 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved5)
    )
  );
}
pub type RTL_BARRIER = _RTL_BARRIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
  pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_SRWLOCK() {
  assert_eq!(
    ::std::mem::size_of::<_RTL_SRWLOCK>(),
    8usize,
    concat!("Size of: ", stringify!(_RTL_SRWLOCK))
  );
  assert_eq!(
    ::std::mem::align_of::<_RTL_SRWLOCK>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_SRWLOCK))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_SRWLOCK>())).Ptr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_SRWLOCK),
      "::",
      stringify!(Ptr)
    )
  );
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SUPPORTED_OS_INFO {
  pub MajorVersion: WORD,
  pub MinorVersion: WORD,
}
#[test]
fn bindgen_test_layout__SUPPORTED_OS_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SUPPORTED_OS_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SUPPORTED_OS_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SUPPORTED_OS_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_SUPPORTED_OS_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SUPPORTED_OS_INFO>())).MajorVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SUPPORTED_OS_INFO),
      "::",
      stringify!(MajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SUPPORTED_OS_INFO>())).MinorVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SUPPORTED_OS_INFO),
      "::",
      stringify!(MinorVersion)
    )
  );
}
pub type SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO;
pub const _CM_SERVICE_NODE_TYPE_DriverType: _CM_SERVICE_NODE_TYPE = 1;
pub const _CM_SERVICE_NODE_TYPE_FileSystemType: _CM_SERVICE_NODE_TYPE = 2;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceOwnProcess: _CM_SERVICE_NODE_TYPE = 16;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceShareProcess: _CM_SERVICE_NODE_TYPE = 32;
pub const _CM_SERVICE_NODE_TYPE_AdapterType: _CM_SERVICE_NODE_TYPE = 4;
pub const _CM_SERVICE_NODE_TYPE_RecognizerType: _CM_SERVICE_NODE_TYPE = 8;
pub type _CM_SERVICE_NODE_TYPE = ::std::os::raw::c_int;
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
pub const _CM_SERVICE_LOAD_TYPE_BootLoad: _CM_SERVICE_LOAD_TYPE = 0;
pub const _CM_SERVICE_LOAD_TYPE_SystemLoad: _CM_SERVICE_LOAD_TYPE = 1;
pub const _CM_SERVICE_LOAD_TYPE_AutoLoad: _CM_SERVICE_LOAD_TYPE = 2;
pub const _CM_SERVICE_LOAD_TYPE_DemandLoad: _CM_SERVICE_LOAD_TYPE = 3;
pub const _CM_SERVICE_LOAD_TYPE_DisableLoad: _CM_SERVICE_LOAD_TYPE = 4;
pub type _CM_SERVICE_LOAD_TYPE = ::std::os::raw::c_int;
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
pub const _CM_ERROR_CONTROL_TYPE_IgnoreError: _CM_ERROR_CONTROL_TYPE = 0;
pub const _CM_ERROR_CONTROL_TYPE_NormalError: _CM_ERROR_CONTROL_TYPE = 1;
pub const _CM_ERROR_CONTROL_TYPE_SevereError: _CM_ERROR_CONTROL_TYPE = 2;
pub const _CM_ERROR_CONTROL_TYPE_CriticalError: _CM_ERROR_CONTROL_TYPE = 3;
pub type _CM_ERROR_CONTROL_TYPE = ::std::os::raw::c_int;
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
pub type SAVEPOINT_ID = ULONG;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
pub type SPHANDLE = *mut HANDLE;
pub type HGLOBAL = HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKEY__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HKEY__() {
  assert_eq!(
    ::std::mem::size_of::<HKEY__>(),
    4usize,
    concat!("Size of: ", stringify!(HKEY__))
  );
  assert_eq!(
    ::std::mem::align_of::<HKEY__>(),
    4usize,
    concat!("Alignment of ", stringify!(HKEY__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HKEY__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HKEY__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HKEY = *mut HKEY__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
  assert_eq!(
    ::std::mem::size_of::<HINSTANCE__>(),
    4usize,
    concat!("Size of: ", stringify!(HINSTANCE__))
  );
  assert_eq!(
    ::std::mem::align_of::<HINSTANCE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HINSTANCE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HINSTANCE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HINSTANCE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
  pub dwLowDateTime: DWORD,
  pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
  assert_eq!(
    ::std::mem::size_of::<_FILETIME>(),
    8usize,
    concat!("Size of: ", stringify!(_FILETIME))
  );
  assert_eq!(
    ::std::mem::align_of::<_FILETIME>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILETIME))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FILETIME>())).dwLowDateTime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILETIME),
      "::",
      stringify!(dwLowDateTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FILETIME>())).dwHighDateTime as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILETIME),
      "::",
      stringify!(dwHighDateTime)
    )
  );
}
pub type FILETIME = _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWND__() {
  assert_eq!(
    ::std::mem::size_of::<HWND__>(),
    4usize,
    concat!("Size of: ", stringify!(HWND__))
  );
  assert_eq!(
    ::std::mem::align_of::<HWND__>(),
    4usize,
    concat!("Alignment of ", stringify!(HWND__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HWND__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HWND__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBITMAP__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HBITMAP__() {
  assert_eq!(
    ::std::mem::size_of::<HBITMAP__>(),
    4usize,
    concat!("Size of: ", stringify!(HBITMAP__))
  );
  assert_eq!(
    ::std::mem::align_of::<HBITMAP__>(),
    4usize,
    concat!("Alignment of ", stringify!(HBITMAP__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HBITMAP__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HBITMAP__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HENHMETAFILE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HENHMETAFILE__() {
  assert_eq!(
    ::std::mem::size_of::<HENHMETAFILE__>(),
    4usize,
    concat!("Size of: ", stringify!(HENHMETAFILE__))
  );
  assert_eq!(
    ::std::mem::align_of::<HENHMETAFILE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HENHMETAFILE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HENHMETAFILE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HENHMETAFILE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HENHMETAFILE = *mut HENHMETAFILE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HICON__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HICON__() {
  assert_eq!(
    ::std::mem::size_of::<HICON__>(),
    4usize,
    concat!("Size of: ", stringify!(HICON__))
  );
  assert_eq!(
    ::std::mem::align_of::<HICON__>(),
    4usize,
    concat!("Alignment of ", stringify!(HICON__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HICON__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HICON__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRECT {
  pub left: LONG,
  pub top: LONG,
  pub right: LONG,
  pub bottom: LONG,
}
#[test]
fn bindgen_test_layout_tagRECT() {
  assert_eq!(
    ::std::mem::size_of::<tagRECT>(),
    16usize,
    concat!("Size of: ", stringify!(tagRECT))
  );
  assert_eq!(
    ::std::mem::align_of::<tagRECT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRECT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).left as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(left)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).top as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(top)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).right as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(right)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).bottom as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(bottom)
    )
  );
}
pub type RECT = tagRECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSIZE {
  pub cx: LONG,
  pub cy: LONG,
}
#[test]
fn bindgen_test_layout_tagSIZE() {
  assert_eq!(
    ::std::mem::size_of::<tagSIZE>(),
    8usize,
    concat!("Size of: ", stringify!(tagSIZE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSIZE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSIZE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSIZE>())).cx as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSIZE),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSIZE>())).cy as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSIZE),
      "::",
      stringify!(cy)
    )
  );
}
pub type SIZE = tagSIZE;
pub type SIZEL = SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_ATTRIBUTES {
  pub nLength: DWORD,
  pub lpSecurityDescriptor: LPVOID,
  pub bInheritHandle: BOOL,
}
#[test]
fn bindgen_test_layout__SECURITY_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_ATTRIBUTES>(),
    24usize,
    concat!("Size of: ", stringify!(_SECURITY_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_ATTRIBUTES>())).nLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(nLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_ATTRIBUTES>())).lpSecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(lpSecurityDescriptor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_ATTRIBUTES>())).bInheritHandle as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(bInheritHandle)
    )
  );
}
pub type SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES;
pub type LPSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OVERLAPPED {
  pub Internal: ULONG_PTR,
  pub InternalHigh: ULONG_PTR,
  pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1,
  pub hEvent: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OVERLAPPED__bindgen_ty_1 {
  pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1,
  pub Pointer: PVOID,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OVERLAPPED__bindgen_ty_1__bindgen_ty_1 {
  pub Offset: DWORD,
  pub OffsetHigh: DWORD,
}
#[test]
fn bindgen_test_layout__OVERLAPPED__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>())).Offset as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>())).OffsetHigh as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(OffsetHigh)
    )
  );
}
#[test]
fn bindgen_test_layout__OVERLAPPED__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_OVERLAPPED__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_OVERLAPPED__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_OVERLAPPED__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_OVERLAPPED__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED__bindgen_ty_1>())).Pointer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1),
      "::",
      stringify!(Pointer)
    )
  );
}
#[test]
fn bindgen_test_layout__OVERLAPPED() {
  assert_eq!(
    ::std::mem::size_of::<_OVERLAPPED>(),
    32usize,
    concat!("Size of: ", stringify!(_OVERLAPPED))
  );
  assert_eq!(
    ::std::mem::align_of::<_OVERLAPPED>(),
    8usize,
    concat!("Alignment of ", stringify!(_OVERLAPPED))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED>())).Internal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(Internal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED>())).InternalHigh as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(InternalHigh)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED>())).hEvent as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(hEvent)
    )
  );
}
pub type LPOVERLAPPED = *mut _OVERLAPPED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEMTIME {
  pub wYear: WORD,
  pub wMonth: WORD,
  pub wDayOfWeek: WORD,
  pub wDay: WORD,
  pub wHour: WORD,
  pub wMinute: WORD,
  pub wSecond: WORD,
  pub wMilliseconds: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEMTIME() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEMTIME>(),
    16usize,
    concat!("Size of: ", stringify!(_SYSTEMTIME))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEMTIME>(),
    2usize,
    concat!("Alignment of ", stringify!(_SYSTEMTIME))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wYear as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wYear)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wMonth as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMonth)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wDayOfWeek as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wDayOfWeek)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wDay as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wDay)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wHour as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wHour)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wMinute as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMinute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wSecond as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wSecond)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wMilliseconds as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMilliseconds)
    )
  );
}
pub type SYSTEMTIME = _SYSTEMTIME;
pub const _STREAM_INFO_LEVELS_FindStreamInfoStandard: _STREAM_INFO_LEVELS = 0;
pub const _STREAM_INFO_LEVELS_FindStreamInfoMaxInfoLevel: _STREAM_INFO_LEVELS = 1;
pub type _STREAM_INFO_LEVELS = ::std::os::raw::c_int;
pub use self::_STREAM_INFO_LEVELS as STREAM_INFO_LEVELS;
pub type SRWLOCK = RTL_SRWLOCK;
pub type SYNCHRONIZATION_BARRIER = RTL_BARRIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_INFORMATION {
  pub hProcess: HANDLE,
  pub hThread: HANDLE,
  pub dwProcessId: DWORD,
  pub dwThreadId: DWORD,
}
#[test]
fn bindgen_test_layout__PROCESS_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_PROCESS_INFORMATION>(),
    24usize,
    concat!("Size of: ", stringify!(_PROCESS_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_PROCESS_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESS_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).hProcess as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(hProcess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).hThread as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(hThread)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).dwProcessId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(dwProcessId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).dwThreadId as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(dwThreadId)
    )
  );
}
pub type LPPROCESS_INFORMATION = *mut _PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOA {
  pub cb: DWORD,
  pub lpReserved: LPSTR,
  pub lpDesktop: LPSTR,
  pub lpTitle: LPSTR,
  pub dwX: DWORD,
  pub dwY: DWORD,
  pub dwXSize: DWORD,
  pub dwYSize: DWORD,
  pub dwXCountChars: DWORD,
  pub dwYCountChars: DWORD,
  pub dwFillAttribute: DWORD,
  pub dwFlags: DWORD,
  pub wShowWindow: WORD,
  pub cbReserved2: WORD,
  pub lpReserved2: LPBYTE,
  pub hStdInput: HANDLE,
  pub hStdOutput: HANDLE,
  pub hStdError: HANDLE,
}
#[test]
fn bindgen_test_layout__STARTUPINFOA() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOA>(),
    104usize,
    concat!("Size of: ", stringify!(_STARTUPINFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpReserved as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpDesktop as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpDesktop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpTitle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwX as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwX)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwY as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwY)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwXSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwXSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwYSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwYSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwXCountChars as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwXCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwYCountChars as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwYCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwFillAttribute as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwFillAttribute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwFlags as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).wShowWindow as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(wShowWindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).cbReserved2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(cbReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpReserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).hStdInput as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdInput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).hStdOutput as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).hStdError as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdError)
    )
  );
}
pub type STARTUPINFOA = _STARTUPINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOW {
  pub cb: DWORD,
  pub lpReserved: LPWSTR,
  pub lpDesktop: LPWSTR,
  pub lpTitle: LPWSTR,
  pub dwX: DWORD,
  pub dwY: DWORD,
  pub dwXSize: DWORD,
  pub dwYSize: DWORD,
  pub dwXCountChars: DWORD,
  pub dwYCountChars: DWORD,
  pub dwFillAttribute: DWORD,
  pub dwFlags: DWORD,
  pub wShowWindow: WORD,
  pub cbReserved2: WORD,
  pub lpReserved2: LPBYTE,
  pub hStdInput: HANDLE,
  pub hStdOutput: HANDLE,
  pub hStdError: HANDLE,
}
#[test]
fn bindgen_test_layout__STARTUPINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOW>(),
    104usize,
    concat!("Size of: ", stringify!(_STARTUPINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpReserved as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpDesktop as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpDesktop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpTitle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwX as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwX)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwY as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwY)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwXSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwXSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwYSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwYSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwXCountChars as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwXCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwYCountChars as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwYCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwFillAttribute as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwFillAttribute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwFlags as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).wShowWindow as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(wShowWindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).cbReserved2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(cbReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpReserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).hStdInput as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdInput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).hStdOutput as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).hStdError as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdError)
    )
  );
}
pub type STARTUPINFOW = _STARTUPINFOW;
pub type LPSTARTUPINFOW = *mut _STARTUPINFOW;
pub type STARTUPINFO = STARTUPINFOW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE_LIST {
  _unused: [u8; 0],
}
pub type LPPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_INFO {
  pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1,
  pub dwPageSize: DWORD,
  pub lpMinimumApplicationAddress: LPVOID,
  pub lpMaximumApplicationAddress: LPVOID,
  pub dwActiveProcessorMask: DWORD_PTR,
  pub dwNumberOfProcessors: DWORD,
  pub dwProcessorType: DWORD,
  pub dwAllocationGranularity: DWORD,
  pub wProcessorLevel: WORD,
  pub wProcessorRevision: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_INFO__bindgen_ty_1 {
  pub dwOemId: DWORD,
  pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1 {
  pub wProcessorArchitecture: WORD,
  pub wReserved: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>())).wProcessorArchitecture
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wProcessorArchitecture)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>())).wReserved as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO__bindgen_ty_1>())).dwOemId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1),
      "::",
      stringify!(dwOemId)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SYSTEM_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwPageSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwPageSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO>())).lpMinimumApplicationAddress as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(lpMinimumApplicationAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO>())).lpMaximumApplicationAddress as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(lpMaximumApplicationAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwActiveProcessorMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwActiveProcessorMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwNumberOfProcessors as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwNumberOfProcessors)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwProcessorType as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwProcessorType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwAllocationGranularity as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwAllocationGranularity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).wProcessorLevel as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(wProcessorLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).wProcessorRevision as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(wProcessorRevision)
    )
  );
}
pub type SYSTEM_INFO = _SYSTEM_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOEXA {
  pub StartupInfo: STARTUPINFOA,
  pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
#[test]
fn bindgen_test_layout__STARTUPINFOEXA() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOEXA>(),
    112usize,
    concat!("Size of: ", stringify!(_STARTUPINFOEXA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOEXA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOEXA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXA>())).StartupInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXA),
      "::",
      stringify!(StartupInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXA>())).lpAttributeList as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXA),
      "::",
      stringify!(lpAttributeList)
    )
  );
}
pub type STARTUPINFOEXA = _STARTUPINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOEXW {
  pub StartupInfo: STARTUPINFOW,
  pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
#[test]
fn bindgen_test_layout__STARTUPINFOEXW() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOEXW>(),
    112usize,
    concat!("Size of: ", stringify!(_STARTUPINFOEXW))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOEXW>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOEXW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXW>())).StartupInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXW),
      "::",
      stringify!(StartupInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXW>())).lpAttributeList as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXW),
      "::",
      stringify!(lpAttributeList)
    )
  );
}
pub type STARTUPINFOEXW = _STARTUPINFOEXW;
pub type STARTUPINFOEX = STARTUPINFOEXW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_STATUS {
  pub ACLineStatus: BYTE,
  pub BatteryFlag: BYTE,
  pub BatteryLifePercent: BYTE,
  pub SystemStatusFlag: BYTE,
  pub BatteryLifeTime: DWORD,
  pub BatteryFullLifeTime: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_POWER_STATUS>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_POWER_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_POWER_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_POWER_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).ACLineStatus as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(ACLineStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryFlag as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryFlag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryLifePercent as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryLifePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).SystemStatusFlag as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(SystemStatusFlag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryLifeTime as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryLifeTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryFullLifeTime as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryFullLifeTime)
    )
  );
}
pub type SYSTEM_POWER_STATUS = _SYSTEM_POWER_STATUS;
pub type SENDASYNCPROC = ::std::option::Option<
  unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: ULONG_PTR, arg4: LRESULT),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHELLHOOKINFO {
  pub hwnd: HWND,
  pub rc: RECT,
}
#[test]
fn bindgen_test_layout_SHELLHOOKINFO() {
  assert_eq!(
    ::std::mem::size_of::<SHELLHOOKINFO>(),
    24usize,
    concat!("Size of: ", stringify!(SHELLHOOKINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<SHELLHOOKINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(SHELLHOOKINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SHELLHOOKINFO>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHELLHOOKINFO),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SHELLHOOKINFO>())).rc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHELLHOOKINFO),
      "::",
      stringify!(rc)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLESTRUCT {
  pub styleOld: DWORD,
  pub styleNew: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTYLESTRUCT() {
  assert_eq!(
    ::std::mem::size_of::<tagSTYLESTRUCT>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTYLESTRUCT))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTYLESTRUCT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLESTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLESTRUCT>())).styleOld as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLESTRUCT),
      "::",
      stringify!(styleOld)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLESTRUCT>())).styleNew as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLESTRUCT),
      "::",
      stringify!(styleNew)
    )
  );
}
pub type STYLESTRUCT = tagSTYLESTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSCROLLINFO {
  pub cbSize: UINT,
  pub fMask: UINT,
  pub nMin: ::std::os::raw::c_int,
  pub nMax: ::std::os::raw::c_int,
  pub nPage: UINT,
  pub nPos: ::std::os::raw::c_int,
  pub nTrackPos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tagSCROLLINFO() {
  assert_eq!(
    ::std::mem::size_of::<tagSCROLLINFO>(),
    28usize,
    concat!("Size of: ", stringify!(tagSCROLLINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSCROLLINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSCROLLINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nMin as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nMin)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nMax as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nPage as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nPage)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nPos as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nTrackPos as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nTrackPos)
    )
  );
}
pub type SCROLLINFO = tagSCROLLINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALKEYSA {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszActivePort: LPSTR,
  pub lpszPort: LPSTR,
  pub iBaudRate: UINT,
  pub iPortState: UINT,
  pub iActive: UINT,
}
#[test]
fn bindgen_test_layout_tagSERIALKEYSA() {
  assert_eq!(
    ::std::mem::size_of::<tagSERIALKEYSA>(),
    40usize,
    concat!("Size of: ", stringify!(tagSERIALKEYSA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSERIALKEYSA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSERIALKEYSA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).lpszActivePort as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(lpszActivePort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).lpszPort as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(lpszPort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).iBaudRate as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iBaudRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).iPortState as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iPortState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).iActive as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iActive)
    )
  );
}
pub type SERIALKEYSA = tagSERIALKEYSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALKEYSW {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszActivePort: LPWSTR,
  pub lpszPort: LPWSTR,
  pub iBaudRate: UINT,
  pub iPortState: UINT,
  pub iActive: UINT,
}
#[test]
fn bindgen_test_layout_tagSERIALKEYSW() {
  assert_eq!(
    ::std::mem::size_of::<tagSERIALKEYSW>(),
    40usize,
    concat!("Size of: ", stringify!(tagSERIALKEYSW))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSERIALKEYSW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSERIALKEYSW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).lpszActivePort as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(lpszActivePort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).lpszPort as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(lpszPort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).iBaudRate as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iBaudRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).iPortState as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iPortState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).iActive as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iActive)
    )
  );
}
pub type SERIALKEYSW = tagSERIALKEYSW;
pub type SERIALKEYS = SERIALKEYSW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTICKYKEYS {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTICKYKEYS() {
  assert_eq!(
    ::std::mem::size_of::<tagSTICKYKEYS>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTICKYKEYS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTICKYKEYS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTICKYKEYS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTICKYKEYS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTICKYKEYS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTICKYKEYS>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTICKYKEYS),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type STICKYKEYS = tagSTICKYKEYS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOUNDSENTRYA {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iFSTextEffect: DWORD,
  pub iFSTextEffectMSec: DWORD,
  pub iFSTextEffectColorBits: DWORD,
  pub iFSGrafEffect: DWORD,
  pub iFSGrafEffectMSec: DWORD,
  pub iFSGrafEffectColor: DWORD,
  pub iWindowsEffect: DWORD,
  pub iWindowsEffectMSec: DWORD,
  pub lpszWindowsEffectDLL: LPSTR,
  pub iWindowsEffectOrdinal: DWORD,
}
#[test]
fn bindgen_test_layout_tagSOUNDSENTRYA() {
  assert_eq!(
    ::std::mem::size_of::<tagSOUNDSENTRYA>(),
    56usize,
    concat!("Size of: ", stringify!(tagSOUNDSENTRYA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOUNDSENTRYA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOUNDSENTRYA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffect as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffectMSec as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffectColorBits as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffectColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffect as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffectMSec as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffectMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffectColor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffectColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffect as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffectMSec as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).lpszWindowsEffectDLL as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(lpszWindowsEffectDLL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffectOrdinal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffectOrdinal)
    )
  );
}
pub type SOUNDSENTRYA = tagSOUNDSENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOUNDSENTRYW {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iFSTextEffect: DWORD,
  pub iFSTextEffectMSec: DWORD,
  pub iFSTextEffectColorBits: DWORD,
  pub iFSGrafEffect: DWORD,
  pub iFSGrafEffectMSec: DWORD,
  pub iFSGrafEffectColor: DWORD,
  pub iWindowsEffect: DWORD,
  pub iWindowsEffectMSec: DWORD,
  pub lpszWindowsEffectDLL: LPWSTR,
  pub iWindowsEffectOrdinal: DWORD,
}
#[test]
fn bindgen_test_layout_tagSOUNDSENTRYW() {
  assert_eq!(
    ::std::mem::size_of::<tagSOUNDSENTRYW>(),
    56usize,
    concat!("Size of: ", stringify!(tagSOUNDSENTRYW))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOUNDSENTRYW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOUNDSENTRYW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffect as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffectMSec as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffectColorBits as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffectColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffect as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffectMSec as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffectMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffectColor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffectColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffect as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffectMSec as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).lpszWindowsEffectDLL as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(lpszWindowsEffectDLL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffectOrdinal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffectOrdinal)
    )
  );
}
pub type SOUNDSENTRYW = tagSOUNDSENTRYW;
pub type SOUNDSENTRY = SOUNDSENTRYW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSCROLLBARINFO {
  pub cbSize: DWORD,
  pub rcScrollBar: RECT,
  pub dxyLineButton: ::std::os::raw::c_int,
  pub xyThumbTop: ::std::os::raw::c_int,
  pub xyThumbBottom: ::std::os::raw::c_int,
  pub reserved: ::std::os::raw::c_int,
  pub rgstate: [DWORD; 6usize],
}
#[test]
fn bindgen_test_layout_tagSCROLLBARINFO() {
  assert_eq!(
    ::std::mem::size_of::<tagSCROLLBARINFO>(),
    60usize,
    concat!("Size of: ", stringify!(tagSCROLLBARINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSCROLLBARINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSCROLLBARINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).rcScrollBar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(rcScrollBar)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).dxyLineButton as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(dxyLineButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).xyThumbTop as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(xyThumbTop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).xyThumbBottom as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(xyThumbBottom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).reserved as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).rgstate as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(rgstate)
    )
  );
}
pub type SCROLLBARINFO = tagSCROLLBARINFO;
pub const SYSNLS_FUNCTION_COMPARE_STRING: SYSNLS_FUNCTION = 1;
pub type SYSNLS_FUNCTION = ::std::os::raw::c_int;
pub const SYSGEOTYPE_GEO_NATION: SYSGEOTYPE = 1;
pub const SYSGEOTYPE_GEO_LATITUDE: SYSGEOTYPE = 2;
pub const SYSGEOTYPE_GEO_LONGITUDE: SYSGEOTYPE = 3;
pub const SYSGEOTYPE_GEO_ISO2: SYSGEOTYPE = 4;
pub const SYSGEOTYPE_GEO_ISO3: SYSGEOTYPE = 5;
pub const SYSGEOTYPE_GEO_RFC1766: SYSGEOTYPE = 6;
pub const SYSGEOTYPE_GEO_LCID: SYSGEOTYPE = 7;
pub const SYSGEOTYPE_GEO_FRIENDLYNAME: SYSGEOTYPE = 8;
pub const SYSGEOTYPE_GEO_OFFICIALNAME: SYSGEOTYPE = 9;
pub const SYSGEOTYPE_GEO_TIMEZONES: SYSGEOTYPE = 10;
pub const SYSGEOTYPE_GEO_OFFICIALLANGUAGES: SYSGEOTYPE = 11;
pub const SYSGEOTYPE_GEO_ISO_UN_NUMBER: SYSGEOTYPE = 12;
pub const SYSGEOTYPE_GEO_PARENT: SYSGEOTYPE = 13;
pub const SYSGEOTYPE_GEO_DIALINGCODE: SYSGEOTYPE = 14;
pub const SYSGEOTYPE_GEO_CURRENCYCODE: SYSGEOTYPE = 15;
pub const SYSGEOTYPE_GEO_CURRENCYSYMBOL: SYSGEOTYPE = 16;
pub const SYSGEOTYPE_GEO_NAME: SYSGEOTYPE = 17;
pub const SYSGEOTYPE_GEO_ID: SYSGEOTYPE = 18;
pub type SYSGEOTYPE = ::std::os::raw::c_int;
pub const SYSGEOCLASS_GEOCLASS_NATION: SYSGEOCLASS = 16;
pub const SYSGEOCLASS_GEOCLASS_REGION: SYSGEOCLASS = 14;
pub const SYSGEOCLASS_GEOCLASS_ALL: SYSGEOCLASS = 0;
pub type SYSGEOCLASS = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMALL_RECT {
  pub Left: SHORT,
  pub Top: SHORT,
  pub Right: SHORT,
  pub Bottom: SHORT,
}
#[test]
fn bindgen_test_layout__SMALL_RECT() {
  assert_eq!(
    ::std::mem::size_of::<_SMALL_RECT>(),
    8usize,
    concat!("Size of: ", stringify!(_SMALL_RECT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SMALL_RECT>(),
    2usize,
    concat!("Alignment of ", stringify!(_SMALL_RECT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Left as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Left)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Top as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Top)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Right as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Right)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Bottom as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Bottom)
    )
  );
}
pub type SMALL_RECT = _SMALL_RECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SESSION_HEADER {
  pub sess_name: UCHAR,
  pub num_sess: UCHAR,
  pub rcv_dg_outstanding: UCHAR,
  pub rcv_any_outstanding: UCHAR,
}
#[test]
fn bindgen_test_layout__SESSION_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_SESSION_HEADER>(),
    4usize,
    concat!("Size of: ", stringify!(_SESSION_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SESSION_HEADER>(),
    1usize,
    concat!("Alignment of ", stringify!(_SESSION_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).sess_name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(sess_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).num_sess as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(num_sess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).rcv_dg_outstanding as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(rcv_dg_outstanding)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).rcv_any_outstanding as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(rcv_any_outstanding)
    )
  );
}
pub type SESSION_HEADER = _SESSION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SESSION_BUFFER {
  pub lsn: UCHAR,
  pub state: UCHAR,
  pub local_name: [UCHAR; 16usize],
  pub remote_name: [UCHAR; 16usize],
  pub rcvs_outstanding: UCHAR,
  pub sends_outstanding: UCHAR,
}
#[test]
fn bindgen_test_layout__SESSION_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_SESSION_BUFFER>(),
    36usize,
    concat!("Size of: ", stringify!(_SESSION_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SESSION_BUFFER>(),
    1usize,
    concat!("Alignment of ", stringify!(_SESSION_BUFFER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).lsn as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(lsn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).state as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).local_name as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(local_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).remote_name as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(remote_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).rcvs_outstanding as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(rcvs_outstanding)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).sends_outstanding as *const _ as usize },
    35usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(sends_outstanding)
    )
  );
}
pub type SESSION_BUFFER = _SESSION_BUFFER;
pub type I_RPC_HANDLE = *mut ::std::os::raw::c_void;
pub type RPC_BINDING_HANDLE = I_RPC_HANDLE;
pub type handle_t = RPC_BINDING_HANDLE;
pub type UUID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_W {
  pub User: *mut ::std::os::raw::c_ushort,
  pub UserLength: ::std::os::raw::c_ulong,
  pub Domain: *mut ::std::os::raw::c_ushort,
  pub DomainLength: ::std::os::raw::c_ulong,
  pub Password: *mut ::std::os::raw::c_ushort,
  pub PasswordLength: ::std::os::raw::c_ulong,
  pub Flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__SEC_WINNT_AUTH_IDENTITY_W() {
  assert_eq!(
    ::std::mem::size_of::<_SEC_WINNT_AUTH_IDENTITY_W>(),
    48usize,
    concat!("Size of: ", stringify!(_SEC_WINNT_AUTH_IDENTITY_W))
  );
  assert_eq!(
    ::std::mem::align_of::<_SEC_WINNT_AUTH_IDENTITY_W>(),
    8usize,
    concat!("Alignment of ", stringify!(_SEC_WINNT_AUTH_IDENTITY_W))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(User)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).UserLength as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(UserLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).Domain as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(Domain)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).DomainLength as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(DomainLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).Password as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(Password)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).PasswordLength as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(PasswordLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).Flags as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SEC_WINNT_AUTH_IDENTITY_W = _SEC_WINNT_AUTH_IDENTITY_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_A {
  pub User: *mut ::std::os::raw::c_uchar,
  pub UserLength: ::std::os::raw::c_ulong,
  pub Domain: *mut ::std::os::raw::c_uchar,
  pub DomainLength: ::std::os::raw::c_ulong,
  pub Password: *mut ::std::os::raw::c_uchar,
  pub PasswordLength: ::std::os::raw::c_ulong,
  pub Flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__SEC_WINNT_AUTH_IDENTITY_A() {
  assert_eq!(
    ::std::mem::size_of::<_SEC_WINNT_AUTH_IDENTITY_A>(),
    48usize,
    concat!("Size of: ", stringify!(_SEC_WINNT_AUTH_IDENTITY_A))
  );
  assert_eq!(
    ::std::mem::align_of::<_SEC_WINNT_AUTH_IDENTITY_A>(),
    8usize,
    concat!("Alignment of ", stringify!(_SEC_WINNT_AUTH_IDENTITY_A))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(User)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).UserLength as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(UserLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).Domain as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(Domain)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).DomainLength as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(DomainLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).Password as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(Password)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).PasswordLength as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(PasswordLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).Flags as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SEC_WINNT_AUTH_IDENTITY_A = _SEC_WINNT_AUTH_IDENTITY_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_VERSION {
  pub MajorVersion: ::std::os::raw::c_ushort,
  pub MinorVersion: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__RPC_VERSION() {
  assert_eq!(
    ::std::mem::size_of::<_RPC_VERSION>(),
    4usize,
    concat!("Size of: ", stringify!(_RPC_VERSION))
  );
  assert_eq!(
    ::std::mem::align_of::<_RPC_VERSION>(),
    2usize,
    concat!("Alignment of ", stringify!(_RPC_VERSION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_VERSION>())).MajorVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_VERSION),
      "::",
      stringify!(MajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_VERSION>())).MinorVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_VERSION),
      "::",
      stringify!(MinorVersion)
    )
  );
}
pub type RPC_VERSION = _RPC_VERSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_SYNTAX_IDENTIFIER {
  pub SyntaxGUID: GUID,
  pub SyntaxVersion: RPC_VERSION,
}
#[test]
fn bindgen_test_layout__RPC_SYNTAX_IDENTIFIER() {
  assert_eq!(
    ::std::mem::size_of::<_RPC_SYNTAX_IDENTIFIER>(),
    20usize,
    concat!("Size of: ", stringify!(_RPC_SYNTAX_IDENTIFIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_RPC_SYNTAX_IDENTIFIER>(),
    4usize,
    concat!("Alignment of ", stringify!(_RPC_SYNTAX_IDENTIFIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_SYNTAX_IDENTIFIER>())).SyntaxGUID as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_SYNTAX_IDENTIFIER),
      "::",
      stringify!(SyntaxGUID)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_RPC_SYNTAX_IDENTIFIER>())).SyntaxVersion as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_SYNTAX_IDENTIFIER),
      "::",
      stringify!(SyntaxVersion)
    )
  );
}
pub type PRPC_SYNTAX_IDENTIFIER = *mut _RPC_SYNTAX_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_MESSAGE {
  pub Handle: RPC_BINDING_HANDLE,
  pub DataRepresentation: ::std::os::raw::c_ulong,
  pub Buffer: *mut ::std::os::raw::c_void,
  pub BufferLength: ::std::os::raw::c_uint,
  pub ProcNum: ::std::os::raw::c_uint,
  pub TransferSyntax: PRPC_SYNTAX_IDENTIFIER,
  pub RpcInterfaceInformation: *mut ::std::os::raw::c_void,
  pub ReservedForRuntime: *mut ::std::os::raw::c_void,
  pub ManagerEpv: *mut ::std::os::raw::c_void,
  pub ImportContext: *mut ::std::os::raw::c_void,
  pub RpcFlags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__RPC_MESSAGE() {
  assert_eq!(
    ::std::mem::size_of::<_RPC_MESSAGE>(),
    80usize,
    concat!("Size of: ", stringify!(_RPC_MESSAGE))
  );
  assert_eq!(
    ::std::mem::align_of::<_RPC_MESSAGE>(),
    8usize,
    concat!("Alignment of ", stringify!(_RPC_MESSAGE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).Handle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(Handle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).DataRepresentation as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(DataRepresentation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).Buffer as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(Buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).BufferLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(BufferLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ProcNum as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ProcNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).TransferSyntax as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(TransferSyntax)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_RPC_MESSAGE>())).RpcInterfaceInformation as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(RpcInterfaceInformation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ReservedForRuntime as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ReservedForRuntime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ManagerEpv as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ManagerEpv)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ImportContext as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ImportContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).RpcFlags as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(RpcFlags)
    )
  );
}
pub type PRPC_MESSAGE = *mut _RPC_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AppBarData {
  pub cbSize: DWORD,
  pub hWnd: HWND,
  pub uCallbackMessage: UINT,
  pub uEdge: UINT,
  pub rc: RECT,
  pub lParam: LPARAM,
}
#[test]
fn bindgen_test_layout__AppBarData() {
  assert_eq!(
    ::std::mem::size_of::<_AppBarData>(),
    48usize,
    concat!("Size of: ", stringify!(_AppBarData))
  );
  assert_eq!(
    ::std::mem::align_of::<_AppBarData>(),
    8usize,
    concat!("Alignment of ", stringify!(_AppBarData))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).hWnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(hWnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).uCallbackMessage as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(uCallbackMessage)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).uEdge as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(uEdge)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).rc as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(rc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).lParam as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(lParam)
    )
  );
}
pub type PAPPBARDATA = *mut _AppBarData;
extern "C" {
  pub fn SHAppBarMessage(dwMessage: DWORD, pData: PAPPBARDATA) -> UINT_PTR;
}
pub type FILEOP_FLAGS = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEOPSTRUCTA {
  pub hwnd: HWND,
  pub wFunc: UINT,
  pub pFrom: PCZZSTR,
  pub pTo: PCZZSTR,
  pub fFlags: FILEOP_FLAGS,
  pub fAnyOperationsAborted: BOOL,
  pub hNameMappings: LPVOID,
  pub lpszProgressTitle: PCSTR,
}
#[test]
fn bindgen_test_layout__SHFILEOPSTRUCTA() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEOPSTRUCTA>(),
    56usize,
    concat!("Size of: ", stringify!(_SHFILEOPSTRUCTA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEOPSTRUCTA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEOPSTRUCTA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).wFunc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(wFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).pFrom as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(pFrom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).pTo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(pTo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).fFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).fAnyOperationsAborted as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(fAnyOperationsAborted)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).hNameMappings as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(hNameMappings)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).lpszProgressTitle as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(lpszProgressTitle)
    )
  );
}
pub type SHFILEOPSTRUCTA = _SHFILEOPSTRUCTA;
pub type LPSHFILEOPSTRUCTA = *mut _SHFILEOPSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEOPSTRUCTW {
  pub hwnd: HWND,
  pub wFunc: UINT,
  pub pFrom: PCZZWSTR,
  pub pTo: PCZZWSTR,
  pub fFlags: FILEOP_FLAGS,
  pub fAnyOperationsAborted: BOOL,
  pub hNameMappings: LPVOID,
  pub lpszProgressTitle: PCWSTR,
}
#[test]
fn bindgen_test_layout__SHFILEOPSTRUCTW() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEOPSTRUCTW>(),
    56usize,
    concat!("Size of: ", stringify!(_SHFILEOPSTRUCTW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEOPSTRUCTW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEOPSTRUCTW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).wFunc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(wFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).pFrom as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(pFrom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).pTo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(pTo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).fFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).fAnyOperationsAborted as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(fAnyOperationsAborted)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).hNameMappings as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(hNameMappings)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).lpszProgressTitle as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(lpszProgressTitle)
    )
  );
}
pub type SHFILEOPSTRUCTW = _SHFILEOPSTRUCTW;
pub type LPSHFILEOPSTRUCTW = *mut _SHFILEOPSTRUCTW;
pub type SHFILEOPSTRUCT = SHFILEOPSTRUCTW;
extern "C" {
  pub fn SHFileOperationA(lpFileOp: LPSHFILEOPSTRUCTA) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SHFileOperationW(lpFileOp: LPSHFILEOPSTRUCTW) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SHFreeNameMappings(hNameMappings: HANDLE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHNAMEMAPPINGA {
  pub pszOldPath: LPSTR,
  pub pszNewPath: LPSTR,
  pub cchOldPath: ::std::os::raw::c_int,
  pub cchNewPath: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__SHNAMEMAPPINGA() {
  assert_eq!(
    ::std::mem::size_of::<_SHNAMEMAPPINGA>(),
    24usize,
    concat!("Size of: ", stringify!(_SHNAMEMAPPINGA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHNAMEMAPPINGA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHNAMEMAPPINGA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).pszOldPath as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(pszOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).pszNewPath as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(pszNewPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).cchOldPath as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(cchOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).cchNewPath as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(cchNewPath)
    )
  );
}
pub type SHNAMEMAPPINGA = _SHNAMEMAPPINGA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHNAMEMAPPINGW {
  pub pszOldPath: LPWSTR,
  pub pszNewPath: LPWSTR,
  pub cchOldPath: ::std::os::raw::c_int,
  pub cchNewPath: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__SHNAMEMAPPINGW() {
  assert_eq!(
    ::std::mem::size_of::<_SHNAMEMAPPINGW>(),
    24usize,
    concat!("Size of: ", stringify!(_SHNAMEMAPPINGW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHNAMEMAPPINGW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHNAMEMAPPINGW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).pszOldPath as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(pszOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).pszNewPath as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(pszNewPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).cchOldPath as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(cchOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).cchNewPath as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(cchNewPath)
    )
  );
}
pub type SHNAMEMAPPINGW = _SHNAMEMAPPINGW;
pub type SHNAMEMAPPING = SHNAMEMAPPINGW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHELLEXECUTEINFOA {
  pub cbSize: DWORD,
  pub fMask: ULONG,
  pub hwnd: HWND,
  pub lpVerb: LPCSTR,
  pub lpFile: LPCSTR,
  pub lpParameters: LPCSTR,
  pub lpDirectory: LPCSTR,
  pub nShow: ::std::os::raw::c_int,
  pub hInstApp: HINSTANCE,
  pub lpIDList: *mut ::std::os::raw::c_void,
  pub lpClass: LPCSTR,
  pub hkeyClass: HKEY,
  pub dwHotKey: DWORD,
  pub __bindgen_anon_1: _SHELLEXECUTEINFOA__bindgen_ty_1,
  pub hProcess: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SHELLEXECUTEINFOA__bindgen_ty_1 {
  pub hIcon: HANDLE,
  pub hMonitor: HANDLE,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOA__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOA__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOA__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOA__bindgen_ty_1>())).hIcon as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOA__bindgen_ty_1>())).hMonitor as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1),
      "::",
      stringify!(hMonitor)
    )
  );
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOA() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOA>(),
    112usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHELLEXECUTEINFOA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpVerb as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpVerb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpParameters as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpParameters)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpDirectory as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).nShow as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(nShow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hInstApp as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hInstApp)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpIDList as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpIDList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpClass as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hkeyClass as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hkeyClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).dwHotKey as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(dwHotKey)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hProcess as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hProcess)
    )
  );
}
pub type SHELLEXECUTEINFOA = _SHELLEXECUTEINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHELLEXECUTEINFOW {
  pub cbSize: DWORD,
  pub fMask: ULONG,
  pub hwnd: HWND,
  pub lpVerb: LPCWSTR,
  pub lpFile: LPCWSTR,
  pub lpParameters: LPCWSTR,
  pub lpDirectory: LPCWSTR,
  pub nShow: ::std::os::raw::c_int,
  pub hInstApp: HINSTANCE,
  pub lpIDList: *mut ::std::os::raw::c_void,
  pub lpClass: LPCWSTR,
  pub hkeyClass: HKEY,
  pub dwHotKey: DWORD,
  pub __bindgen_anon_1: _SHELLEXECUTEINFOW__bindgen_ty_1,
  pub hProcess: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SHELLEXECUTEINFOW__bindgen_ty_1 {
  pub hIcon: HANDLE,
  pub hMonitor: HANDLE,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOW__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOW__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOW__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOW__bindgen_ty_1>())).hIcon as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOW__bindgen_ty_1>())).hMonitor as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1),
      "::",
      stringify!(hMonitor)
    )
  );
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOW>(),
    112usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHELLEXECUTEINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpVerb as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpVerb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpParameters as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpParameters)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpDirectory as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).nShow as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(nShow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hInstApp as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hInstApp)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpIDList as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpIDList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpClass as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hkeyClass as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hkeyClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).dwHotKey as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(dwHotKey)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hProcess as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hProcess)
    )
  );
}
pub type SHELLEXECUTEINFOW = _SHELLEXECUTEINFOW;
pub type SHELLEXECUTEINFO = SHELLEXECUTEINFOW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHCREATEPROCESSINFOW {
  pub cbSize: DWORD,
  pub fMask: ULONG,
  pub hwnd: HWND,
  pub pszFile: LPCWSTR,
  pub pszParameters: LPCWSTR,
  pub pszCurrentDirectory: LPCWSTR,
  pub hUserToken: HANDLE,
  pub lpProcessAttributes: LPSECURITY_ATTRIBUTES,
  pub lpThreadAttributes: LPSECURITY_ATTRIBUTES,
  pub bInheritHandles: BOOL,
  pub dwCreationFlags: DWORD,
  pub lpStartupInfo: LPSTARTUPINFOW,
  pub lpProcessInformation: LPPROCESS_INFORMATION,
}
#[test]
fn bindgen_test_layout__SHCREATEPROCESSINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SHCREATEPROCESSINFOW>(),
    88usize,
    concat!("Size of: ", stringify!(_SHCREATEPROCESSINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHCREATEPROCESSINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHCREATEPROCESSINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).pszFile as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(pszFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).pszParameters as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(pszParameters)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).pszCurrentDirectory as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(pszCurrentDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).hUserToken as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(hUserToken)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpProcessAttributes as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpProcessAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpThreadAttributes as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpThreadAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).bInheritHandles as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(bInheritHandles)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).dwCreationFlags as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(dwCreationFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpStartupInfo as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpStartupInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpProcessInformation as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpProcessInformation)
    )
  );
}
pub type SHCREATEPROCESSINFOW = _SHCREATEPROCESSINFOW;
pub type PSHCREATEPROCESSINFOW = *mut _SHCREATEPROCESSINFOW;
extern "C" {
  pub fn SHCreateProcessAsUserW(pscpi: PSHCREATEPROCESSINFOW) -> BOOL;
}
extern "C" {
  pub fn SHEvaluateSystemCommandTemplate(
    pszCmdTemplate: PCWSTR,
    ppszApplication: *mut PWSTR,
    ppszCommandLine: *mut PWSTR,
    ppszParameters: *mut PWSTR,
  ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHQUERYRBINFO {
  pub cbSize: DWORD,
  pub i64Size: ::std::os::raw::c_longlong,
  pub i64NumItems: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__SHQUERYRBINFO() {
  assert_eq!(
    ::std::mem::size_of::<_SHQUERYRBINFO>(),
    24usize,
    concat!("Size of: ", stringify!(_SHQUERYRBINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHQUERYRBINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHQUERYRBINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHQUERYRBINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHQUERYRBINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHQUERYRBINFO>())).i64Size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHQUERYRBINFO),
      "::",
      stringify!(i64Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHQUERYRBINFO>())).i64NumItems as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHQUERYRBINFO),
      "::",
      stringify!(i64NumItems)
    )
  );
}
pub type SHQUERYRBINFO = _SHQUERYRBINFO;
pub type LPSHQUERYRBINFO = *mut _SHQUERYRBINFO;
extern "C" {
  pub fn SHQueryRecycleBinA(pszRootPath: LPCSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) -> HRESULT;
}
extern "C" {
  pub fn SHQueryRecycleBinW(pszRootPath: LPCWSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) -> HRESULT;
}
extern "C" {
  pub fn SHEmptyRecycleBinA(hwnd: HWND, pszRootPath: LPCSTR, dwFlags: DWORD) -> HRESULT;
}
extern "C" {
  pub fn SHEmptyRecycleBinW(hwnd: HWND, pszRootPath: LPCWSTR, dwFlags: DWORD) -> HRESULT;
}
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_NOT_PRESENT: QUERY_USER_NOTIFICATION_STATE = 1;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_BUSY: QUERY_USER_NOTIFICATION_STATE = 2;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_RUNNING_D3D_FULL_SCREEN:
  QUERY_USER_NOTIFICATION_STATE = 3;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_PRESENTATION_MODE: QUERY_USER_NOTIFICATION_STATE = 4;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_ACCEPTS_NOTIFICATIONS: QUERY_USER_NOTIFICATION_STATE =
  5;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_QUIET_TIME: QUERY_USER_NOTIFICATION_STATE = 6;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_APP: QUERY_USER_NOTIFICATION_STATE = 7;
pub type QUERY_USER_NOTIFICATION_STATE = ::std::os::raw::c_int;
extern "C" {
  pub fn SHQueryUserNotificationState(pquns: *mut QUERY_USER_NOTIFICATION_STATE) -> HRESULT;
}
extern "C" {
  pub fn SHGetPropertyStoreForWindow(
    hwnd: HWND,
    riid: *const IID,
    ppv: *mut *mut ::std::os::raw::c_void,
  ) -> HRESULT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHFILEINFOA {
  pub hIcon: HICON,
  pub iIcon: ::std::os::raw::c_int,
  pub dwAttributes: DWORD,
  pub szDisplayName: [CHAR; 260usize],
  pub szTypeName: [CHAR; 80usize],
}
#[test]
fn bindgen_test_layout__SHFILEINFOA() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEINFOA>(),
    360usize,
    concat!("Size of: ", stringify!(_SHFILEINFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEINFOA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).hIcon as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).iIcon as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(iIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).dwAttributes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(dwAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).szDisplayName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(szDisplayName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).szTypeName as *const _ as usize },
    276usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(szTypeName)
    )
  );
}
pub type SHFILEINFOA = _SHFILEINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHFILEINFOW {
  pub hIcon: HICON,
  pub iIcon: ::std::os::raw::c_int,
  pub dwAttributes: DWORD,
  pub szDisplayName: [WCHAR; 260usize],
  pub szTypeName: [WCHAR; 80usize],
}
#[test]
fn bindgen_test_layout__SHFILEINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEINFOW>(),
    696usize,
    concat!("Size of: ", stringify!(_SHFILEINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).hIcon as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).iIcon as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(iIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).dwAttributes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(dwAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).szDisplayName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(szDisplayName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).szTypeName as *const _ as usize },
    536usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(szTypeName)
    )
  );
}
pub type SHFILEINFOW = _SHFILEINFOW;
pub type SHFILEINFO = SHFILEINFOW;
extern "C" {
  pub fn SHGetFileInfoA(
    pszPath: LPCSTR,
    dwFileAttributes: DWORD,
    psfi: *mut SHFILEINFOA,
    cbFileInfo: UINT,
    uFlags: UINT,
  ) -> DWORD_PTR;
}
extern "C" {
  pub fn SHGetFileInfoW(
    pszPath: LPCWSTR,
    dwFileAttributes: DWORD,
    psfi: *mut SHFILEINFOW,
    cbFileInfo: UINT,
    uFlags: UINT,
  ) -> DWORD_PTR;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHSTOCKICONINFO {
  pub cbSize: DWORD,
  pub hIcon: HICON,
  pub iSysImageIndex: ::std::os::raw::c_int,
  pub iIcon: ::std::os::raw::c_int,
  pub szPath: [WCHAR; 260usize],
}
#[test]
fn bindgen_test_layout__SHSTOCKICONINFO() {
  assert_eq!(
    ::std::mem::size_of::<_SHSTOCKICONINFO>(),
    544usize,
    concat!("Size of: ", stringify!(_SHSTOCKICONINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHSTOCKICONINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHSTOCKICONINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).hIcon as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).iSysImageIndex as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(iSysImageIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).iIcon as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(iIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).szPath as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(szPath)
    )
  );
}
pub type SHSTOCKICONINFO = _SHSTOCKICONINFO;
pub const SHSTOCKICONID_SIID_DOCNOASSOC: SHSTOCKICONID = 0;
pub const SHSTOCKICONID_SIID_DOCASSOC: SHSTOCKICONID = 1;
pub const SHSTOCKICONID_SIID_APPLICATION: SHSTOCKICONID = 2;
pub const SHSTOCKICONID_SIID_FOLDER: SHSTOCKICONID = 3;
pub const SHSTOCKICONID_SIID_FOLDEROPEN: SHSTOCKICONID = 4;
pub const SHSTOCKICONID_SIID_DRIVE525: SHSTOCKICONID = 5;
pub const SHSTOCKICONID_SIID_DRIVE35: SHSTOCKICONID = 6;
pub const SHSTOCKICONID_SIID_DRIVEREMOVE: SHSTOCKICONID = 7;
pub const SHSTOCKICONID_SIID_DRIVEFIXED: SHSTOCKICONID = 8;
pub const SHSTOCKICONID_SIID_DRIVENET: SHSTOCKICONID = 9;
pub const SHSTOCKICONID_SIID_DRIVENETDISABLED: SHSTOCKICONID = 10;
pub const SHSTOCKICONID_SIID_DRIVECD: SHSTOCKICONID = 11;
pub const SHSTOCKICONID_SIID_DRIVERAM: SHSTOCKICONID = 12;
pub const SHSTOCKICONID_SIID_WORLD: SHSTOCKICONID = 13;
pub const SHSTOCKICONID_SIID_SERVER: SHSTOCKICONID = 15;
pub const SHSTOCKICONID_SIID_PRINTER: SHSTOCKICONID = 16;
pub const SHSTOCKICONID_SIID_MYNETWORK: SHSTOCKICONID = 17;
pub const SHSTOCKICONID_SIID_FIND: SHSTOCKICONID = 22;
pub const SHSTOCKICONID_SIID_HELP: SHSTOCKICONID = 23;
pub const SHSTOCKICONID_SIID_SHARE: SHSTOCKICONID = 28;
pub const SHSTOCKICONID_SIID_LINK: SHSTOCKICONID = 29;
pub const SHSTOCKICONID_SIID_SLOWFILE: SHSTOCKICONID = 30;
pub const SHSTOCKICONID_SIID_RECYCLER: SHSTOCKICONID = 31;
pub const SHSTOCKICONID_SIID_RECYCLERFULL: SHSTOCKICONID = 32;
pub const SHSTOCKICONID_SIID_MEDIACDAUDIO: SHSTOCKICONID = 40;
pub const SHSTOCKICONID_SIID_LOCK: SHSTOCKICONID = 47;
pub const SHSTOCKICONID_SIID_AUTOLIST: SHSTOCKICONID = 49;
pub const SHSTOCKICONID_SIID_PRINTERNET: SHSTOCKICONID = 50;
pub const SHSTOCKICONID_SIID_SERVERSHARE: SHSTOCKICONID = 51;
pub const SHSTOCKICONID_SIID_PRINTERFAX: SHSTOCKICONID = 52;
pub const SHSTOCKICONID_SIID_PRINTERFAXNET: SHSTOCKICONID = 53;
pub const SHSTOCKICONID_SIID_PRINTERFILE: SHSTOCKICONID = 54;
pub const SHSTOCKICONID_SIID_STACK: SHSTOCKICONID = 55;
pub const SHSTOCKICONID_SIID_MEDIASVCD: SHSTOCKICONID = 56;
pub const SHSTOCKICONID_SIID_STUFFEDFOLDER: SHSTOCKICONID = 57;
pub const SHSTOCKICONID_SIID_DRIVEUNKNOWN: SHSTOCKICONID = 58;
pub const SHSTOCKICONID_SIID_DRIVEDVD: SHSTOCKICONID = 59;
pub const SHSTOCKICONID_SIID_MEDIADVD: SHSTOCKICONID = 60;
pub const SHSTOCKICONID_SIID_MEDIADVDRAM: SHSTOCKICONID = 61;
pub const SHSTOCKICONID_SIID_MEDIADVDRW: SHSTOCKICONID = 62;
pub const SHSTOCKICONID_SIID_MEDIADVDR: SHSTOCKICONID = 63;
pub const SHSTOCKICONID_SIID_MEDIADVDROM: SHSTOCKICONID = 64;
pub const SHSTOCKICONID_SIID_MEDIACDAUDIOPLUS: SHSTOCKICONID = 65;
pub const SHSTOCKICONID_SIID_MEDIACDRW: SHSTOCKICONID = 66;
pub const SHSTOCKICONID_SIID_MEDIACDR: SHSTOCKICONID = 67;
pub const SHSTOCKICONID_SIID_MEDIACDBURN: SHSTOCKICONID = 68;
pub const SHSTOCKICONID_SIID_MEDIABLANKCD: SHSTOCKICONID = 69;
pub const SHSTOCKICONID_SIID_MEDIACDROM: SHSTOCKICONID = 70;
pub const SHSTOCKICONID_SIID_AUDIOFILES: SHSTOCKICONID = 71;
pub const SHSTOCKICONID_SIID_IMAGEFILES: SHSTOCKICONID = 72;
pub const SHSTOCKICONID_SIID_VIDEOFILES: SHSTOCKICONID = 73;
pub const SHSTOCKICONID_SIID_MIXEDFILES: SHSTOCKICONID = 74;
pub const SHSTOCKICONID_SIID_FOLDERBACK: SHSTOCKICONID = 75;
pub const SHSTOCKICONID_SIID_FOLDERFRONT: SHSTOCKICONID = 76;
pub const SHSTOCKICONID_SIID_SHIELD: SHSTOCKICONID = 77;
pub const SHSTOCKICONID_SIID_WARNING: SHSTOCKICONID = 78;
pub const SHSTOCKICONID_SIID_INFO: SHSTOCKICONID = 79;
pub const SHSTOCKICONID_SIID_ERROR: SHSTOCKICONID = 80;
pub const SHSTOCKICONID_SIID_KEY: SHSTOCKICONID = 81;
pub const SHSTOCKICONID_SIID_SOFTWARE: SHSTOCKICONID = 82;
pub const SHSTOCKICONID_SIID_RENAME: SHSTOCKICONID = 83;
pub const SHSTOCKICONID_SIID_DELETE: SHSTOCKICONID = 84;
pub const SHSTOCKICONID_SIID_MEDIAAUDIODVD: SHSTOCKICONID = 85;
pub const SHSTOCKICONID_SIID_MEDIAMOVIEDVD: SHSTOCKICONID = 86;
pub const SHSTOCKICONID_SIID_MEDIAENHANCEDCD: SHSTOCKICONID = 87;
pub const SHSTOCKICONID_SIID_MEDIAENHANCEDDVD: SHSTOCKICONID = 88;
pub const SHSTOCKICONID_SIID_MEDIAHDDVD: SHSTOCKICONID = 89;
pub const SHSTOCKICONID_SIID_MEDIABLURAY: SHSTOCKICONID = 90;
pub const SHSTOCKICONID_SIID_MEDIAVCD: SHSTOCKICONID = 91;
pub const SHSTOCKICONID_SIID_MEDIADVDPLUSR: SHSTOCKICONID = 92;
pub const SHSTOCKICONID_SIID_MEDIADVDPLUSRW: SHSTOCKICONID = 93;
pub const SHSTOCKICONID_SIID_DESKTOPPC: SHSTOCKICONID = 94;
pub const SHSTOCKICONID_SIID_MOBILEPC: SHSTOCKICONID = 95;
pub const SHSTOCKICONID_SIID_USERS: SHSTOCKICONID = 96;
pub const SHSTOCKICONID_SIID_MEDIASMARTMEDIA: SHSTOCKICONID = 97;
pub const SHSTOCKICONID_SIID_MEDIACOMPACTFLASH: SHSTOCKICONID = 98;
pub const SHSTOCKICONID_SIID_DEVICECELLPHONE: SHSTOCKICONID = 99;
pub const SHSTOCKICONID_SIID_DEVICECAMERA: SHSTOCKICONID = 100;
pub const SHSTOCKICONID_SIID_DEVICEVIDEOCAMERA: SHSTOCKICONID = 101;
pub const SHSTOCKICONID_SIID_DEVICEAUDIOPLAYER: SHSTOCKICONID = 102;
pub const SHSTOCKICONID_SIID_NETWORKCONNECT: SHSTOCKICONID = 103;
pub const SHSTOCKICONID_SIID_INTERNET: SHSTOCKICONID = 104;
pub const SHSTOCKICONID_SIID_ZIPFILE: SHSTOCKICONID = 105;
pub const SHSTOCKICONID_SIID_SETTINGS: SHSTOCKICONID = 106;
pub const SHSTOCKICONID_SIID_DRIVEHDDVD: SHSTOCKICONID = 132;
pub const SHSTOCKICONID_SIID_DRIVEBD: SHSTOCKICONID = 133;
pub const SHSTOCKICONID_SIID_MEDIAHDDVDROM: SHSTOCKICONID = 134;
pub const SHSTOCKICONID_SIID_MEDIAHDDVDR: SHSTOCKICONID = 135;
pub const SHSTOCKICONID_SIID_MEDIAHDDVDRAM: SHSTOCKICONID = 136;
pub const SHSTOCKICONID_SIID_MEDIABDROM: SHSTOCKICONID = 137;
pub const SHSTOCKICONID_SIID_MEDIABDR: SHSTOCKICONID = 138;
pub const SHSTOCKICONID_SIID_MEDIABDRE: SHSTOCKICONID = 139;
pub const SHSTOCKICONID_SIID_CLUSTEREDDRIVE: SHSTOCKICONID = 140;
pub const SHSTOCKICONID_SIID_MAX_ICONS: SHSTOCKICONID = 181;
pub type SHSTOCKICONID = ::std::os::raw::c_int;
extern "C" {
  pub fn SHGetStockIconInfo(
    siid: SHSTOCKICONID,
    uFlags: UINT,
    psii: *mut SHSTOCKICONINFO,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetDiskFreeSpaceExA(
    pszDirectoryName: LPCSTR,
    pulFreeBytesAvailableToCaller: *mut ULARGE_INTEGER,
    pulTotalNumberOfBytes: *mut ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: *mut ULARGE_INTEGER,
  ) -> BOOL;
}
extern "C" {
  pub fn SHGetDiskFreeSpaceExW(
    pszDirectoryName: LPCWSTR,
    pulFreeBytesAvailableToCaller: *mut ULARGE_INTEGER,
    pulTotalNumberOfBytes: *mut ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: *mut ULARGE_INTEGER,
  ) -> BOOL;
}
extern "C" {
  pub fn SHGetNewLinkInfoA(
    pszLinkTo: LPCSTR,
    pszDir: LPCSTR,
    pszName: LPSTR,
    pfMustCopy: *mut BOOL,
    uFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn SHGetNewLinkInfoW(
    pszLinkTo: LPCWSTR,
    pszDir: LPCWSTR,
    pszName: LPWSTR,
    pfMustCopy: *mut BOOL,
    uFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn SHInvokePrinterCommandA(
    hwnd: HWND,
    uAction: UINT,
    lpBuf1: LPCSTR,
    lpBuf2: LPCSTR,
    fModal: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SHInvokePrinterCommandW(
    hwnd: HWND,
    uAction: UINT,
    lpBuf1: LPCWSTR,
    lpBuf2: LPCWSTR,
    fModal: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SHLoadNonloadedIconOverlayIdentifiers() -> HRESULT;
}
extern "C" {
  pub fn SHIsFileAvailableOffline(pwszPath: PCWSTR, pdwStatus: *mut DWORD) -> HRESULT;
}
extern "C" {
  pub fn SHSetLocalizedName(
    pszPath: PCWSTR,
    pszResModule: PCWSTR,
    idsRes: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHRemoveLocalizedName(pszPath: PCWSTR) -> HRESULT;
}
extern "C" {
  pub fn SHGetLocalizedName(
    pszPath: PCWSTR,
    pszResModule: PWSTR,
    cch: UINT,
    pidsRes: *mut ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHEnumerateUnreadMailAccountsA(
    hKeyUser: HKEY,
    dwIndex: DWORD,
    pszMailAddress: LPSTR,
    cchMailAddress: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHEnumerateUnreadMailAccountsW(
    hKeyUser: HKEY,
    dwIndex: DWORD,
    pszMailAddress: LPWSTR,
    cchMailAddress: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetUnreadMailCountA(
    hKeyUser: HKEY,
    pszMailAddress: LPCSTR,
    pdwCount: *mut DWORD,
    pFileTime: *mut FILETIME,
    pszShellExecuteCommand: LPSTR,
    cchShellExecuteCommand: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetUnreadMailCountW(
    hKeyUser: HKEY,
    pszMailAddress: LPCWSTR,
    pdwCount: *mut DWORD,
    pFileTime: *mut FILETIME,
    pszShellExecuteCommand: LPWSTR,
    cchShellExecuteCommand: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHSetUnreadMailCountA(
    pszMailAddress: LPCSTR,
    dwCount: DWORD,
    pszShellExecuteCommand: LPCSTR,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHSetUnreadMailCountW(
    pszMailAddress: LPCWSTR,
    dwCount: DWORD,
    pszShellExecuteCommand: LPCWSTR,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHTestTokenMembership(hToken: HANDLE, ulRID: ULONG) -> BOOL;
}
extern "C" {
  pub fn SHGetImageList(
    iImageList: ::std::os::raw::c_int,
    riid: *const IID,
    ppvObj: *mut *mut ::std::os::raw::c_void,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetDriveMedia(pszDrive: PCWSTR, pdwMediaContent: *mut DWORD) -> HRESULT;
}
pub type u_short = ::std::os::raw::c_ushort;
pub type SOCKET = UINT_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
  pub s_name: *mut ::std::os::raw::c_char,
  pub s_aliases: *mut *mut ::std::os::raw::c_char,
  pub s_proto: *mut ::std::os::raw::c_char,
  pub s_port: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_servent() {
  assert_eq!(
    ::std::mem::size_of::<servent>(),
    32usize,
    concat!("Size of: ", stringify!(servent))
  );
  assert_eq!(
    ::std::mem::align_of::<servent>(),
    8usize,
    concat!("Alignment of ", stringify!(servent))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_aliases as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_aliases)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_proto as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_proto)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_port as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_port)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
  pub S_un: in_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in_addr__bindgen_ty_1 {
  pub S_un_b: in_addr__bindgen_ty_1__bindgen_ty_1,
  pub S_un_w: in_addr__bindgen_ty_1__bindgen_ty_2,
  pub S_addr: ULONG,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_1 {
  pub s_b1: UCHAR,
  pub s_b2: UCHAR,
  pub s_b3: UCHAR,
  pub s_b4: UCHAR,
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<in_addr__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr__bindgen_ty_1__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b2 as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b3 as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b4 as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b4)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_2 {
  pub s_w1: USHORT,
  pub s_w2: USHORT,
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<in_addr__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr__bindgen_ty_1__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr__bindgen_ty_1__bindgen_ty_2>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_2>())).s_w1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(s_w1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_2>())).s_w2 as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(s_w2)
    )
  );
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<in_addr__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(in_addr__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_un_b as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1),
      "::",
      stringify!(S_un_b)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_un_w as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1),
      "::",
      stringify!(S_un_w)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_addr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1),
      "::",
      stringify!(S_addr)
    )
  );
}
#[test]
fn bindgen_test_layout_in_addr() {
  assert_eq!(
    ::std::mem::size_of::<in_addr>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr>(),
    4usize,
    concat!("Alignment of ", stringify!(in_addr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr>())).S_un as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr),
      "::",
      stringify!(S_un)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
  pub sin_family: ::std::os::raw::c_short,
  pub sin_port: u_short,
  pub sin_addr: in_addr,
  pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
  assert_eq!(
    ::std::mem::size_of::<sockaddr_in>(),
    16usize,
    concat!("Size of: ", stringify!(sockaddr_in))
  );
  assert_eq!(
    ::std::mem::align_of::<sockaddr_in>(),
    4usize,
    concat!("Alignment of ", stringify!(sockaddr_in))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_family)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_port)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_addr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_zero)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
  pub sa_family: u_short,
  pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
  assert_eq!(
    ::std::mem::size_of::<sockaddr>(),
    16usize,
    concat!("Size of: ", stringify!(sockaddr))
  );
  assert_eq!(
    ::std::mem::align_of::<sockaddr>(),
    2usize,
    concat!("Alignment of ", stringify!(sockaddr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr),
      "::",
      stringify!(sa_family)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr),
      "::",
      stringify!(sa_data)
    )
  );
}
pub type SOCKADDR = sockaddr;
pub type SOCKADDR_IN = sockaddr_in;
pub type SERVENT = servent;
pub type ALG_ID = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCHANNEL_ALG {
  pub dwUse: DWORD,
  pub Algid: ALG_ID,
  pub cBits: DWORD,
  pub dwFlags: DWORD,
  pub dwReserved: DWORD,
}
#[test]
fn bindgen_test_layout__SCHANNEL_ALG() {
  assert_eq!(
    ::std::mem::size_of::<_SCHANNEL_ALG>(),
    20usize,
    concat!("Size of: ", stringify!(_SCHANNEL_ALG))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCHANNEL_ALG>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCHANNEL_ALG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).dwUse as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(dwUse)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).Algid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(Algid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).cBits as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(cBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).dwFlags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).dwReserved as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(dwReserved)
    )
  );
}
pub type SCHANNEL_ALG = _SCHANNEL_ALG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_ECCKEY_BLOB {
  pub dwCurveType: ULONG,
  pub cbKey: ULONG,
}
#[test]
fn bindgen_test_layout__SSL_ECCKEY_BLOB() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_ECCKEY_BLOB>(),
    8usize,
    concat!("Size of: ", stringify!(_SSL_ECCKEY_BLOB))
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_ECCKEY_BLOB>(),
    4usize,
    concat!("Alignment of ", stringify!(_SSL_ECCKEY_BLOB))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SSL_ECCKEY_BLOB>())).dwCurveType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_ECCKEY_BLOB),
      "::",
      stringify!(dwCurveType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SSL_ECCKEY_BLOB>())).cbKey as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_ECCKEY_BLOB),
      "::",
      stringify!(cbKey)
    )
  );
}
pub type SSL_ECCKEY_BLOB = _SSL_ECCKEY_BLOB;
pub type SECURITY_STATUS = LONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HTTPSPolicyCallbackData {
  pub __bindgen_anon_1: _HTTPSPolicyCallbackData__bindgen_ty_1,
  pub dwAuthType: DWORD,
  pub fdwChecks: DWORD,
  pub pwszServerName: *mut WCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HTTPSPolicyCallbackData__bindgen_ty_1 {
  pub cbStruct: DWORD,
  pub cbSize: DWORD,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__HTTPSPolicyCallbackData__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_HTTPSPolicyCallbackData__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_HTTPSPolicyCallbackData__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_HTTPSPolicyCallbackData__bindgen_ty_1>())).cbStruct as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1),
      "::",
      stringify!(cbStruct)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_HTTPSPolicyCallbackData__bindgen_ty_1>())).cbSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1),
      "::",
      stringify!(cbSize)
    )
  );
}
#[test]
fn bindgen_test_layout__HTTPSPolicyCallbackData() {
  assert_eq!(
    ::std::mem::size_of::<_HTTPSPolicyCallbackData>(),
    24usize,
    concat!("Size of: ", stringify!(_HTTPSPolicyCallbackData))
  );
  assert_eq!(
    ::std::mem::align_of::<_HTTPSPolicyCallbackData>(),
    8usize,
    concat!("Alignment of ", stringify!(_HTTPSPolicyCallbackData))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HTTPSPolicyCallbackData>())).dwAuthType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData),
      "::",
      stringify!(dwAuthType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HTTPSPolicyCallbackData>())).fdwChecks as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData),
      "::",
      stringify!(fdwChecks)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_HTTPSPolicyCallbackData>())).pwszServerName as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData),
      "::",
      stringify!(pwszServerName)
    )
  );
}
pub type SSL_EXTRA_CERT_CHAIN_POLICY_PARA = _HTTPSPolicyCallbackData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS {
  pub cbSize: DWORD,
  pub dwErrorLevel: DWORD,
  pub dwErrorCategory: DWORD,
  pub dwReserved: DWORD,
  pub wszErrorText: [WCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    528usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).dwErrorLevel as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(dwErrorLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).dwErrorCategory
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(dwErrorCategory)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).dwReserved as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).wszErrorText as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(wszErrorText)
    )
  );
}
pub type SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA {
  pub cbSize: DWORD,
  pub dwReserved: DWORD,
  pub pwszServerName: LPWSTR,
  pub rgpszHpkpValue: [LPSTR; 2usize],
}
#[test]
fn bindgen_test_layout__SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).dwReserved
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).pwszServerName
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(pwszServerName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).rgpszHpkpValue
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(rgpszHpkpValue)
    )
  );
}
pub type SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA =
  _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA {
  pub cbSize: DWORD,
  pub dwReserved: DWORD,
  pub pwszServerName: PCWSTR,
}
#[test]
fn bindgen_test_layout__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>())).dwReserved as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>())).pwszServerName
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(pwszServerName)
    )
  );
}
pub type SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS {
  pub cbSize: DWORD,
  pub lError: LONG,
  pub wszErrorText: [WCHAR; 512usize],
}
#[test]
fn bindgen_test_layout__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    1032usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>())).lError as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(lError)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>())).wszErrorText
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(wszErrorText)
    )
  );
}
pub type SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub type byte = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
  pub pad: [*mut ::std::os::raw::c_void; 2usize],
  pub userContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(_bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).pad as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_bindgen_ty_1),
      "::",
      stringify!(pad)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).userContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_bindgen_ty_1),
      "::",
      stringify!(userContext)
    )
  );
}
pub type NDR_SCONTEXT = *mut _bindgen_ty_1;
pub type NDR_RUNDOWN =
  ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
pub type NDR_NOTIFY_ROUTINE = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCONTEXT_QUEUE {
  pub NumberOfObjects: ::std::os::raw::c_ulong,
  pub ArrayOfObjects: *mut NDR_SCONTEXT,
}
#[test]
fn bindgen_test_layout__SCONTEXT_QUEUE() {
  assert_eq!(
    ::std::mem::size_of::<_SCONTEXT_QUEUE>(),
    16usize,
    concat!("Size of: ", stringify!(_SCONTEXT_QUEUE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCONTEXT_QUEUE>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCONTEXT_QUEUE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCONTEXT_QUEUE>())).NumberOfObjects as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCONTEXT_QUEUE),
      "::",
      stringify!(NumberOfObjects)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCONTEXT_QUEUE>())).ArrayOfObjects as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCONTEXT_QUEUE),
      "::",
      stringify!(ArrayOfObjects)
    )
  );
}
pub type SCONTEXT_QUEUE = _SCONTEXT_QUEUE;
pub type error_status_t = ::std::os::raw::c_ulong;
pub type EXPR_EVAL = ::std::option::Option<unsafe extern "C" fn(arg1: *mut _MIDL_STUB_MESSAGE)>;
pub type PFORMAT_STRING = *const ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARRAY_INFO {
  pub Dimension: ::std::os::raw::c_long,
  pub BufferConformanceMark: *mut ::std::os::raw::c_ulong,
  pub BufferVarianceMark: *mut ::std::os::raw::c_ulong,
  pub MaxCountArray: *mut ::std::os::raw::c_ulong,
  pub OffsetArray: *mut ::std::os::raw::c_ulong,
  pub ActualCountArray: *mut ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ARRAY_INFO() {
  assert_eq!(
    ::std::mem::size_of::<ARRAY_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(ARRAY_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<ARRAY_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(ARRAY_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).Dimension as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(Dimension)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).BufferConformanceMark as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(BufferConformanceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).BufferVarianceMark as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(BufferVarianceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).MaxCountArray as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(MaxCountArray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).OffsetArray as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(OffsetArray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).ActualCountArray as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(ActualCountArray)
    )
  );
}
pub type PARRAY_INFO = *mut ARRAY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_ASYNC_MESSAGE {
  _unused: [u8; 0],
}
pub type PNDR_ASYNC_MESSAGE = *mut _NDR_ASYNC_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CORRELATION_INFO {
  _unused: [u8; 0],
}
pub type PNDR_CORRELATION_INFO = *mut _NDR_CORRELATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDR_ALLOC_ALL_NODES_CONTEXT {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDR_POINTER_QUEUE_STATE {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_PROC_CONTEXT {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_STUB_MESSAGE {
  pub RpcMsg: PRPC_MESSAGE,
  pub Buffer: *mut ::std::os::raw::c_uchar,
  pub BufferStart: *mut ::std::os::raw::c_uchar,
  pub BufferEnd: *mut ::std::os::raw::c_uchar,
  pub BufferMark: *mut ::std::os::raw::c_uchar,
  pub BufferLength: ::std::os::raw::c_ulong,
  pub MemorySize: ::std::os::raw::c_ulong,
  pub Memory: *mut ::std::os::raw::c_uchar,
  pub IsClient: ::std::os::raw::c_uchar,
  pub Pad: ::std::os::raw::c_uchar,
  pub uFlags2: ::std::os::raw::c_ushort,
  pub ReuseBuffer: ::std::os::raw::c_int,
  pub pAllocAllNodesContext: *mut NDR_ALLOC_ALL_NODES_CONTEXT,
  pub pPointerQueueState: *mut NDR_POINTER_QUEUE_STATE,
  pub IgnoreEmbeddedPointers: ::std::os::raw::c_int,
  pub PointerBufferMark: *mut ::std::os::raw::c_uchar,
  pub CorrDespIncrement: ::std::os::raw::c_uchar,
  pub uFlags: ::std::os::raw::c_uchar,
  pub UniquePtrCount: ::std::os::raw::c_ushort,
  pub MaxCount: ULONG_PTR,
  pub Offset: ::std::os::raw::c_ulong,
  pub ActualCount: ::std::os::raw::c_ulong,
  pub pfnAllocate:
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>,
  pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
  pub StackTop: *mut ::std::os::raw::c_uchar,
  pub pPresentedType: *mut ::std::os::raw::c_uchar,
  pub pTransmitType: *mut ::std::os::raw::c_uchar,
  pub SavedHandle: handle_t,
  pub StubDesc: *const _MIDL_STUB_DESC,
  pub FullPtrXlatTables: *mut _FULL_PTR_XLAT_TABLES,
  pub FullPtrRefId: ::std::os::raw::c_ulong,
  pub PointerLength: ::std::os::raw::c_ulong,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
  pub dwDestContext: ::std::os::raw::c_ulong,
  pub pvDestContext: *mut ::std::os::raw::c_void,
  pub SavedContextHandles: *mut NDR_SCONTEXT,
  pub ParamNumber: ::std::os::raw::c_long,
  pub pRpcChannelBuffer: *mut IRpcChannelBuffer,
  pub pArrayInfo: PARRAY_INFO,
  pub SizePtrCountArray: *mut ::std::os::raw::c_ulong,
  pub SizePtrOffsetArray: *mut ::std::os::raw::c_ulong,
  pub SizePtrLengthArray: *mut ::std::os::raw::c_ulong,
  pub pArgQueue: *mut ::std::os::raw::c_void,
  pub dwStubPhase: ::std::os::raw::c_ulong,
  pub LowStackMark: *mut ::std::os::raw::c_void,
  pub pAsyncMsg: PNDR_ASYNC_MESSAGE,
  pub pCorrInfo: PNDR_CORRELATION_INFO,
  pub pCorrMemory: *mut ::std::os::raw::c_uchar,
  pub pMemoryList: *mut ::std::os::raw::c_void,
  pub pCSInfo: INT_PTR,
  pub ConformanceMark: *mut ::std::os::raw::c_uchar,
  pub VarianceMark: *mut ::std::os::raw::c_uchar,
  pub Unused: INT_PTR,
  pub pContext: *mut _NDR_PROC_CONTEXT,
  pub ContextHandleHash: *mut ::std::os::raw::c_void,
  pub pUserMarshalList: *mut ::std::os::raw::c_void,
  pub Reserved51_3: INT_PTR,
  pub Reserved51_4: INT_PTR,
  pub Reserved51_5: INT_PTR,
}
#[test]
fn bindgen_test_layout__MIDL_STUB_MESSAGE() {
  assert_eq!(
    ::std::mem::size_of::<_MIDL_STUB_MESSAGE>(),
    400usize,
    concat!("Size of: ", stringify!(_MIDL_STUB_MESSAGE))
  );
  assert_eq!(
    ::std::mem::align_of::<_MIDL_STUB_MESSAGE>(),
    8usize,
    concat!("Alignment of ", stringify!(_MIDL_STUB_MESSAGE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).RpcMsg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(RpcMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Buffer as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferStart as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferStart)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferEnd as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferEnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferMark as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferLength as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).MemorySize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(MemorySize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Memory as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Memory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).IsClient as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(IsClient)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Pad as *const _ as usize },
    57usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Pad)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).uFlags2 as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(uFlags2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ReuseBuffer as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ReuseBuffer)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pAllocAllNodesContext as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pAllocAllNodesContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pPointerQueueState as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pPointerQueueState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).IgnoreEmbeddedPointers as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(IgnoreEmbeddedPointers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).PointerBufferMark as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(PointerBufferMark)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).CorrDespIncrement as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(CorrDespIncrement)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).uFlags as *const _ as usize },
    97usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(uFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).UniquePtrCount as *const _ as usize },
    98usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(UniquePtrCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).MaxCount as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(MaxCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Offset as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ActualCount as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ActualCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pfnAllocate as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pfnAllocate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pfnFree as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pfnFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).StackTop as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(StackTop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pPresentedType as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pPresentedType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pTransmitType as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pTransmitType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SavedHandle as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SavedHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).StubDesc as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(StubDesc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).FullPtrXlatTables as *const _ as usize
    },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(FullPtrXlatTables)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).FullPtrRefId as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(FullPtrRefId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).PointerLength as *const _ as usize },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(PointerLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).dwDestContext as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(dwDestContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pvDestContext as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pvDestContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SavedContextHandles as *const _ as usize
    },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SavedContextHandles)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ParamNumber as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ParamNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pRpcChannelBuffer as *const _ as usize
    },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pRpcChannelBuffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pArrayInfo as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pArrayInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SizePtrCountArray as *const _ as usize
    },
    240usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SizePtrCountArray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SizePtrOffsetArray as *const _ as usize
    },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SizePtrOffsetArray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SizePtrLengthArray as *const _ as usize
    },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SizePtrLengthArray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pArgQueue as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pArgQueue)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).dwStubPhase as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(dwStubPhase)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).LowStackMark as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(LowStackMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pAsyncMsg as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pAsyncMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pCorrInfo as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pCorrInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pCorrMemory as *const _ as usize },
    304usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pCorrMemory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pMemoryList as *const _ as usize },
    312usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pMemoryList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pCSInfo as *const _ as usize },
    320usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pCSInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ConformanceMark as *const _ as usize },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ConformanceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).VarianceMark as *const _ as usize },
    336usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(VarianceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Unused as *const _ as usize },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Unused)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pContext as *const _ as usize },
    352usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ContextHandleHash as *const _ as usize
    },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ContextHandleHash)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pUserMarshalList as *const _ as usize },
    368usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pUserMarshalList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Reserved51_3 as *const _ as usize },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Reserved51_3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Reserved51_4 as *const _ as usize },
    384usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Reserved51_4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Reserved51_5 as *const _ as usize },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Reserved51_5)
    )
  );
}
impl _MIDL_STUB_MESSAGE {
  #[inline]
  pub fn fInDontFree(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fInDontFree(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fDontCallFreeInst(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fDontCallFreeInst(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fUnused1(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fUnused1(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasReturn(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasReturn(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasExtensions(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasExtensions(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasNewCorrDesc(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasNewCorrDesc(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(5usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fIsIn(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fIsIn(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(6usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fIsOut(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fIsOut(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(7usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fIsOicf(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fIsOicf(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(8usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fBufferValid(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fBufferValid(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(9usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasMemoryValidateCallback(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasMemoryValidateCallback(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(10usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fInFree(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fInFree(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(11usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fNeedMCCP(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fNeedMCCP(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(12usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fUnused2(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
  }
  #[inline]
  pub fn set_fUnused2(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(13usize, 3u8, val as u64)
    }
  }
  #[inline]
  pub fn fUnused3(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_fUnused3(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(16usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    fInDontFree: ::std::os::raw::c_int,
    fDontCallFreeInst: ::std::os::raw::c_int,
    fUnused1: ::std::os::raw::c_int,
    fHasReturn: ::std::os::raw::c_int,
    fHasExtensions: ::std::os::raw::c_int,
    fHasNewCorrDesc: ::std::os::raw::c_int,
    fIsIn: ::std::os::raw::c_int,
    fIsOut: ::std::os::raw::c_int,
    fIsOicf: ::std::os::raw::c_int,
    fBufferValid: ::std::os::raw::c_int,
    fHasMemoryValidateCallback: ::std::os::raw::c_int,
    fInFree: ::std::os::raw::c_int,
    fNeedMCCP: ::std::os::raw::c_int,
    fUnused2: ::std::os::raw::c_int,
    fUnused3: ::std::os::raw::c_int,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let fInDontFree: u32 = unsafe { ::std::mem::transmute(fInDontFree) };
      fInDontFree as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let fDontCallFreeInst: u32 = unsafe { ::std::mem::transmute(fDontCallFreeInst) };
      fDontCallFreeInst as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let fUnused1: u32 = unsafe { ::std::mem::transmute(fUnused1) };
      fUnused1 as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let fHasReturn: u32 = unsafe { ::std::mem::transmute(fHasReturn) };
      fHasReturn as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let fHasExtensions: u32 = unsafe { ::std::mem::transmute(fHasExtensions) };
      fHasExtensions as u64
    });
    __bindgen_bitfield_unit.set(5usize, 1u8, {
      let fHasNewCorrDesc: u32 = unsafe { ::std::mem::transmute(fHasNewCorrDesc) };
      fHasNewCorrDesc as u64
    });
    __bindgen_bitfield_unit.set(6usize, 1u8, {
      let fIsIn: u32 = unsafe { ::std::mem::transmute(fIsIn) };
      fIsIn as u64
    });
    __bindgen_bitfield_unit.set(7usize, 1u8, {
      let fIsOut: u32 = unsafe { ::std::mem::transmute(fIsOut) };
      fIsOut as u64
    });
    __bindgen_bitfield_unit.set(8usize, 1u8, {
      let fIsOicf: u32 = unsafe { ::std::mem::transmute(fIsOicf) };
      fIsOicf as u64
    });
    __bindgen_bitfield_unit.set(9usize, 1u8, {
      let fBufferValid: u32 = unsafe { ::std::mem::transmute(fBufferValid) };
      fBufferValid as u64
    });
    __bindgen_bitfield_unit.set(10usize, 1u8, {
      let fHasMemoryValidateCallback: u32 =
        unsafe { ::std::mem::transmute(fHasMemoryValidateCallback) };
      fHasMemoryValidateCallback as u64
    });
    __bindgen_bitfield_unit.set(11usize, 1u8, {
      let fInFree: u32 = unsafe { ::std::mem::transmute(fInFree) };
      fInFree as u64
    });
    __bindgen_bitfield_unit.set(12usize, 1u8, {
      let fNeedMCCP: u32 = unsafe { ::std::mem::transmute(fNeedMCCP) };
      fNeedMCCP as u64
    });
    __bindgen_bitfield_unit.set(13usize, 3u8, {
      let fUnused2: u32 = unsafe { ::std::mem::transmute(fUnused2) };
      fUnused2 as u64
    });
    __bindgen_bitfield_unit.set(16usize, 16u8, {
      let fUnused3: u32 = unsafe { ::std::mem::transmute(fUnused3) };
      fUnused3 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type PMIDL_STUB_MESSAGE = *mut _MIDL_STUB_MESSAGE;
pub type GENERIC_BINDING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type GENERIC_UNBIND_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_uchar),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_BINDING_ROUTINE_PAIR {
  pub pfnBind: GENERIC_BINDING_ROUTINE,
  pub pfnUnbind: GENERIC_UNBIND_ROUTINE,
}
#[test]
fn bindgen_test_layout__GENERIC_BINDING_ROUTINE_PAIR() {
  assert_eq!(
    ::std::mem::size_of::<_GENERIC_BINDING_ROUTINE_PAIR>(),
    16usize,
    concat!("Size of: ", stringify!(_GENERIC_BINDING_ROUTINE_PAIR))
  );
  assert_eq!(
    ::std::mem::align_of::<_GENERIC_BINDING_ROUTINE_PAIR>(),
    8usize,
    concat!("Alignment of ", stringify!(_GENERIC_BINDING_ROUTINE_PAIR))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GENERIC_BINDING_ROUTINE_PAIR>())).pfnBind as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_BINDING_ROUTINE_PAIR),
      "::",
      stringify!(pfnBind)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GENERIC_BINDING_ROUTINE_PAIR>())).pfnUnbind as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_BINDING_ROUTINE_PAIR),
      "::",
      stringify!(pfnUnbind)
    )
  );
}
pub type GENERIC_BINDING_ROUTINE_PAIR = _GENERIC_BINDING_ROUTINE_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __GENERIC_BINDING_INFO {
  pub pObj: *mut ::std::os::raw::c_void,
  pub Size: ::std::os::raw::c_uint,
  pub pfnBind: GENERIC_BINDING_ROUTINE,
  pub pfnUnbind: GENERIC_UNBIND_ROUTINE,
}
#[test]
fn bindgen_test_layout___GENERIC_BINDING_INFO() {
  assert_eq!(
    ::std::mem::size_of::<__GENERIC_BINDING_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(__GENERIC_BINDING_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<__GENERIC_BINDING_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(__GENERIC_BINDING_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).pObj as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(pObj)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).Size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).pfnBind as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(pfnBind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).pfnUnbind as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(pfnUnbind)
    )
  );
}
pub type PGENERIC_BINDING_INFO = *mut __GENERIC_BINDING_INFO;
pub type XMIT_HELPER_ROUTINE =
  ::std::option::Option<unsafe extern "C" fn(arg1: PMIDL_STUB_MESSAGE)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XMIT_ROUTINE_QUINTUPLE {
  pub pfnTranslateToXmit: XMIT_HELPER_ROUTINE,
  pub pfnTranslateFromXmit: XMIT_HELPER_ROUTINE,
  pub pfnFreeXmit: XMIT_HELPER_ROUTINE,
  pub pfnFreeInst: XMIT_HELPER_ROUTINE,
}
#[test]
fn bindgen_test_layout__XMIT_ROUTINE_QUINTUPLE() {
  assert_eq!(
    ::std::mem::size_of::<_XMIT_ROUTINE_QUINTUPLE>(),
    32usize,
    concat!("Size of: ", stringify!(_XMIT_ROUTINE_QUINTUPLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_XMIT_ROUTINE_QUINTUPLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_XMIT_ROUTINE_QUINTUPLE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnTranslateToXmit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnTranslateToXmit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnTranslateFromXmit as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnTranslateFromXmit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnFreeXmit as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnFreeXmit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnFreeInst as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnFreeInst)
    )
  );
}
pub type XMIT_ROUTINE_QUINTUPLE = _XMIT_ROUTINE_QUINTUPLE;
pub type USER_MARSHAL_SIZING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_ulong,
>;
pub type USER_MARSHAL_MARSHALLING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_uchar,
>;
pub type USER_MARSHAL_UNMARSHALLING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_uchar,
>;
pub type USER_MARSHAL_FREEING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USER_MARSHAL_ROUTINE_QUADRUPLE {
  pub pfnBufferSize: USER_MARSHAL_SIZING_ROUTINE,
  pub pfnMarshall: USER_MARSHAL_MARSHALLING_ROUTINE,
  pub pfnUnmarshall: USER_MARSHAL_UNMARSHALLING_ROUTINE,
  pub pfnFree: USER_MARSHAL_FREEING_ROUTINE,
}
#[test]
fn bindgen_test_layout__USER_MARSHAL_ROUTINE_QUADRUPLE() {
  assert_eq!(
    ::std::mem::size_of::<_USER_MARSHAL_ROUTINE_QUADRUPLE>(),
    32usize,
    concat!("Size of: ", stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_USER_MARSHAL_ROUTINE_QUADRUPLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnBufferSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnBufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnMarshall as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnMarshall)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnUnmarshall as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnUnmarshall)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnFree as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnFree)
    )
  );
}
pub type USER_MARSHAL_ROUTINE_QUADRUPLE = _USER_MARSHAL_ROUTINE_QUADRUPLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MALLOC_FREE_STRUCT {
  pub pfnAllocate:
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>,
  pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout__MALLOC_FREE_STRUCT() {
  assert_eq!(
    ::std::mem::size_of::<_MALLOC_FREE_STRUCT>(),
    16usize,
    concat!("Size of: ", stringify!(_MALLOC_FREE_STRUCT))
  );
  assert_eq!(
    ::std::mem::align_of::<_MALLOC_FREE_STRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(_MALLOC_FREE_STRUCT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MALLOC_FREE_STRUCT>())).pfnAllocate as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MALLOC_FREE_STRUCT),
      "::",
      stringify!(pfnAllocate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MALLOC_FREE_STRUCT>())).pfnFree as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MALLOC_FREE_STRUCT),
      "::",
      stringify!(pfnFree)
    )
  );
}
pub type MALLOC_FREE_STRUCT = _MALLOC_FREE_STRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMM_FAULT_OFFSETS {
  pub CommOffset: ::std::os::raw::c_short,
  pub FaultOffset: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout__COMM_FAULT_OFFSETS() {
  assert_eq!(
    ::std::mem::size_of::<_COMM_FAULT_OFFSETS>(),
    4usize,
    concat!("Size of: ", stringify!(_COMM_FAULT_OFFSETS))
  );
  assert_eq!(
    ::std::mem::align_of::<_COMM_FAULT_OFFSETS>(),
    2usize,
    concat!("Alignment of ", stringify!(_COMM_FAULT_OFFSETS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_COMM_FAULT_OFFSETS>())).CommOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMM_FAULT_OFFSETS),
      "::",
      stringify!(CommOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_COMM_FAULT_OFFSETS>())).FaultOffset as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMM_FAULT_OFFSETS),
      "::",
      stringify!(FaultOffset)
    )
  );
}
pub type COMM_FAULT_OFFSETS = _COMM_FAULT_OFFSETS;
pub const _IDL_CS_CONVERT_IDL_CS_NO_CONVERT: _IDL_CS_CONVERT = 0;
pub const _IDL_CS_CONVERT_IDL_CS_IN_PLACE_CONVERT: _IDL_CS_CONVERT = 1;
pub const _IDL_CS_CONVERT_IDL_CS_NEW_BUFFER_CONVERT: _IDL_CS_CONVERT = 2;
pub type _IDL_CS_CONVERT = ::std::os::raw::c_int;
pub use self::_IDL_CS_CONVERT as IDL_CS_CONVERT;
pub type CS_TYPE_NET_SIZE_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    ulLocalBufferSize: ::std::os::raw::c_ulong,
    conversionType: *mut IDL_CS_CONVERT,
    pulNetworkBufferSize: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TYPE_LOCAL_SIZE_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    ulNetworkBufferSize: ::std::os::raw::c_ulong,
    conversionType: *mut IDL_CS_CONVERT,
    pulLocalBufferSize: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TYPE_TO_NETCS_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    pLocalData: *mut ::std::os::raw::c_void,
    ulLocalDataLength: ::std::os::raw::c_ulong,
    pNetworkData: *mut byte,
    pulNetworkDataLength: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TYPE_FROM_NETCS_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    pNetworkData: *mut byte,
    ulNetworkDataLength: ::std::os::raw::c_ulong,
    ulLocalBufferSize: ::std::os::raw::c_ulong,
    pLocalData: *mut ::std::os::raw::c_void,
    pulLocalDataLength: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TAG_GETTING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    fServerSide: ::std::os::raw::c_int,
    pulSendingTag: *mut ::std::os::raw::c_ulong,
    pulDesiredReceivingTag: *mut ::std::os::raw::c_ulong,
    pulReceivingTag: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CS_SIZE_CONVERT_ROUTINES {
  pub pfnNetSize: CS_TYPE_NET_SIZE_ROUTINE,
  pub pfnToNetCs: CS_TYPE_TO_NETCS_ROUTINE,
  pub pfnLocalSize: CS_TYPE_LOCAL_SIZE_ROUTINE,
  pub pfnFromNetCs: CS_TYPE_FROM_NETCS_ROUTINE,
}
#[test]
fn bindgen_test_layout__NDR_CS_SIZE_CONVERT_ROUTINES() {
  assert_eq!(
    ::std::mem::size_of::<_NDR_CS_SIZE_CONVERT_ROUTINES>(),
    32usize,
    concat!("Size of: ", stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES))
  );
  assert_eq!(
    ::std::mem::align_of::<_NDR_CS_SIZE_CONVERT_ROUTINES>(),
    8usize,
    concat!("Alignment of ", stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnNetSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnNetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnToNetCs as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnToNetCs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnLocalSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnLocalSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnFromNetCs as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnFromNetCs)
    )
  );
}
pub type NDR_CS_SIZE_CONVERT_ROUTINES = _NDR_CS_SIZE_CONVERT_ROUTINES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CS_ROUTINES {
  pub pSizeConvertRoutines: *mut NDR_CS_SIZE_CONVERT_ROUTINES,
  pub pTagGettingRoutines: *mut CS_TAG_GETTING_ROUTINE,
}
#[test]
fn bindgen_test_layout__NDR_CS_ROUTINES() {
  assert_eq!(
    ::std::mem::size_of::<_NDR_CS_ROUTINES>(),
    16usize,
    concat!("Size of: ", stringify!(_NDR_CS_ROUTINES))
  );
  assert_eq!(
    ::std::mem::align_of::<_NDR_CS_ROUTINES>(),
    8usize,
    concat!("Alignment of ", stringify!(_NDR_CS_ROUTINES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_ROUTINES>())).pSizeConvertRoutines as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_ROUTINES),
      "::",
      stringify!(pSizeConvertRoutines)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_ROUTINES>())).pTagGettingRoutines as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_ROUTINES),
      "::",
      stringify!(pTagGettingRoutines)
    )
  );
}
pub type NDR_CS_ROUTINES = _NDR_CS_ROUTINES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_EXPR_DESC {
  pub pOffset: *const ::std::os::raw::c_ushort,
  pub pFormatExpr: PFORMAT_STRING,
}
#[test]
fn bindgen_test_layout__NDR_EXPR_DESC() {
  assert_eq!(
    ::std::mem::size_of::<_NDR_EXPR_DESC>(),
    16usize,
    concat!("Size of: ", stringify!(_NDR_EXPR_DESC))
  );
  assert_eq!(
    ::std::mem::align_of::<_NDR_EXPR_DESC>(),
    8usize,
    concat!("Alignment of ", stringify!(_NDR_EXPR_DESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NDR_EXPR_DESC>())).pOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_EXPR_DESC),
      "::",
      stringify!(pOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NDR_EXPR_DESC>())).pFormatExpr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_EXPR_DESC),
      "::",
      stringify!(pFormatExpr)
    )
  );
}
pub type NDR_EXPR_DESC = _NDR_EXPR_DESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MIDL_STUB_DESC {
  pub RpcInterfaceInformation: *mut ::std::os::raw::c_void,
  pub pfnAllocate:
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>,
  pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
  pub IMPLICIT_HANDLE_INFO: _MIDL_STUB_DESC__bindgen_ty_1,
  pub apfnNdrRundownRoutines: *const NDR_RUNDOWN,
  pub aGenericBindingRoutinePairs: *const GENERIC_BINDING_ROUTINE_PAIR,
  pub apfnExprEval: *const EXPR_EVAL,
  pub aXmitQuintuple: *const XMIT_ROUTINE_QUINTUPLE,
  pub pFormatTypes: *const ::std::os::raw::c_uchar,
  pub fCheckBounds: ::std::os::raw::c_int,
  pub Version: ::std::os::raw::c_ulong,
  pub pMallocFreeStruct: *mut MALLOC_FREE_STRUCT,
  pub MIDLVersion: ::std::os::raw::c_long,
  pub CommFaultOffsets: *const COMM_FAULT_OFFSETS,
  pub aUserMarshalQuadruple: *const USER_MARSHAL_ROUTINE_QUADRUPLE,
  pub NotifyRoutineTable: *const NDR_NOTIFY_ROUTINE,
  pub mFlags: ULONG_PTR,
  pub CsRoutineTables: *const NDR_CS_ROUTINES,
  pub ProxyServerInfo: *mut ::std::os::raw::c_void,
  pub pExprInfo: *const NDR_EXPR_DESC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MIDL_STUB_DESC__bindgen_ty_1 {
  pub pAutoHandle: *mut handle_t,
  pub pPrimitiveHandle: *mut handle_t,
  pub pGenericBindingInfo: PGENERIC_BINDING_INFO,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__MIDL_STUB_DESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_MIDL_STUB_DESC__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_MIDL_STUB_DESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_MIDL_STUB_DESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_MIDL_STUB_DESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC__bindgen_ty_1>())).pAutoHandle as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC__bindgen_ty_1),
      "::",
      stringify!(pAutoHandle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC__bindgen_ty_1>())).pPrimitiveHandle as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC__bindgen_ty_1),
      "::",
      stringify!(pPrimitiveHandle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC__bindgen_ty_1>())).pGenericBindingInfo as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC__bindgen_ty_1),
      "::",
      stringify!(pGenericBindingInfo)
    )
  );
}
#[test]
fn bindgen_test_layout__MIDL_STUB_DESC() {
  assert_eq!(
    ::std::mem::size_of::<_MIDL_STUB_DESC>(),
    152usize,
    concat!("Size of: ", stringify!(_MIDL_STUB_DESC))
  );
  assert_eq!(
    ::std::mem::align_of::<_MIDL_STUB_DESC>(),
    8usize,
    concat!("Alignment of ", stringify!(_MIDL_STUB_DESC))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).RpcInterfaceInformation as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(RpcInterfaceInformation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pfnAllocate as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pfnAllocate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pfnFree as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pfnFree)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).IMPLICIT_HANDLE_INFO as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(IMPLICIT_HANDLE_INFO)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).apfnNdrRundownRoutines as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(apfnNdrRundownRoutines)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).aGenericBindingRoutinePairs as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(aGenericBindingRoutinePairs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).apfnExprEval as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(apfnExprEval)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).aXmitQuintuple as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(aXmitQuintuple)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pFormatTypes as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pFormatTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).fCheckBounds as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(fCheckBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).Version as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pMallocFreeStruct as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pMallocFreeStruct)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).MIDLVersion as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(MIDLVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).CommFaultOffsets as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(CommFaultOffsets)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).aUserMarshalQuadruple as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(aUserMarshalQuadruple)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).NotifyRoutineTable as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(NotifyRoutineTable)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).mFlags as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(mFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).CsRoutineTables as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(CsRoutineTables)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).ProxyServerInfo as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(ProxyServerInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pExprInfo as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pExprInfo)
    )
  );
}
pub type STUB_THUNK = ::std::option::Option<unsafe extern "C" fn(arg1: PMIDL_STUB_MESSAGE)>;
pub type SERVER_ROUTINE = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub const XLAT_SIDE_XLAT_SERVER: XLAT_SIDE = 1;
pub const XLAT_SIDE_XLAT_CLIENT: XLAT_SIDE = 2;
pub type XLAT_SIDE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FULL_PTR_XLAT_TABLES {
  pub RefIdToPointer: *mut ::std::os::raw::c_void,
  pub PointerToRefId: *mut ::std::os::raw::c_void,
  pub NextRefId: ::std::os::raw::c_ulong,
  pub XlatSide: XLAT_SIDE,
}
#[test]
fn bindgen_test_layout__FULL_PTR_XLAT_TABLES() {
  assert_eq!(
    ::std::mem::size_of::<_FULL_PTR_XLAT_TABLES>(),
    24usize,
    concat!("Size of: ", stringify!(_FULL_PTR_XLAT_TABLES))
  );
  assert_eq!(
    ::std::mem::align_of::<_FULL_PTR_XLAT_TABLES>(),
    8usize,
    concat!("Alignment of ", stringify!(_FULL_PTR_XLAT_TABLES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).RefIdToPointer as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(RefIdToPointer)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).PointerToRefId as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(PointerToRefId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).NextRefId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(NextRefId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).XlatSide as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(XlatSide)
    )
  );
}
pub const STUB_PHASE_STUB_UNMARSHAL: STUB_PHASE = 0;
pub const STUB_PHASE_STUB_CALL_SERVER: STUB_PHASE = 1;
pub const STUB_PHASE_STUB_MARSHAL: STUB_PHASE = 2;
pub const STUB_PHASE_STUB_CALL_SERVER_NO_HRESULT: STUB_PHASE = 3;
pub type STUB_PHASE = ::std::os::raw::c_int;
pub type OLECHAR = WCHAR;
pub type LPOLESTR = *mut OLECHAR;
pub type LPCOLESTR = *const OLECHAR;
pub type DOUBLE = f64;
pub type SCODE = LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLAGGED_WORD_BLOB {
  pub fFlags: ULONG,
  pub clSize: ULONG,
  pub asData: [::std::os::raw::c_ushort; 1usize],
}
#[test]
fn bindgen_test_layout__FLAGGED_WORD_BLOB() {
  assert_eq!(
    ::std::mem::size_of::<_FLAGGED_WORD_BLOB>(),
    12usize,
    concat!("Size of: ", stringify!(_FLAGGED_WORD_BLOB))
  );
  assert_eq!(
    ::std::mem::align_of::<_FLAGGED_WORD_BLOB>(),
    4usize,
    concat!("Alignment of ", stringify!(_FLAGGED_WORD_BLOB))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FLAGGED_WORD_BLOB>())).fFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLAGGED_WORD_BLOB),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FLAGGED_WORD_BLOB>())).clSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLAGGED_WORD_BLOB),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FLAGGED_WORD_BLOB>())).asData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLAGGED_WORD_BLOB),
      "::",
      stringify!(asData)
    )
  );
}
pub type FLAGGED_WORD_BLOB = _FLAGGED_WORD_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BYTE_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut byte,
}
#[test]
fn bindgen_test_layout__BYTE_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_BYTE_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_BYTE_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_BYTE_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_BYTE_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_BYTE_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_BYTE_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_BYTE_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_BYTE_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type BYTE_SIZEDARR = _BYTE_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHORT_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__SHORT_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_SHORT_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_SHORT_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHORT_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHORT_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHORT_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHORT_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHORT_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHORT_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type WORD_SIZEDARR = _SHORT_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONG_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut ULONG,
}
#[test]
fn bindgen_test_layout__LONG_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_LONG_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_LONG_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_LONG_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_LONG_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LONG_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LONG_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LONG_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_LONG_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type DWORD_SIZEDARR = _LONG_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HYPER_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__HYPER_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_HYPER_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_HYPER_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_HYPER_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_HYPER_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HYPER_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HYPER_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HYPER_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_HYPER_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type HYPER_SIZEDARR = _HYPER_SIZEDARR;
pub const tagSTGC_STGC_DEFAULT: tagSTGC = 0;
pub const tagSTGC_STGC_OVERWRITE: tagSTGC = 1;
pub const tagSTGC_STGC_ONLYIFCURRENT: tagSTGC = 2;
pub const tagSTGC_STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE: tagSTGC = 4;
pub const tagSTGC_STGC_CONSOLIDATE: tagSTGC = 8;
pub type tagSTGC = ::std::os::raw::c_int;
pub use self::tagSTGC as STGC;
pub const tagSTGMOVE_STGMOVE_MOVE: tagSTGMOVE = 0;
pub const tagSTGMOVE_STGMOVE_COPY: tagSTGMOVE = 1;
pub const tagSTGMOVE_STGMOVE_SHALLOWCOPY: tagSTGMOVE = 2;
pub type tagSTGMOVE = ::std::os::raw::c_int;
pub use self::tagSTGMOVE as STGMOVE;
pub const tagSTATFLAG_STATFLAG_DEFAULT: tagSTATFLAG = 0;
pub const tagSTATFLAG_STATFLAG_NONAME: tagSTATFLAG = 1;
pub const tagSTATFLAG_STATFLAG_NOOPEN: tagSTATFLAG = 2;
pub type tagSTATFLAG = ::std::os::raw::c_int;
pub use self::tagSTATFLAG as STATFLAG;
pub type CLIPFORMAT = WORD;
pub type HMETAFILEPICT = *mut ::std::os::raw::c_void;
pub type DATE = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagCY {
  pub __bindgen_anon_1: tagCY__bindgen_ty_1,
  pub int64: LONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCY__bindgen_ty_1 {
  pub Lo: ULONG,
  pub Hi: LONG,
}
#[test]
fn bindgen_test_layout_tagCY__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagCY__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagCY__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagCY__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCY__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagCY__bindgen_ty_1>())).Lo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCY__bindgen_ty_1),
      "::",
      stringify!(Lo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagCY__bindgen_ty_1>())).Hi as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCY__bindgen_ty_1),
      "::",
      stringify!(Hi)
    )
  );
}
#[test]
fn bindgen_test_layout_tagCY() {
  assert_eq!(
    ::std::mem::size_of::<tagCY>(),
    8usize,
    concat!("Size of: ", stringify!(tagCY))
  );
  assert_eq!(
    ::std::mem::align_of::<tagCY>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagCY>())).int64 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCY),
      "::",
      stringify!(int64)
    )
  );
}
pub type CY = tagCY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagDEC {
  pub wReserved: USHORT,
  pub __bindgen_anon_1: tagDEC__bindgen_ty_1,
  pub Hi32: ULONG,
  pub __bindgen_anon_2: tagDEC__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_1 {
  pub __bindgen_anon_1: tagDEC__bindgen_ty_1__bindgen_ty_1,
  pub signscale: USHORT,
  _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_1__bindgen_ty_1 {
  pub scale: BYTE,
  pub sign: BYTE,
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_1__bindgen_ty_1>())).scale as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(scale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_1__bindgen_ty_1>())).sign as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(sign)
    )
  );
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_1>(),
    2usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(tagDEC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC__bindgen_ty_1>())).signscale as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_1),
      "::",
      stringify!(signscale)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_2 {
  pub __bindgen_anon_1: tagDEC__bindgen_ty_2__bindgen_ty_1,
  pub Lo64: ULONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_2__bindgen_ty_1 {
  pub Lo32: ULONG,
  pub Mid32: ULONG,
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_2__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_2__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_2__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_2__bindgen_ty_1>())).Lo32 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Lo32)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_2__bindgen_ty_1>())).Mid32 as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Mid32)
    )
  );
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_2>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDEC__bindgen_ty_2))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC__bindgen_ty_2>())).Lo64 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_2),
      "::",
      stringify!(Lo64)
    )
  );
}
#[test]
fn bindgen_test_layout_tagDEC() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC>(),
    16usize,
    concat!("Size of: ", stringify!(tagDEC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDEC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC>())).wReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC),
      "::",
      stringify!(wReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC>())).Hi32 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC),
      "::",
      stringify!(Hi32)
    )
  );
}
pub type DECIMAL = tagDEC;
pub type wireBSTR = *mut FLAGGED_WORD_BLOB;
pub type BSTR = *mut OLECHAR;
pub type VARIANT_BOOL = ::std::os::raw::c_short;
pub type VARTYPE = ::std::os::raw::c_ushort;
pub type PROPID = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HOTPLUG_INFO {
  pub Size: DWORD,
  pub MediaRemovable: BOOLEAN,
  pub MediaHotplug: BOOLEAN,
  pub DeviceHotplug: BOOLEAN,
  pub WriteCacheEnableOverride: BOOLEAN,
}
#[test]
fn bindgen_test_layout__STORAGE_HOTPLUG_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HOTPLUG_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_STORAGE_HOTPLUG_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HOTPLUG_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HOTPLUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).MediaRemovable as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(MediaRemovable)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).MediaHotplug as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(MediaHotplug)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).DeviceHotplug as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(DeviceHotplug)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).WriteCacheEnableOverride as *const _
        as usize
    },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(WriteCacheEnableOverride)
    )
  );
}
pub type STORAGE_HOTPLUG_INFO = _STORAGE_HOTPLUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBER {
  pub DeviceType: DWORD,
  pub DeviceNumber: DWORD,
  pub PartitionNumber: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMBER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMBER>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMBER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMBER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMBER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER>())).DeviceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER>())).DeviceNumber as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER),
      "::",
      stringify!(DeviceNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER>())).PartitionNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER),
      "::",
      stringify!(PartitionNumber)
    )
  );
}
pub type STORAGE_DEVICE_NUMBER = _STORAGE_DEVICE_NUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBERS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfDevices: DWORD,
  pub Devices: [STORAGE_DEVICE_NUMBER; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMBERS() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMBERS>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMBERS))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMBERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMBERS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).NumberOfDevices as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(NumberOfDevices)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).Devices as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(Devices)
    )
  );
}
pub type STORAGE_DEVICE_NUMBERS = _STORAGE_DEVICE_NUMBERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBER_EX {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub DeviceType: DWORD,
  pub DeviceNumber: DWORD,
  pub DeviceGuid: GUID,
  pub PartitionNumber: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMBER_EX() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMBER_EX>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMBER_EX))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMBER_EX>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMBER_EX))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).DeviceType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).DeviceNumber as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(DeviceNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).DeviceGuid as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).PartitionNumber as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(PartitionNumber)
    )
  );
}
pub type STORAGE_DEVICE_NUMBER_EX = _STORAGE_DEVICE_NUMBER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_BUS_RESET_REQUEST {
  pub PathId: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_BUS_RESET_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_BUS_RESET_REQUEST>(),
    1usize,
    concat!("Size of: ", stringify!(_STORAGE_BUS_RESET_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_BUS_RESET_REQUEST>(),
    1usize,
    concat!("Alignment of ", stringify!(_STORAGE_BUS_RESET_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_BUS_RESET_REQUEST>())).PathId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_BUS_RESET_REQUEST),
      "::",
      stringify!(PathId)
    )
  );
}
pub type STORAGE_BUS_RESET_REQUEST = _STORAGE_BUS_RESET_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STORAGE_BREAK_RESERVATION_REQUEST {
  pub Length: DWORD,
  pub _unused: BYTE,
  pub PathId: BYTE,
  pub TargetId: BYTE,
  pub Lun: BYTE,
}
#[test]
fn bindgen_test_layout_STORAGE_BREAK_RESERVATION_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<STORAGE_BREAK_RESERVATION_REQUEST>(),
    8usize,
    concat!("Size of: ", stringify!(STORAGE_BREAK_RESERVATION_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<STORAGE_BREAK_RESERVATION_REQUEST>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).Length as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>()))._unused as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(_unused)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).PathId as *const _ as usize
    },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(PathId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).TargetId as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(TargetId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).Lun as *const _ as usize
    },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(Lun)
    )
  );
}
pub const _STORAGE_MEDIA_TYPE_DDS_4mm: _STORAGE_MEDIA_TYPE = 32;
pub const _STORAGE_MEDIA_TYPE_MiniQic: _STORAGE_MEDIA_TYPE = 33;
pub const _STORAGE_MEDIA_TYPE_Travan: _STORAGE_MEDIA_TYPE = 34;
pub const _STORAGE_MEDIA_TYPE_QIC: _STORAGE_MEDIA_TYPE = 35;
pub const _STORAGE_MEDIA_TYPE_MP_8mm: _STORAGE_MEDIA_TYPE = 36;
pub const _STORAGE_MEDIA_TYPE_AME_8mm: _STORAGE_MEDIA_TYPE = 37;
pub const _STORAGE_MEDIA_TYPE_AIT1_8mm: _STORAGE_MEDIA_TYPE = 38;
pub const _STORAGE_MEDIA_TYPE_DLT: _STORAGE_MEDIA_TYPE = 39;
pub const _STORAGE_MEDIA_TYPE_NCTP: _STORAGE_MEDIA_TYPE = 40;
pub const _STORAGE_MEDIA_TYPE_IBM_3480: _STORAGE_MEDIA_TYPE = 41;
pub const _STORAGE_MEDIA_TYPE_IBM_3490E: _STORAGE_MEDIA_TYPE = 42;
pub const _STORAGE_MEDIA_TYPE_IBM_Magstar_3590: _STORAGE_MEDIA_TYPE = 43;
pub const _STORAGE_MEDIA_TYPE_IBM_Magstar_MP: _STORAGE_MEDIA_TYPE = 44;
pub const _STORAGE_MEDIA_TYPE_STK_DATA_D3: _STORAGE_MEDIA_TYPE = 45;
pub const _STORAGE_MEDIA_TYPE_SONY_DTF: _STORAGE_MEDIA_TYPE = 46;
pub const _STORAGE_MEDIA_TYPE_DV_6mm: _STORAGE_MEDIA_TYPE = 47;
pub const _STORAGE_MEDIA_TYPE_DMI: _STORAGE_MEDIA_TYPE = 48;
pub const _STORAGE_MEDIA_TYPE_SONY_D2: _STORAGE_MEDIA_TYPE = 49;
pub const _STORAGE_MEDIA_TYPE_CLEANER_CARTRIDGE: _STORAGE_MEDIA_TYPE = 50;
pub const _STORAGE_MEDIA_TYPE_CD_ROM: _STORAGE_MEDIA_TYPE = 51;
pub const _STORAGE_MEDIA_TYPE_CD_R: _STORAGE_MEDIA_TYPE = 52;
pub const _STORAGE_MEDIA_TYPE_CD_RW: _STORAGE_MEDIA_TYPE = 53;
pub const _STORAGE_MEDIA_TYPE_DVD_ROM: _STORAGE_MEDIA_TYPE = 54;
pub const _STORAGE_MEDIA_TYPE_DVD_R: _STORAGE_MEDIA_TYPE = 55;
pub const _STORAGE_MEDIA_TYPE_DVD_RW: _STORAGE_MEDIA_TYPE = 56;
pub const _STORAGE_MEDIA_TYPE_MO_3_RW: _STORAGE_MEDIA_TYPE = 57;
pub const _STORAGE_MEDIA_TYPE_MO_5_WO: _STORAGE_MEDIA_TYPE = 58;
pub const _STORAGE_MEDIA_TYPE_MO_5_RW: _STORAGE_MEDIA_TYPE = 59;
pub const _STORAGE_MEDIA_TYPE_MO_5_LIMDOW: _STORAGE_MEDIA_TYPE = 60;
pub const _STORAGE_MEDIA_TYPE_PC_5_WO: _STORAGE_MEDIA_TYPE = 61;
pub const _STORAGE_MEDIA_TYPE_PC_5_RW: _STORAGE_MEDIA_TYPE = 62;
pub const _STORAGE_MEDIA_TYPE_PD_5_RW: _STORAGE_MEDIA_TYPE = 63;
pub const _STORAGE_MEDIA_TYPE_ABL_5_WO: _STORAGE_MEDIA_TYPE = 64;
pub const _STORAGE_MEDIA_TYPE_PINNACLE_APEX_5_RW: _STORAGE_MEDIA_TYPE = 65;
pub const _STORAGE_MEDIA_TYPE_SONY_12_WO: _STORAGE_MEDIA_TYPE = 66;
pub const _STORAGE_MEDIA_TYPE_PHILIPS_12_WO: _STORAGE_MEDIA_TYPE = 67;
pub const _STORAGE_MEDIA_TYPE_HITACHI_12_WO: _STORAGE_MEDIA_TYPE = 68;
pub const _STORAGE_MEDIA_TYPE_CYGNET_12_WO: _STORAGE_MEDIA_TYPE = 69;
pub const _STORAGE_MEDIA_TYPE_KODAK_14_WO: _STORAGE_MEDIA_TYPE = 70;
pub const _STORAGE_MEDIA_TYPE_MO_NFR_525: _STORAGE_MEDIA_TYPE = 71;
pub const _STORAGE_MEDIA_TYPE_NIKON_12_RW: _STORAGE_MEDIA_TYPE = 72;
pub const _STORAGE_MEDIA_TYPE_IOMEGA_ZIP: _STORAGE_MEDIA_TYPE = 73;
pub const _STORAGE_MEDIA_TYPE_IOMEGA_JAZ: _STORAGE_MEDIA_TYPE = 74;
pub const _STORAGE_MEDIA_TYPE_SYQUEST_EZ135: _STORAGE_MEDIA_TYPE = 75;
pub const _STORAGE_MEDIA_TYPE_SYQUEST_EZFLYER: _STORAGE_MEDIA_TYPE = 76;
pub const _STORAGE_MEDIA_TYPE_SYQUEST_SYJET: _STORAGE_MEDIA_TYPE = 77;
pub const _STORAGE_MEDIA_TYPE_AVATAR_F2: _STORAGE_MEDIA_TYPE = 78;
pub const _STORAGE_MEDIA_TYPE_MP2_8mm: _STORAGE_MEDIA_TYPE = 79;
pub const _STORAGE_MEDIA_TYPE_DST_S: _STORAGE_MEDIA_TYPE = 80;
pub const _STORAGE_MEDIA_TYPE_DST_M: _STORAGE_MEDIA_TYPE = 81;
pub const _STORAGE_MEDIA_TYPE_DST_L: _STORAGE_MEDIA_TYPE = 82;
pub const _STORAGE_MEDIA_TYPE_VXATape_1: _STORAGE_MEDIA_TYPE = 83;
pub const _STORAGE_MEDIA_TYPE_VXATape_2: _STORAGE_MEDIA_TYPE = 84;
pub const _STORAGE_MEDIA_TYPE_STK_9840: _STORAGE_MEDIA_TYPE = 85;
pub const _STORAGE_MEDIA_TYPE_LTO_Ultrium: _STORAGE_MEDIA_TYPE = 86;
pub const _STORAGE_MEDIA_TYPE_LTO_Accelis: _STORAGE_MEDIA_TYPE = 87;
pub const _STORAGE_MEDIA_TYPE_DVD_RAM: _STORAGE_MEDIA_TYPE = 88;
pub const _STORAGE_MEDIA_TYPE_AIT_8mm: _STORAGE_MEDIA_TYPE = 89;
pub const _STORAGE_MEDIA_TYPE_ADR_1: _STORAGE_MEDIA_TYPE = 90;
pub const _STORAGE_MEDIA_TYPE_ADR_2: _STORAGE_MEDIA_TYPE = 91;
pub const _STORAGE_MEDIA_TYPE_STK_9940: _STORAGE_MEDIA_TYPE = 92;
pub const _STORAGE_MEDIA_TYPE_SAIT: _STORAGE_MEDIA_TYPE = 93;
pub const _STORAGE_MEDIA_TYPE_VXATape: _STORAGE_MEDIA_TYPE = 94;
pub type _STORAGE_MEDIA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_MEDIA_TYPE as STORAGE_MEDIA_TYPE;
pub const _STORAGE_BUS_TYPE_BusTypeUnknown: _STORAGE_BUS_TYPE = 0;
pub const _STORAGE_BUS_TYPE_BusTypeScsi: _STORAGE_BUS_TYPE = 1;
pub const _STORAGE_BUS_TYPE_BusTypeAtapi: _STORAGE_BUS_TYPE = 2;
pub const _STORAGE_BUS_TYPE_BusTypeAta: _STORAGE_BUS_TYPE = 3;
pub const _STORAGE_BUS_TYPE_BusType1394: _STORAGE_BUS_TYPE = 4;
pub const _STORAGE_BUS_TYPE_BusTypeSsa: _STORAGE_BUS_TYPE = 5;
pub const _STORAGE_BUS_TYPE_BusTypeFibre: _STORAGE_BUS_TYPE = 6;
pub const _STORAGE_BUS_TYPE_BusTypeUsb: _STORAGE_BUS_TYPE = 7;
pub const _STORAGE_BUS_TYPE_BusTypeRAID: _STORAGE_BUS_TYPE = 8;
pub const _STORAGE_BUS_TYPE_BusTypeiScsi: _STORAGE_BUS_TYPE = 9;
pub const _STORAGE_BUS_TYPE_BusTypeSas: _STORAGE_BUS_TYPE = 10;
pub const _STORAGE_BUS_TYPE_BusTypeSata: _STORAGE_BUS_TYPE = 11;
pub const _STORAGE_BUS_TYPE_BusTypeSd: _STORAGE_BUS_TYPE = 12;
pub const _STORAGE_BUS_TYPE_BusTypeMmc: _STORAGE_BUS_TYPE = 13;
pub const _STORAGE_BUS_TYPE_BusTypeVirtual: _STORAGE_BUS_TYPE = 14;
pub const _STORAGE_BUS_TYPE_BusTypeFileBackedVirtual: _STORAGE_BUS_TYPE = 15;
pub const _STORAGE_BUS_TYPE_BusTypeSpaces: _STORAGE_BUS_TYPE = 16;
pub const _STORAGE_BUS_TYPE_BusTypeNvme: _STORAGE_BUS_TYPE = 17;
pub const _STORAGE_BUS_TYPE_BusTypeSCM: _STORAGE_BUS_TYPE = 18;
pub const _STORAGE_BUS_TYPE_BusTypeUfs: _STORAGE_BUS_TYPE = 19;
pub const _STORAGE_BUS_TYPE_BusTypeMax: _STORAGE_BUS_TYPE = 20;
pub const _STORAGE_BUS_TYPE_BusTypeMaxReserved: _STORAGE_BUS_TYPE = 127;
pub type _STORAGE_BUS_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_BUS_TYPE as STORAGE_BUS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PREDICT_FAILURE {
  pub PredictFailure: DWORD,
  pub VendorSpecific: [BYTE; 512usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PREDICT_FAILURE() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PREDICT_FAILURE>(),
    516usize,
    concat!("Size of: ", stringify!(_STORAGE_PREDICT_FAILURE))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PREDICT_FAILURE>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PREDICT_FAILURE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PREDICT_FAILURE>())).PredictFailure as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PREDICT_FAILURE),
      "::",
      stringify!(PredictFailure)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PREDICT_FAILURE>())).VendorSpecific as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PREDICT_FAILURE),
      "::",
      stringify!(VendorSpecific)
    )
  );
}
pub type STORAGE_PREDICT_FAILURE = _STORAGE_PREDICT_FAILURE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_FAILURE_PREDICTION_CONFIG {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Set: BOOLEAN,
  pub Enabled: BOOLEAN,
  pub Reserved: WORD,
}
#[test]
fn bindgen_test_layout__STORAGE_FAILURE_PREDICTION_CONFIG() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_FAILURE_PREDICTION_CONFIG>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_FAILURE_PREDICTION_CONFIG>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Set as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Set)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Enabled as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Enabled)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Reserved as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_FAILURE_PREDICTION_CONFIG = _STORAGE_FAILURE_PREDICTION_CONFIG;
pub const _STORAGE_QUERY_TYPE_PropertyStandardQuery: _STORAGE_QUERY_TYPE = 0;
pub const _STORAGE_QUERY_TYPE_PropertyExistsQuery: _STORAGE_QUERY_TYPE = 1;
pub const _STORAGE_QUERY_TYPE_PropertyMaskQuery: _STORAGE_QUERY_TYPE = 2;
pub const _STORAGE_QUERY_TYPE_PropertyQueryMaxDefined: _STORAGE_QUERY_TYPE = 3;
pub type _STORAGE_QUERY_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_QUERY_TYPE as STORAGE_QUERY_TYPE;
pub const _STORAGE_SET_TYPE_PropertyStandardSet: _STORAGE_SET_TYPE = 0;
pub const _STORAGE_SET_TYPE_PropertyExistsSet: _STORAGE_SET_TYPE = 1;
pub const _STORAGE_SET_TYPE_PropertySetMaxDefined: _STORAGE_SET_TYPE = 2;
pub type _STORAGE_SET_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_SET_TYPE as STORAGE_SET_TYPE;
pub const _STORAGE_PROPERTY_ID_StorageDeviceProperty: _STORAGE_PROPERTY_ID = 0;
pub const _STORAGE_PROPERTY_ID_StorageAdapterProperty: _STORAGE_PROPERTY_ID = 1;
pub const _STORAGE_PROPERTY_ID_StorageDeviceIdProperty: _STORAGE_PROPERTY_ID = 2;
pub const _STORAGE_PROPERTY_ID_StorageDeviceUniqueIdProperty: _STORAGE_PROPERTY_ID = 3;
pub const _STORAGE_PROPERTY_ID_StorageDeviceWriteCacheProperty: _STORAGE_PROPERTY_ID = 4;
pub const _STORAGE_PROPERTY_ID_StorageMiniportProperty: _STORAGE_PROPERTY_ID = 5;
pub const _STORAGE_PROPERTY_ID_StorageAccessAlignmentProperty: _STORAGE_PROPERTY_ID = 6;
pub const _STORAGE_PROPERTY_ID_StorageDeviceSeekPenaltyProperty: _STORAGE_PROPERTY_ID = 7;
pub const _STORAGE_PROPERTY_ID_StorageDeviceTrimProperty: _STORAGE_PROPERTY_ID = 8;
pub const _STORAGE_PROPERTY_ID_StorageDeviceWriteAggregationProperty: _STORAGE_PROPERTY_ID = 9;
pub const _STORAGE_PROPERTY_ID_StorageDeviceDeviceTelemetryProperty: _STORAGE_PROPERTY_ID = 10;
pub const _STORAGE_PROPERTY_ID_StorageDeviceLBProvisioningProperty: _STORAGE_PROPERTY_ID = 11;
pub const _STORAGE_PROPERTY_ID_StorageDevicePowerProperty: _STORAGE_PROPERTY_ID = 12;
pub const _STORAGE_PROPERTY_ID_StorageDeviceCopyOffloadProperty: _STORAGE_PROPERTY_ID = 13;
pub const _STORAGE_PROPERTY_ID_StorageDeviceResiliencyProperty: _STORAGE_PROPERTY_ID = 14;
pub const _STORAGE_PROPERTY_ID_StorageDeviceMediumProductType: _STORAGE_PROPERTY_ID = 15;
pub const _STORAGE_PROPERTY_ID_StorageAdapterRpmbProperty: _STORAGE_PROPERTY_ID = 16;
pub const _STORAGE_PROPERTY_ID_StorageAdapterCryptoProperty: _STORAGE_PROPERTY_ID = 17;
pub const _STORAGE_PROPERTY_ID_StorageDeviceIoCapabilityProperty: _STORAGE_PROPERTY_ID = 48;
pub const _STORAGE_PROPERTY_ID_StorageAdapterProtocolSpecificProperty: _STORAGE_PROPERTY_ID = 49;
pub const _STORAGE_PROPERTY_ID_StorageDeviceProtocolSpecificProperty: _STORAGE_PROPERTY_ID = 50;
pub const _STORAGE_PROPERTY_ID_StorageAdapterTemperatureProperty: _STORAGE_PROPERTY_ID = 51;
pub const _STORAGE_PROPERTY_ID_StorageDeviceTemperatureProperty: _STORAGE_PROPERTY_ID = 52;
pub const _STORAGE_PROPERTY_ID_StorageAdapterPhysicalTopologyProperty: _STORAGE_PROPERTY_ID = 53;
pub const _STORAGE_PROPERTY_ID_StorageDevicePhysicalTopologyProperty: _STORAGE_PROPERTY_ID = 54;
pub const _STORAGE_PROPERTY_ID_StorageDeviceAttributesProperty: _STORAGE_PROPERTY_ID = 55;
pub const _STORAGE_PROPERTY_ID_StorageDeviceManagementStatus: _STORAGE_PROPERTY_ID = 56;
pub const _STORAGE_PROPERTY_ID_StorageAdapterSerialNumberProperty: _STORAGE_PROPERTY_ID = 57;
pub const _STORAGE_PROPERTY_ID_StorageDeviceLocationProperty: _STORAGE_PROPERTY_ID = 58;
pub const _STORAGE_PROPERTY_ID_StorageDeviceNumaProperty: _STORAGE_PROPERTY_ID = 59;
pub const _STORAGE_PROPERTY_ID_StorageDeviceZonedDeviceProperty: _STORAGE_PROPERTY_ID = 60;
pub const _STORAGE_PROPERTY_ID_StorageDeviceUnsafeShutdownCount: _STORAGE_PROPERTY_ID = 61;
pub const _STORAGE_PROPERTY_ID_StorageDeviceEnduranceProperty: _STORAGE_PROPERTY_ID = 62;
pub type _STORAGE_PROPERTY_ID = ::std::os::raw::c_int;
pub use self::_STORAGE_PROPERTY_ID as STORAGE_PROPERTY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROPERTY_QUERY {
  pub PropertyId: STORAGE_PROPERTY_ID,
  pub QueryType: STORAGE_QUERY_TYPE,
  pub AdditionalParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROPERTY_QUERY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROPERTY_QUERY>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_PROPERTY_QUERY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROPERTY_QUERY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROPERTY_QUERY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_QUERY>())).PropertyId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_QUERY),
      "::",
      stringify!(PropertyId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_QUERY>())).QueryType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_QUERY),
      "::",
      stringify!(QueryType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROPERTY_QUERY>())).AdditionalParameters as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_QUERY),
      "::",
      stringify!(AdditionalParameters)
    )
  );
}
pub type STORAGE_PROPERTY_QUERY = _STORAGE_PROPERTY_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROPERTY_SET {
  pub PropertyId: STORAGE_PROPERTY_ID,
  pub SetType: STORAGE_SET_TYPE,
  pub AdditionalParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROPERTY_SET() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROPERTY_SET>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_PROPERTY_SET))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROPERTY_SET>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROPERTY_SET))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_SET>())).PropertyId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_SET),
      "::",
      stringify!(PropertyId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_SET>())).SetType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_SET),
      "::",
      stringify!(SetType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROPERTY_SET>())).AdditionalParameters as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_SET),
      "::",
      stringify!(AdditionalParameters)
    )
  );
}
pub type STORAGE_PROPERTY_SET = _STORAGE_PROPERTY_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DESCRIPTOR_HEADER {
  pub Version: DWORD,
  pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DESCRIPTOR_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DESCRIPTOR_HEADER>(),
    8usize,
    concat!("Size of: ", stringify!(_STORAGE_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DESCRIPTOR_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DESCRIPTOR_HEADER>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DESCRIPTOR_HEADER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DESCRIPTOR_HEADER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DESCRIPTOR_HEADER),
      "::",
      stringify!(Size)
    )
  );
}
pub type STORAGE_DESCRIPTOR_HEADER = _STORAGE_DESCRIPTOR_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceType: BYTE,
  pub DeviceTypeModifier: BYTE,
  pub RemovableMedia: BOOLEAN,
  pub CommandQueueing: BOOLEAN,
  pub VendorIdOffset: DWORD,
  pub ProductIdOffset: DWORD,
  pub ProductRevisionOffset: DWORD,
  pub SerialNumberOffset: DWORD,
  pub BusType: STORAGE_BUS_TYPE,
  pub RawPropertiesLength: DWORD,
  pub RawDeviceProperties: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_DESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).DeviceType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).DeviceTypeModifier as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(DeviceTypeModifier)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).RemovableMedia as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(RemovableMedia)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).CommandQueueing as *const _ as usize
    },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(CommandQueueing)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).VendorIdOffset as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(VendorIdOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).ProductIdOffset as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ProductIdOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).ProductRevisionOffset as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ProductRevisionOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).SerialNumberOffset as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(SerialNumberOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).BusType as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(BusType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).RawPropertiesLength as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(RawPropertiesLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).RawDeviceProperties as *const _
        as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(RawDeviceProperties)
    )
  );
}
pub type STORAGE_DEVICE_DESCRIPTOR = _STORAGE_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ADAPTER_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub MaximumTransferLength: DWORD,
  pub MaximumPhysicalPages: DWORD,
  pub AlignmentMask: DWORD,
  pub AdapterUsesPio: BOOLEAN,
  pub AdapterScansDown: BOOLEAN,
  pub CommandQueueing: BOOLEAN,
  pub AcceleratedTransfer: BOOLEAN,
  pub BusType: BYTE,
  pub BusMajorVersion: WORD,
  pub BusMinorVersion: WORD,
  pub SrbType: BYTE,
  pub AddressType: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_ADAPTER_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ADAPTER_DESCRIPTOR>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_ADAPTER_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ADAPTER_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_ADAPTER_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).MaximumTransferLength as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(MaximumTransferLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).MaximumPhysicalPages as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(MaximumPhysicalPages)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AlignmentMask as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AlignmentMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AdapterUsesPio as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AdapterUsesPio)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AdapterScansDown as *const _ as usize
    },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AdapterScansDown)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).CommandQueueing as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(CommandQueueing)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AcceleratedTransfer as *const _
        as usize
    },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AcceleratedTransfer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).BusType as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(BusType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).BusMajorVersion as *const _ as usize
    },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(BusMajorVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).BusMinorVersion as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(BusMinorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).SrbType as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(SrbType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AddressType as *const _ as usize
    },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AddressType)
    )
  );
}
pub type STORAGE_ADAPTER_DESCRIPTOR = _STORAGE_ADAPTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub BytesPerCacheLine: DWORD,
  pub BytesOffsetForCacheAlignment: DWORD,
  pub BytesPerLogicalSector: DWORD,
  pub BytesPerPhysicalSector: DWORD,
  pub BytesOffsetForSectorAlignment: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>(),
    28usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesPerCacheLine as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesPerCacheLine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesOffsetForCacheAlignment
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesOffsetForCacheAlignment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesPerLogicalSector
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesPerLogicalSector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesPerPhysicalSector
        as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesPerPhysicalSector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesOffsetForSectorAlignment
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesOffsetForSectorAlignment)
    )
  );
}
pub type STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub MediumProductType: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>())).Version as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>())).MediumProductType
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR),
      "::",
      stringify!(MediumProductType)
    )
  );
}
pub type STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetReserved: _STORAGE_PORT_CODE_SET = 0;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetStorport: _STORAGE_PORT_CODE_SET = 1;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSCSIport: _STORAGE_PORT_CODE_SET = 2;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSpaceport: _STORAGE_PORT_CODE_SET = 3;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetATAport: _STORAGE_PORT_CODE_SET = 4;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetUSBport: _STORAGE_PORT_CODE_SET = 5;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSBP2port: _STORAGE_PORT_CODE_SET = 6;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSDport: _STORAGE_PORT_CODE_SET = 7;
pub type _STORAGE_PORT_CODE_SET = ::std::os::raw::c_int;
pub use self::_STORAGE_PORT_CODE_SET as STORAGE_PORT_CODE_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_MINIPORT_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Portdriver: STORAGE_PORT_CODE_SET,
  pub LUNResetSupported: BOOLEAN,
  pub TargetResetSupported: BOOLEAN,
  pub IoTimeoutValue: WORD,
  pub ExtraIoInfoSupported: BOOLEAN,
  pub Reserved0: [BYTE; 3usize],
  pub Reserved1: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_MINIPORT_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_MINIPORT_DESCRIPTOR>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_MINIPORT_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_MINIPORT_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_MINIPORT_DESCRIPTOR))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Portdriver as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Portdriver)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).LUNResetSupported as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(LUNResetSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).TargetResetSupported as *const _
        as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(TargetResetSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).IoTimeoutValue as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(IoTimeoutValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).ExtraIoInfoSupported as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(ExtraIoInfoSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Reserved0 as *const _ as usize
    },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Reserved1 as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Reserved1)
    )
  );
}
pub type STORAGE_MINIPORT_DESCRIPTOR = _STORAGE_MINIPORT_DESCRIPTOR;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetReserved: _STORAGE_IDENTIFIER_CODE_SET = 0;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetBinary: _STORAGE_IDENTIFIER_CODE_SET = 1;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetAscii: _STORAGE_IDENTIFIER_CODE_SET = 2;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetUtf8: _STORAGE_IDENTIFIER_CODE_SET = 3;
pub type _STORAGE_IDENTIFIER_CODE_SET = ::std::os::raw::c_int;
pub use self::_STORAGE_IDENTIFIER_CODE_SET as STORAGE_IDENTIFIER_CODE_SET;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeVendorSpecific: _STORAGE_IDENTIFIER_TYPE = 0;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeVendorId: _STORAGE_IDENTIFIER_TYPE = 1;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeEUI64: _STORAGE_IDENTIFIER_TYPE = 2;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeFCPHName: _STORAGE_IDENTIFIER_TYPE = 3;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypePortRelative: _STORAGE_IDENTIFIER_TYPE = 4;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeTargetPortGroup: _STORAGE_IDENTIFIER_TYPE = 5;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeLogicalUnitGroup: _STORAGE_IDENTIFIER_TYPE = 6;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeMD5LogicalUnitIdentifier: _STORAGE_IDENTIFIER_TYPE =
  7;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeScsiNameString: _STORAGE_IDENTIFIER_TYPE = 8;
pub type _STORAGE_IDENTIFIER_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_IDENTIFIER_TYPE as STORAGE_IDENTIFIER_TYPE;
pub const _STORAGE_ID_NAA_FORMAT_StorageIdNAAFormatIEEEExtended: _STORAGE_ID_NAA_FORMAT = 2;
pub const _STORAGE_ID_NAA_FORMAT_StorageIdNAAFormatIEEERegistered: _STORAGE_ID_NAA_FORMAT = 3;
pub const _STORAGE_ID_NAA_FORMAT_StorageIdNAAFormatIEEEERegisteredExtended: _STORAGE_ID_NAA_FORMAT =
  5;
pub type _STORAGE_ID_NAA_FORMAT = ::std::os::raw::c_int;
pub use self::_STORAGE_ID_NAA_FORMAT as STORAGE_ID_NAA_FORMAT;
pub const _STORAGE_ASSOCIATION_TYPE_StorageIdAssocDevice: _STORAGE_ASSOCIATION_TYPE = 0;
pub const _STORAGE_ASSOCIATION_TYPE_StorageIdAssocPort: _STORAGE_ASSOCIATION_TYPE = 1;
pub const _STORAGE_ASSOCIATION_TYPE_StorageIdAssocTarget: _STORAGE_ASSOCIATION_TYPE = 2;
pub type _STORAGE_ASSOCIATION_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_ASSOCIATION_TYPE as STORAGE_ASSOCIATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDENTIFIER {
  pub CodeSet: STORAGE_IDENTIFIER_CODE_SET,
  pub Type: STORAGE_IDENTIFIER_TYPE,
  pub IdentifierSize: WORD,
  pub NextOffset: WORD,
  pub Association: STORAGE_ASSOCIATION_TYPE,
  pub Identifier: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_IDENTIFIER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_IDENTIFIER>(),
    20usize,
    concat!("Size of: ", stringify!(_STORAGE_IDENTIFIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_IDENTIFIER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_IDENTIFIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).CodeSet as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(CodeSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).Type as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).IdentifierSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(IdentifierSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).NextOffset as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(NextOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).Association as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(Association)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).Identifier as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(Identifier)
    )
  );
}
pub type STORAGE_IDENTIFIER = _STORAGE_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_ID_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfIdentifiers: DWORD,
  pub Identifiers: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_ID_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_ID_DESCRIPTOR>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_ID_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).NumberOfIdentifiers as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(NumberOfIdentifiers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).Identifiers as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(Identifiers)
    )
  );
}
pub type STORAGE_DEVICE_ID_DESCRIPTOR = _STORAGE_DEVICE_ID_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_LB_PROVISIONING_MAP_RESOURCES {
  pub Size: DWORD,
  pub Version: DWORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved1: [BYTE; 3usize],
  pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved3: [BYTE; 3usize],
  pub AvailableMappingResources: DWORDLONG,
  pub UsedMappingResources: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_LB_PROVISIONING_MAP_RESOURCES() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Version as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Reserved1 as *const _
        as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Reserved3 as *const _
        as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Reserved3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).AvailableMappingResources
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(AvailableMappingResources)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).UsedMappingResources
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(UsedMappingResources)
    )
  );
}
impl _STORAGE_LB_PROVISIONING_MAP_RESOURCES {
  #[inline]
  pub fn AvailableMappingResourcesValid(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_AvailableMappingResourcesValid(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn UsedMappingResourcesValid(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_UsedMappingResourcesValid(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 6u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    AvailableMappingResourcesValid: BYTE,
    UsedMappingResourcesValid: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let AvailableMappingResourcesValid: u8 =
        unsafe { ::std::mem::transmute(AvailableMappingResourcesValid) };
      AvailableMappingResourcesValid as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let UsedMappingResourcesValid: u8 =
        unsafe { ::std::mem::transmute(UsedMappingResourcesValid) };
      UsedMappingResourcesValid as u64
    });
    __bindgen_bitfield_unit.set(2usize, 6u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
  #[inline]
  pub fn AvailableMappingResourcesScope(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
  }
  #[inline]
  pub fn set_AvailableMappingResourcesScope(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_2.set(0usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn UsedMappingResourcesScope(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
  }
  #[inline]
  pub fn set_UsedMappingResourcesScope(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_2.set(2usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved2(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved2(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_2.set(4usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_2(
    AvailableMappingResourcesScope: BYTE,
    UsedMappingResourcesScope: BYTE,
    Reserved2: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 2u8, {
      let AvailableMappingResourcesScope: u8 =
        unsafe { ::std::mem::transmute(AvailableMappingResourcesScope) };
      AvailableMappingResourcesScope as u64
    });
    __bindgen_bitfield_unit.set(2usize, 2u8, {
      let UsedMappingResourcesScope: u8 =
        unsafe { ::std::mem::transmute(UsedMappingResourcesScope) };
      UsedMappingResourcesScope as u64
    });
    __bindgen_bitfield_unit.set(4usize, 4u8, {
      let Reserved2: u8 = unsafe { ::std::mem::transmute(Reserved2) };
      Reserved2 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_LB_PROVISIONING_MAP_RESOURCES = _STORAGE_LB_PROVISIONING_MAP_RESOURCES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NameOffset: DWORD,
  pub NumberOfLogicalCopies: DWORD,
  pub NumberOfPhysicalCopies: DWORD,
  pub PhysicalDiskRedundancy: DWORD,
  pub NumberOfColumns: DWORD,
  pub Interleave: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_RESILIENCY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NameOffset as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NumberOfLogicalCopies
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NumberOfLogicalCopies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NumberOfPhysicalCopies
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NumberOfPhysicalCopies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).PhysicalDiskRedundancy
        as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(PhysicalDiskRedundancy)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NumberOfColumns as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NumberOfColumns)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).Interleave as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(Interleave)
    )
  );
}
pub type STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR;
pub const _STORAGE_RPMB_FRAME_TYPE_StorageRpmbFrameTypeUnknown: _STORAGE_RPMB_FRAME_TYPE = 0;
pub const _STORAGE_RPMB_FRAME_TYPE_StorageRpmbFrameTypeStandard: _STORAGE_RPMB_FRAME_TYPE = 1;
pub const _STORAGE_RPMB_FRAME_TYPE_StorageRpmbFrameTypeMax: _STORAGE_RPMB_FRAME_TYPE = 2;
pub type _STORAGE_RPMB_FRAME_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_RPMB_FRAME_TYPE as STORAGE_RPMB_FRAME_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_RPMB_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SizeInBytes: DWORD,
  pub MaxReliableWriteSizeInBytes: DWORD,
  pub FrameFormat: STORAGE_RPMB_FRAME_TYPE,
}
#[test]
fn bindgen_test_layout__STORAGE_RPMB_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_RPMB_DESCRIPTOR>(),
    20usize,
    concat!("Size of: ", stringify!(_STORAGE_RPMB_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_RPMB_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_RPMB_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).SizeInBytes as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(SizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).MaxReliableWriteSizeInBytes as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(MaxReliableWriteSizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).FrameFormat as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(FrameFormat)
    )
  );
}
pub type STORAGE_RPMB_DESCRIPTOR = _STORAGE_RPMB_DESCRIPTOR;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmUnknown: _STORAGE_CRYPTO_ALGORITHM_ID =
  0;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmXTSAES: _STORAGE_CRYPTO_ALGORITHM_ID =
  1;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmBitlockerAESCBC:
  _STORAGE_CRYPTO_ALGORITHM_ID = 2;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmAESECB: _STORAGE_CRYPTO_ALGORITHM_ID =
  3;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmESSIVAESCBC:
  _STORAGE_CRYPTO_ALGORITHM_ID = 4;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmMax: _STORAGE_CRYPTO_ALGORITHM_ID = 5;
pub type _STORAGE_CRYPTO_ALGORITHM_ID = ::std::os::raw::c_int;
pub use self::_STORAGE_CRYPTO_ALGORITHM_ID as STORAGE_CRYPTO_ALGORITHM_ID;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySizeUnknown: _STORAGE_CRYPTO_KEY_SIZE = 0;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize128Bits: _STORAGE_CRYPTO_KEY_SIZE = 1;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize192Bits: _STORAGE_CRYPTO_KEY_SIZE = 2;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize256Bits: _STORAGE_CRYPTO_KEY_SIZE = 3;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize512Bits: _STORAGE_CRYPTO_KEY_SIZE = 4;
pub type _STORAGE_CRYPTO_KEY_SIZE = ::std::os::raw::c_int;
pub use self::_STORAGE_CRYPTO_KEY_SIZE as STORAGE_CRYPTO_KEY_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_CRYPTO_CAPABILITY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub CryptoCapabilityIndex: DWORD,
  pub AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
  pub KeySize: STORAGE_CRYPTO_KEY_SIZE,
  pub DataUnitSizeBitmask: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_CRYPTO_CAPABILITY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_CRYPTO_CAPABILITY>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_CRYPTO_CAPABILITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_CRYPTO_CAPABILITY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_CRYPTO_CAPABILITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).CryptoCapabilityIndex as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(CryptoCapabilityIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).AlgorithmId as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(AlgorithmId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).KeySize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(KeySize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).DataUnitSizeBitmask as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(DataUnitSizeBitmask)
    )
  );
}
pub type STORAGE_CRYPTO_CAPABILITY = _STORAGE_CRYPTO_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_CRYPTO_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumKeysSupported: DWORD,
  pub NumCryptoCapabilities: DWORD,
  pub CryptoCapabilities: [STORAGE_CRYPTO_CAPABILITY; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_CRYPTO_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_CRYPTO_DESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_CRYPTO_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_CRYPTO_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_CRYPTO_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).NumKeysSupported as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(NumKeysSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).NumCryptoCapabilities as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(NumCryptoCapabilities)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).CryptoCapabilities as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(CryptoCapabilities)
    )
  );
}
pub type STORAGE_CRYPTO_DESCRIPTOR = _STORAGE_CRYPTO_DESCRIPTOR;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeUnspecified: _STORAGE_TIER_MEDIA_TYPE = 0;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeDisk: _STORAGE_TIER_MEDIA_TYPE = 1;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeSsd: _STORAGE_TIER_MEDIA_TYPE = 2;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeScm: _STORAGE_TIER_MEDIA_TYPE = 4;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeMax: _STORAGE_TIER_MEDIA_TYPE = 5;
pub type _STORAGE_TIER_MEDIA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_TIER_MEDIA_TYPE as STORAGE_TIER_MEDIA_TYPE;
pub const _STORAGE_TIER_CLASS_StorageTierClassUnspecified: _STORAGE_TIER_CLASS = 0;
pub const _STORAGE_TIER_CLASS_StorageTierClassCapacity: _STORAGE_TIER_CLASS = 1;
pub const _STORAGE_TIER_CLASS_StorageTierClassPerformance: _STORAGE_TIER_CLASS = 2;
pub const _STORAGE_TIER_CLASS_StorageTierClassMax: _STORAGE_TIER_CLASS = 3;
pub type _STORAGE_TIER_CLASS = ::std::os::raw::c_int;
pub use self::_STORAGE_TIER_CLASS as STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_TIER {
  pub Id: GUID,
  pub Name: [WCHAR; 256usize],
  pub Description: [WCHAR; 256usize],
  pub Flags: DWORDLONG,
  pub ProvisionedCapacity: DWORDLONG,
  pub MediaType: STORAGE_TIER_MEDIA_TYPE,
  pub Class: STORAGE_TIER_CLASS,
}
#[test]
fn bindgen_test_layout__STORAGE_TIER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TIER>(),
    1064usize,
    concat!("Size of: ", stringify!(_STORAGE_TIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TIER>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_TIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Id as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Description as *const _ as usize },
    528usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Description)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Flags as *const _ as usize },
    1040usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).ProvisionedCapacity as *const _ as usize },
    1048usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(ProvisionedCapacity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).MediaType as *const _ as usize },
    1056usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(MediaType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Class as *const _ as usize },
    1060usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Class)
    )
  );
}
pub type STORAGE_TIER = _STORAGE_TIER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_TIERING_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub TotalNumberOfTiers: DWORD,
  pub NumberOfTiersReturned: DWORD,
  pub Tiers: [STORAGE_TIER; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_TIERING_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>(),
    1088usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).TotalNumberOfTiers as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(TotalNumberOfTiers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).NumberOfTiersReturned
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(NumberOfTiersReturned)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Tiers as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Tiers)
    )
  );
}
pub type STORAGE_DEVICE_TIERING_DESCRIPTOR = _STORAGE_DEVICE_TIERING_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfFaultDomains: DWORD,
  pub FaultDomainIds: [GUID; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>(),
    28usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).Version as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).NumberOfFaultDomains
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(NumberOfFaultDomains)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).FaultDomainIds as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(FaultDomainIds)
    )
  );
}
pub type STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeUnknown: _STORAGE_PROTOCOL_TYPE = 0;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeScsi: _STORAGE_PROTOCOL_TYPE = 1;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeAta: _STORAGE_PROTOCOL_TYPE = 2;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeNvme: _STORAGE_PROTOCOL_TYPE = 3;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeSd: _STORAGE_PROTOCOL_TYPE = 4;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeUfs: _STORAGE_PROTOCOL_TYPE = 5;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeProprietary: _STORAGE_PROTOCOL_TYPE = 126;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeMaxReserved: _STORAGE_PROTOCOL_TYPE = 127;
pub type _STORAGE_PROTOCOL_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_TYPE as STORAGE_PROTOCOL_TYPE;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeUnknown: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  0;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeIdentify: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  1;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeLogPage: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  2;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeFeature: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  3;
pub type _STORAGE_PROTOCOL_NVME_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_NVME_DATA_TYPE as STORAGE_PROTOCOL_NVME_DATA_TYPE;
pub const _STORAGE_PROTOCOL_ATA_DATA_TYPE_AtaDataTypeUnknown: _STORAGE_PROTOCOL_ATA_DATA_TYPE = 0;
pub const _STORAGE_PROTOCOL_ATA_DATA_TYPE_AtaDataTypeIdentify: _STORAGE_PROTOCOL_ATA_DATA_TYPE = 1;
pub const _STORAGE_PROTOCOL_ATA_DATA_TYPE_AtaDataTypeLogPage: _STORAGE_PROTOCOL_ATA_DATA_TYPE = 2;
pub type _STORAGE_PROTOCOL_ATA_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_ATA_DATA_TYPE as STORAGE_PROTOCOL_ATA_DATA_TYPE;
pub const _STORAGE_PROTOCOL_UFS_DATA_TYPE_UfsDataTypeUnknown: _STORAGE_PROTOCOL_UFS_DATA_TYPE = 0;
pub const _STORAGE_PROTOCOL_UFS_DATA_TYPE_UfsDataTypeQueryDescriptor:
  _STORAGE_PROTOCOL_UFS_DATA_TYPE = 1;
pub const _STORAGE_PROTOCOL_UFS_DATA_TYPE_UfsDataTypeMax: _STORAGE_PROTOCOL_UFS_DATA_TYPE = 2;
pub type _STORAGE_PROTOCOL_UFS_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_UFS_DATA_TYPE as STORAGE_PROTOCOL_UFS_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_SPECIFIC_DATA {
  pub ProtocolType: STORAGE_PROTOCOL_TYPE,
  pub DataType: DWORD,
  pub ProtocolDataRequestValue: DWORD,
  pub ProtocolDataRequestSubValue: DWORD,
  pub ProtocolDataOffset: DWORD,
  pub ProtocolDataLength: DWORD,
  pub FixedProtocolReturnData: DWORD,
  pub ProtocolDataRequestSubValue2: DWORD,
  pub ProtocolDataRequestSubValue3: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_SPECIFIC_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).DataType as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(DataType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestValue
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestSubValue
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestSubValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataOffset as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataLength as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).FixedProtocolReturnData
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(FixedProtocolReturnData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestSubValue2
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestSubValue2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestSubValue3
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestSubValue3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).Reserved as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PROTOCOL_SPECIFIC_DATA = _STORAGE_PROTOCOL_SPECIFIC_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
  pub ProtocolType: STORAGE_PROTOCOL_TYPE,
  pub DataType: DWORD,
  pub ProtocolDataValue: DWORD,
  pub ProtocolDataSubValue: DWORD,
  pub ProtocolDataOffset: DWORD,
  pub ProtocolDataLength: DWORD,
  pub FixedProtocolReturnData: DWORD,
  pub ProtocolDataSubValue2: DWORD,
  pub ProtocolDataSubValue3: DWORD,
  pub ProtocolDataSubValue4: DWORD,
  pub ProtocolDataSubValue5: DWORD,
  pub Reserved: [DWORD; 5usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_SPECIFIC_DATA_EXT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>(),
    64usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolType as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).DataType as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(DataType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataValue as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataOffset as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataLength as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).FixedProtocolReturnData
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(FixedProtocolReturnData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue2
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue3
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue4
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue5
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).Reserved as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA,
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_DATA_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>())).ProtocolSpecificData as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR),
      "::",
      stringify!(ProtocolSpecificData)
    )
  );
}
pub type STORAGE_PROTOCOL_DATA_DESCRIPTOR = _STORAGE_PROTOCOL_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>())).ProtocolSpecificData
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT),
      "::",
      stringify!(ProtocolSpecificData)
    )
  );
}
pub type STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_INFO {
  pub Index: WORD,
  pub Temperature: SHORT,
  pub OverThreshold: SHORT,
  pub UnderThreshold: SHORT,
  pub OverThresholdChangable: BOOLEAN,
  pub UnderThresholdChangable: BOOLEAN,
  pub EventGenerated: BOOLEAN,
  pub Reserved0: BYTE,
  pub Reserved1: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_TEMPERATURE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TEMPERATURE_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_TEMPERATURE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TEMPERATURE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_TEMPERATURE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Index as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Index)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Temperature as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Temperature)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).OverThreshold as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(OverThreshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).UnderThreshold as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(UnderThreshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).OverThresholdChangable as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(OverThresholdChangable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).UnderThresholdChangable as *const _
        as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(UnderThresholdChangable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).EventGenerated as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(EventGenerated)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Reserved0 as *const _ as usize },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Reserved1 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Reserved1)
    )
  );
}
pub type STORAGE_TEMPERATURE_INFO = _STORAGE_TEMPERATURE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_DATA_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub CriticalTemperature: SHORT,
  pub WarningTemperature: SHORT,
  pub InfoCount: WORD,
  pub Reserved0: [BYTE; 2usize],
  pub Reserved1: [DWORD; 2usize],
  pub TemperatureInfo: [STORAGE_TEMPERATURE_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_TEMPERATURE_DATA_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).CriticalTemperature
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(CriticalTemperature)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).WarningTemperature
        as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(WarningTemperature)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).InfoCount as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(InfoCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Reserved0 as *const _
        as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Reserved1 as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).TemperatureInfo as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(TemperatureInfo)
    )
  );
}
pub type STORAGE_TEMPERATURE_DATA_DESCRIPTOR = _STORAGE_TEMPERATURE_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_THRESHOLD {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: WORD,
  pub Index: WORD,
  pub Threshold: SHORT,
  pub OverThreshold: BOOLEAN,
  pub Reserved: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_TEMPERATURE_THRESHOLD() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TEMPERATURE_THRESHOLD>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_TEMPERATURE_THRESHOLD))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TEMPERATURE_THRESHOLD>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_TEMPERATURE_THRESHOLD))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Index as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Index)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Threshold as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Threshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).OverThreshold as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(OverThreshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Reserved as *const _ as usize
    },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_TEMPERATURE_THRESHOLD = _STORAGE_TEMPERATURE_THRESHOLD;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorUnknown: _STORAGE_DEVICE_FORM_FACTOR = 0;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor3_5: _STORAGE_DEVICE_FORM_FACTOR = 1;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor2_5: _STORAGE_DEVICE_FORM_FACTOR = 2;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor1_8: _STORAGE_DEVICE_FORM_FACTOR = 3;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor1_8Less: _STORAGE_DEVICE_FORM_FACTOR = 4;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorEmbedded: _STORAGE_DEVICE_FORM_FACTOR = 5;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorMemoryCard: _STORAGE_DEVICE_FORM_FACTOR = 6;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactormSata: _STORAGE_DEVICE_FORM_FACTOR = 7;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorM_2: _STORAGE_DEVICE_FORM_FACTOR = 8;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorPCIeBoard: _STORAGE_DEVICE_FORM_FACTOR = 9;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorDimm: _STORAGE_DEVICE_FORM_FACTOR = 10;
pub type _STORAGE_DEVICE_FORM_FACTOR = ::std::os::raw::c_int;
pub use self::_STORAGE_DEVICE_FORM_FACTOR as STORAGE_DEVICE_FORM_FACTOR;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusUnknown: _STORAGE_COMPONENT_HEALTH_STATUS =
  0;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusNormal: _STORAGE_COMPONENT_HEALTH_STATUS = 1;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusThrottled: _STORAGE_COMPONENT_HEALTH_STATUS =
  2;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusWarning: _STORAGE_COMPONENT_HEALTH_STATUS =
  3;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusDisabled: _STORAGE_COMPONENT_HEALTH_STATUS =
  4;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusFailed: _STORAGE_COMPONENT_HEALTH_STATUS = 5;
pub type _STORAGE_COMPONENT_HEALTH_STATUS = ::std::os::raw::c_int;
pub use self::_STORAGE_COMPONENT_HEALTH_STATUS as STORAGE_COMPONENT_HEALTH_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_SPEC_VERSION {
  pub __bindgen_anon_1: _STORAGE_SPEC_VERSION__bindgen_ty_1,
  pub AsUlong: DWORD,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_SPEC_VERSION__bindgen_ty_1 {
  pub MinorVersion: _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1,
  pub MajorVersion: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1 {
  pub __bindgen_anon_1: _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  pub AsUshort: WORD,
  _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub SubMinor: BYTE,
  pub Minor: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .SubMinor as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(SubMinor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .Minor as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Minor)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1>())).AsUshort
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AsUshort)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1>())).MinorVersion as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1),
      "::",
      stringify!(MinorVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1>())).MajorVersion as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1),
      "::",
      stringify!(MajorVersion)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_SPEC_VERSION))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_SPEC_VERSION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION>())).AsUlong as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION),
      "::",
      stringify!(AsUlong)
    )
  );
}
pub type STORAGE_SPEC_VERSION = _STORAGE_SPEC_VERSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PHYSICAL_DEVICE_DATA {
  pub DeviceId: DWORD,
  pub Role: DWORD,
  pub HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
  pub CommandProtocol: STORAGE_PROTOCOL_TYPE,
  pub SpecVersion: STORAGE_SPEC_VERSION,
  pub FormFactor: STORAGE_DEVICE_FORM_FACTOR,
  pub Vendor: [BYTE; 8usize],
  pub Model: [BYTE; 40usize],
  pub FirmwareRevision: [BYTE; 16usize],
  pub Capacity: DWORDLONG,
  pub PhysicalLocation: [BYTE; 32usize],
  pub Reserved: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_DEVICE_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_DEVICE_DATA>(),
    136usize,
    concat!("Size of: ", stringify!(_STORAGE_PHYSICAL_DEVICE_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_DEVICE_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_PHYSICAL_DEVICE_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).DeviceId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(DeviceId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Role as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Role)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).HealthStatus as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(HealthStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).CommandProtocol as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(CommandProtocol)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).SpecVersion as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(SpecVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).FormFactor as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(FormFactor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Vendor as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Vendor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Model as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Model)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).FirmwareRevision as *const _
        as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(FirmwareRevision)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Capacity as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Capacity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).PhysicalLocation as *const _
        as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(PhysicalLocation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Reserved as *const _ as usize
    },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PHYSICAL_DEVICE_DATA = _STORAGE_PHYSICAL_DEVICE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PHYSICAL_ADAPTER_DATA {
  pub AdapterId: DWORD,
  pub HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
  pub CommandProtocol: STORAGE_PROTOCOL_TYPE,
  pub SpecVersion: STORAGE_SPEC_VERSION,
  pub Vendor: [BYTE; 8usize],
  pub Model: [BYTE; 40usize],
  pub FirmwareRevision: [BYTE; 16usize],
  pub PhysicalLocation: [BYTE; 32usize],
  pub ExpanderConnected: BOOLEAN,
  pub Reserved0: [BYTE; 3usize],
  pub Reserved1: [DWORD; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_ADAPTER_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_ADAPTER_DATA>(),
    128usize,
    concat!("Size of: ", stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_ADAPTER_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).AdapterId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(AdapterId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).HealthStatus as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(HealthStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).CommandProtocol as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(CommandProtocol)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).SpecVersion as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(SpecVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Vendor as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Vendor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Model as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Model)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).FirmwareRevision as *const _
        as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(FirmwareRevision)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).PhysicalLocation as *const _
        as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(PhysicalLocation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).ExpanderConnected as *const _
        as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(ExpanderConnected)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Reserved0 as *const _ as usize
    },
    113usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Reserved1 as *const _ as usize
    },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Reserved1)
    )
  );
}
pub type STORAGE_PHYSICAL_ADAPTER_DATA = _STORAGE_PHYSICAL_ADAPTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PHYSICAL_NODE_DATA {
  pub NodeId: DWORD,
  pub AdapterCount: DWORD,
  pub AdapterDataLength: DWORD,
  pub AdapterDataOffset: DWORD,
  pub DeviceCount: DWORD,
  pub DeviceDataLength: DWORD,
  pub DeviceDataOffset: DWORD,
  pub Reserved: [DWORD; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_NODE_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_NODE_DATA>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_PHYSICAL_NODE_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_NODE_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PHYSICAL_NODE_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).NodeId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(NodeId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).AdapterCount as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(AdapterCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).AdapterDataLength as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(AdapterDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).AdapterDataOffset as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(AdapterDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).DeviceCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(DeviceCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).DeviceDataLength as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(DeviceDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).DeviceDataOffset as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(DeviceDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).Reserved as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PHYSICAL_NODE_DATA = _STORAGE_PHYSICAL_NODE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NodeCount: DWORD,
  pub Reserved: DWORD,
  pub Node: [STORAGE_PHYSICAL_NODE_DATA; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).NodeCount as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(NodeCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Reserved as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Node as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Node)
    )
  );
}
pub type STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub LunMaxIoCount: DWORD,
  pub AdapterMaxIoCount: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).Version as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).LunMaxIoCount as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(LunMaxIoCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).AdapterMaxIoCount
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(AdapterMaxIoCount)
    )
  );
}
pub type STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Attributes: DWORD64,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>())).Attributes as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR),
      "::",
      stringify!(Attributes)
    )
  );
}
pub type STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthUnknown: _STORAGE_DISK_HEALTH_STATUS = 0;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthUnhealthy: _STORAGE_DISK_HEALTH_STATUS = 1;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthWarning: _STORAGE_DISK_HEALTH_STATUS = 2;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthHealthy: _STORAGE_DISK_HEALTH_STATUS = 3;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthMax: _STORAGE_DISK_HEALTH_STATUS = 4;
pub type _STORAGE_DISK_HEALTH_STATUS = ::std::os::raw::c_int;
pub use self::_STORAGE_DISK_HEALTH_STATUS as STORAGE_DISK_HEALTH_STATUS;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusNone: _STORAGE_DISK_OPERATIONAL_STATUS = 0;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusUnknown: _STORAGE_DISK_OPERATIONAL_STATUS =
  1;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusOk: _STORAGE_DISK_OPERATIONAL_STATUS = 2;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusPredictingFailure:
  _STORAGE_DISK_OPERATIONAL_STATUS = 3;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusInService: _STORAGE_DISK_OPERATIONAL_STATUS =
  4;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusHardwareError:
  _STORAGE_DISK_OPERATIONAL_STATUS = 5;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusNotUsable: _STORAGE_DISK_OPERATIONAL_STATUS =
  6;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusTransientError:
  _STORAGE_DISK_OPERATIONAL_STATUS = 7;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusMissing: _STORAGE_DISK_OPERATIONAL_STATUS =
  8;
pub type _STORAGE_DISK_OPERATIONAL_STATUS = ::std::os::raw::c_int;
pub use self::_STORAGE_DISK_OPERATIONAL_STATUS as STORAGE_DISK_OPERATIONAL_STATUS;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonUnknown:
  _STORAGE_OPERATIONAL_STATUS_REASON = 0;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonScsiSenseCode:
  _STORAGE_OPERATIONAL_STATUS_REASON = 1;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonMedia: _STORAGE_OPERATIONAL_STATUS_REASON =
  2;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonIo: _STORAGE_OPERATIONAL_STATUS_REASON = 3;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonThresholdExceeded:
  _STORAGE_OPERATIONAL_STATUS_REASON = 4;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonLostData:
  _STORAGE_OPERATIONAL_STATUS_REASON = 5;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonEnergySource:
  _STORAGE_OPERATIONAL_STATUS_REASON = 6;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonConfiguration:
  _STORAGE_OPERATIONAL_STATUS_REASON = 7;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonDeviceController:
  _STORAGE_OPERATIONAL_STATUS_REASON = 8;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonMediaController:
  _STORAGE_OPERATIONAL_STATUS_REASON = 9;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonComponent:
  _STORAGE_OPERATIONAL_STATUS_REASON = 10;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonNVDIMM_N:
  _STORAGE_OPERATIONAL_STATUS_REASON = 11;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonBackgroundOperation:
  _STORAGE_OPERATIONAL_STATUS_REASON = 12;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonInvalidFirmware:
  _STORAGE_OPERATIONAL_STATUS_REASON = 13;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonHealthCheck:
  _STORAGE_OPERATIONAL_STATUS_REASON = 14;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonLostDataPersistence:
  _STORAGE_OPERATIONAL_STATUS_REASON = 15;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonDisabledByPlatform:
  _STORAGE_OPERATIONAL_STATUS_REASON = 16;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonLostWritePersistence:
  _STORAGE_OPERATIONAL_STATUS_REASON = 17;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonDataPersistenceLossImminent:
  _STORAGE_OPERATIONAL_STATUS_REASON = 18;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonWritePersistenceLossImminent:
  _STORAGE_OPERATIONAL_STATUS_REASON = 19;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonMax: _STORAGE_OPERATIONAL_STATUS_REASON =
  20;
pub type _STORAGE_OPERATIONAL_STATUS_REASON = ::std::os::raw::c_int;
pub use self::_STORAGE_OPERATIONAL_STATUS_REASON as STORAGE_OPERATIONAL_STATUS_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Reason: STORAGE_OPERATIONAL_STATUS_REASON,
  pub RawBytes: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_OPERATIONAL_REASON__bindgen_ty_1 {
  pub ScsiSenseKey: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1,
  pub NVDIMM_N: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2,
  pub AsUlong: DWORD,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1 {
  pub SenseKey: BYTE,
  pub ASC: BYTE,
  pub ASCQ: BYTE,
  pub Reserved: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).SenseKey
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(SenseKey)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).ASC
        as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ASC)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).ASCQ
        as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ASCQ)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).Reserved
        as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2 {
  pub CriticalHealth: BYTE,
  pub ModuleHealth: [BYTE; 2usize],
  pub ErrorThresholdStatus: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>()))
        .CriticalHealth as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(CriticalHealth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>()))
        .ModuleHealth as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(ModuleHealth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>()))
        .ErrorThresholdStatus as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(ErrorThresholdStatus)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>())).ScsiSenseKey as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1),
      "::",
      stringify!(ScsiSenseKey)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>())).NVDIMM_N as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1),
      "::",
      stringify!(NVDIMM_N)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>())).AsUlong as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1),
      "::",
      stringify!(AsUlong)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_OPERATIONAL_REASON))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_OPERATIONAL_REASON))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).Reason as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(Reason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).RawBytes as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(RawBytes)
    )
  );
}
pub type STORAGE_OPERATIONAL_REASON = _STORAGE_OPERATIONAL_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_MANAGEMENT_STATUS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Health: STORAGE_DISK_HEALTH_STATUS,
  pub NumberOfOperationalStatus: DWORD,
  pub NumberOfAdditionalReasons: DWORD,
  pub OperationalStatus: [STORAGE_DISK_OPERATIONAL_STATUS; 16usize],
  pub AdditionalReasons: [STORAGE_OPERATIONAL_REASON; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_MANAGEMENT_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_MANAGEMENT_STATUS>(),
    100usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_MANAGEMENT_STATUS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).Health as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(Health)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).NumberOfOperationalStatus
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfOperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).NumberOfAdditionalReasons
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfAdditionalReasons)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).OperationalStatus as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(OperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).AdditionalReasons as *const _
        as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(AdditionalReasons)
    )
  );
}
pub type STORAGE_DEVICE_MANAGEMENT_STATUS = _STORAGE_DEVICE_MANAGEMENT_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_ADAPTER_SERIAL_NUMBER {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SerialNumber: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout__STORAGE_ADAPTER_SERIAL_NUMBER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ADAPTER_SERIAL_NUMBER>(),
    264usize,
    concat!("Size of: ", stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ADAPTER_SERIAL_NUMBER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_SERIAL_NUMBER>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_SERIAL_NUMBER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_SERIAL_NUMBER>())).SerialNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER),
      "::",
      stringify!(SerialNumber)
    )
  );
}
pub type STORAGE_ADAPTER_SERIAL_NUMBER = _STORAGE_ADAPTER_SERIAL_NUMBER;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeUnknown: _STORAGE_ZONED_DEVICE_TYPES = 0;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeHostManaged: _STORAGE_ZONED_DEVICE_TYPES = 1;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeHostAware: _STORAGE_ZONED_DEVICE_TYPES = 2;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeDeviceManaged: _STORAGE_ZONED_DEVICE_TYPES = 3;
pub type _STORAGE_ZONED_DEVICE_TYPES = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONED_DEVICE_TYPES as STORAGE_ZONED_DEVICE_TYPES;
pub const _STORAGE_ZONE_TYPES_ZoneTypeUnknown: _STORAGE_ZONE_TYPES = 0;
pub const _STORAGE_ZONE_TYPES_ZoneTypeConventional: _STORAGE_ZONE_TYPES = 1;
pub const _STORAGE_ZONE_TYPES_ZoneTypeSequentialWriteRequired: _STORAGE_ZONE_TYPES = 2;
pub const _STORAGE_ZONE_TYPES_ZoneTypeSequentialWritePreferred: _STORAGE_ZONE_TYPES = 3;
pub const _STORAGE_ZONE_TYPES_ZoneTypeMax: _STORAGE_ZONE_TYPES = 4;
pub type _STORAGE_ZONE_TYPES = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONE_TYPES as STORAGE_ZONE_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONE_GROUP {
  pub ZoneCount: DWORD,
  pub ZoneType: STORAGE_ZONE_TYPES,
  pub ZoneSize: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_ZONE_GROUP() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONE_GROUP>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_ZONE_GROUP))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONE_GROUP>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_ZONE_GROUP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_GROUP>())).ZoneCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_GROUP),
      "::",
      stringify!(ZoneCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_GROUP>())).ZoneType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_GROUP),
      "::",
      stringify!(ZoneType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_GROUP>())).ZoneSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_GROUP),
      "::",
      stringify!(ZoneSize)
    )
  );
}
pub type STORAGE_ZONE_GROUP = _STORAGE_ZONE_GROUP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceType: STORAGE_ZONED_DEVICE_TYPES,
  pub ZoneCount: DWORD,
  pub ZoneAttributes: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1,
  pub ZoneGroupCount: DWORD,
  pub ZoneGroup: [STORAGE_ZONE_GROUP; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1 {
  pub SequentialRequiredZone: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
  pub SequentialPreferredZone: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
  pub MaxOpenZoneCount: DWORD,
  pub UnrestrictedRead: BOOLEAN,
  pub Reserved: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()))
        .MaxOpenZoneCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(MaxOpenZoneCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()))
        .UnrestrictedRead as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(UnrestrictedRead)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()))
        .Reserved as *const _ as usize
    },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
  pub OptimalOpenZoneCount: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>()))
        .OptimalOpenZoneCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(OptimalOpenZoneCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>()))
        .Reserved as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Reserved)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>()))
        .SequentialRequiredZone as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1),
      "::",
      stringify!(SequentialRequiredZone)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>()))
        .SequentialPreferredZone as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1),
      "::",
      stringify!(SequentialPreferredZone)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).DeviceType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneCount as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneAttributes as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneGroupCount as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneGroupCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneGroup as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneGroup)
    )
  );
}
pub type STORAGE_ZONED_DEVICE_DESCRIPTOR = _STORAGE_ZONED_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_LOCATION {
  pub Socket: DWORD,
  pub Slot: DWORD,
  pub Adapter: DWORD,
  pub Port: DWORD,
  pub __bindgen_anon_1: _DEVICE_LOCATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_LOCATION__bindgen_ty_1 {
  pub __bindgen_anon_1: _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1,
  pub __bindgen_anon_2: _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1 {
  pub Channel: DWORD,
  pub Device: DWORD,
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>())).Channel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Channel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>())).Device as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Device)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2 {
  pub Target: DWORD,
  pub Lun: DWORD,
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>())).Target as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Target)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>())).Lun as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Lun)
    )
  );
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_DEVICE_LOCATION__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_DEVICE_LOCATION__bindgen_ty_1))
  );
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION>(),
    24usize,
    concat!("Size of: ", stringify!(_DEVICE_LOCATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_DEVICE_LOCATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Socket as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Socket)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Slot as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Adapter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Adapter)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Port as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Port)
    )
  );
}
pub type DEVICE_LOCATION = _DEVICE_LOCATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_LOCATION_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Location: DEVICE_LOCATION,
  pub StringOffset: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_LOCATION_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>(),
    36usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).Location as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(Location)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).StringOffset as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(StringOffset)
    )
  );
}
pub type STORAGE_DEVICE_LOCATION_DESCRIPTOR = _STORAGE_DEVICE_LOCATION_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMA_PROPERTY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumaNode: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMA_PROPERTY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMA_PROPERTY>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMA_PROPERTY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMA_PROPERTY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMA_PROPERTY))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMA_PROPERTY>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMA_PROPERTY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMA_PROPERTY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMA_PROPERTY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMA_PROPERTY>())).NumaNode as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMA_PROPERTY),
      "::",
      stringify!(NumaNode)
    )
  );
}
pub type STORAGE_DEVICE_NUMA_PROPERTY = _STORAGE_DEVICE_NUMA_PROPERTY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub UnsafeShutdownCount: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>())).UnsafeShutdownCount
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT),
      "::",
      stringify!(UnsafeShutdownCount)
    )
  );
}
pub type STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_INFO {
  pub ValidFields: DWORD,
  pub GroupId: DWORD,
  pub Flags: _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1,
  pub LifePercentage: DWORD,
  pub BytesReadCount: [BYTE; 16usize],
  pub ByteWriteCount: [BYTE; 16usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1)
    )
  );
}
impl _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1 {
  #[inline]
  pub fn Shared(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Shared(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Shared: DWORD,
    Reserved: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Shared: u32 = unsafe { ::std::mem::transmute(Shared) };
      Shared as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__STORAGE_HW_ENDURANCE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_ENDURANCE_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_ENDURANCE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_ENDURANCE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_ENDURANCE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).ValidFields as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(ValidFields)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).GroupId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(GroupId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).LifePercentage as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(LifePercentage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).BytesReadCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(BytesReadCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).ByteWriteCount as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(ByteWriteCount)
    )
  );
}
pub type STORAGE_HW_ENDURANCE_INFO = _STORAGE_HW_ENDURANCE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
}
#[test]
fn bindgen_test_layout__STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>())).EnduranceInfo as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR),
      "::",
      stringify!(EnduranceInfo)
    )
  );
}
pub type STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_TOKEN {
  pub TokenType: [BYTE; 4usize],
  pub Reserved: [BYTE; 2usize],
  pub TokenIdLength: [BYTE; 2usize],
  pub __bindgen_anon_1: _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1 {
  pub StorageOffloadZeroDataToken: _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1,
  pub Token: [BYTE; 504usize],
  _bindgen_union_align: [u8; 504usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1 {
  pub Reserved2: [BYTE; 504usize],
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1>(),
    504usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1>())).Reserved2
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Reserved2)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_TOKEN__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>(),
    504usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>())).StorageOffloadZeroDataToken
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1),
      "::",
      stringify!(StorageOffloadZeroDataToken)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>())).Token as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1),
      "::",
      stringify!(Token)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_TOKEN() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_TOKEN>(),
    512usize,
    concat!("Size of: ", stringify!(_STORAGE_OFFLOAD_TOKEN))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_TOKEN>(),
    1usize,
    concat!("Alignment of ", stringify!(_STORAGE_OFFLOAD_TOKEN))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN>())).TokenType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN),
      "::",
      stringify!(TokenType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN>())).TokenIdLength as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN),
      "::",
      stringify!(TokenIdLength)
    )
  );
}
pub type STORAGE_OFFLOAD_TOKEN = _STORAGE_OFFLOAD_TOKEN;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_READ_OUTPUT {
  pub OffloadReadFlags: DWORD,
  pub Reserved: DWORD,
  pub LengthProtected: DWORDLONG,
  pub TokenLength: DWORD,
  pub Token: STORAGE_OFFLOAD_TOKEN,
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_READ_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_READ_OUTPUT>(),
    536usize,
    concat!("Size of: ", stringify!(_STORAGE_OFFLOAD_READ_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_READ_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_OFFLOAD_READ_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).OffloadReadFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(OffloadReadFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).Reserved as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).LengthProtected as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(LengthProtected)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).TokenLength as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(TokenLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).Token as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(Token)
    )
  );
}
pub type STORAGE_OFFLOAD_READ_OUTPUT = _STORAGE_OFFLOAD_READ_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OFFLOAD_WRITE_OUTPUT {
  pub OffloadWriteFlags: DWORD,
  pub Reserved: DWORD,
  pub LengthCopied: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_WRITE_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_WRITE_OUTPUT>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_WRITE_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_WRITE_OUTPUT>())).OffloadWriteFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT),
      "::",
      stringify!(OffloadWriteFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_WRITE_OUTPUT>())).Reserved as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_WRITE_OUTPUT>())).LengthCopied as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT),
      "::",
      stringify!(LengthCopied)
    )
  );
}
pub type STORAGE_OFFLOAD_WRITE_OUTPUT = _STORAGE_OFFLOAD_WRITE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TIER_REGION {
  pub TierId: GUID,
  pub Offset: DWORDLONG,
  pub Length: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_TIER_REGION() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TIER_REGION>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_TIER_REGION))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TIER_REGION>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_TIER_REGION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER_REGION>())).TierId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER_REGION),
      "::",
      stringify!(TierId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER_REGION>())).Offset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER_REGION),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER_REGION>())).Length as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER_REGION),
      "::",
      stringify!(Length)
    )
  );
}
pub type STORAGE_TIER_REGION = _STORAGE_TIER_REGION;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeAndLengthMayDifferent:
  _STORAGE_ZONES_ATTRIBUTES = 0;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeSameLengthSame: _STORAGE_ZONES_ATTRIBUTES = 1;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeSameLastZoneLengthDifferent:
  _STORAGE_ZONES_ATTRIBUTES = 2;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeMayDifferentLengthSame:
  _STORAGE_ZONES_ATTRIBUTES = 3;
pub type _STORAGE_ZONES_ATTRIBUTES = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONES_ATTRIBUTES as STORAGE_ZONES_ATTRIBUTES;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionConventional: _STORAGE_ZONE_CONDITION = 0;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionEmpty: _STORAGE_ZONE_CONDITION = 1;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionImplicitlyOpened: _STORAGE_ZONE_CONDITION = 2;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionExplicitlyOpened: _STORAGE_ZONE_CONDITION = 3;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionClosed: _STORAGE_ZONE_CONDITION = 4;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionReadOnly: _STORAGE_ZONE_CONDITION = 13;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionFull: _STORAGE_ZONE_CONDITION = 14;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionOffline: _STORAGE_ZONE_CONDITION = 15;
pub type _STORAGE_ZONE_CONDITION = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONE_CONDITION as STORAGE_ZONE_CONDITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONE_DESCRIPTOR {
  pub Size: DWORD,
  pub ZoneType: STORAGE_ZONE_TYPES,
  pub ZoneCondition: STORAGE_ZONE_CONDITION,
  pub ResetWritePointerRecommend: BOOLEAN,
  pub Reserved0: [BYTE; 3usize],
  pub ZoneSize: DWORDLONG,
  pub WritePointerOffset: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_ZONE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONE_DESCRIPTOR>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_ZONE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONE_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_ZONE_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ZoneType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ZoneType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ZoneCondition as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ZoneCondition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ResetWritePointerRecommend as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ResetWritePointerRecommend)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).Reserved0 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ZoneSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ZoneSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).WritePointerOffset as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(WritePointerOffset)
    )
  );
}
pub type STORAGE_ZONE_DESCRIPTOR = _STORAGE_ZONE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_GET_BC_PROPERTIES_OUTPUT {
  pub MaximumRequestsPerPeriod: DWORD,
  pub MinimumPeriod: DWORD,
  pub MaximumRequestSize: DWORDLONG,
  pub EstimatedTimePerRequest: DWORD,
  pub NumOutStandingRequests: DWORD,
  pub RequestSize: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_GET_BC_PROPERTIES_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).MaximumRequestsPerPeriod
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(MaximumRequestsPerPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).MinimumPeriod as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(MinimumPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).MaximumRequestSize as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(MaximumRequestSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).EstimatedTimePerRequest
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(EstimatedTimePerRequest)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).NumOutStandingRequests
        as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(NumOutStandingRequests)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).RequestSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(RequestSize)
    )
  );
}
pub type STORAGE_GET_BC_PROPERTIES_OUTPUT = _STORAGE_GET_BC_PROPERTIES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ALLOCATE_BC_STREAM_INPUT {
  pub Version: DWORD,
  pub RequestsPerPeriod: DWORD,
  pub Period: DWORD,
  pub RetryFailures: BOOLEAN,
  pub Discardable: BOOLEAN,
  pub Reserved1: [BOOLEAN; 2usize],
  pub AccessType: DWORD,
  pub AccessMode: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ALLOCATE_BC_STREAM_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).RequestsPerPeriod as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(RequestsPerPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Period as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Period)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).RetryFailures as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(RetryFailures)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Discardable as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Discardable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Reserved1 as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).AccessType as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(AccessType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).AccessMode as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(AccessMode)
    )
  );
}
pub type STORAGE_ALLOCATE_BC_STREAM_INPUT = _STORAGE_ALLOCATE_BC_STREAM_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
  pub RequestSize: DWORDLONG,
  pub NumOutStandingRequests: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ALLOCATE_BC_STREAM_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>())).RequestSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT),
      "::",
      stringify!(RequestSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>())).NumOutStandingRequests
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT),
      "::",
      stringify!(NumOutStandingRequests)
    )
  );
}
pub type STORAGE_ALLOCATE_BC_STREAM_OUTPUT = _STORAGE_ALLOCATE_BC_STREAM_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PRIORITY_HINT_SUPPORT {
  pub SupportFlags: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_PRIORITY_HINT_SUPPORT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PRIORITY_HINT_SUPPORT>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_PRIORITY_HINT_SUPPORT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PRIORITY_HINT_SUPPORT>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PRIORITY_HINT_SUPPORT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PRIORITY_HINT_SUPPORT>())).SupportFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PRIORITY_HINT_SUPPORT),
      "::",
      stringify!(SupportFlags)
    )
  );
}
pub type STORAGE_PRIORITY_HINT_SUPPORT = _STORAGE_PRIORITY_HINT_SUPPORT;
pub const _STORAGE_DIAGNOSTIC_LEVEL_StorageDiagnosticLevelDefault: _STORAGE_DIAGNOSTIC_LEVEL = 0;
pub const _STORAGE_DIAGNOSTIC_LEVEL_StorageDiagnosticLevelMax: _STORAGE_DIAGNOSTIC_LEVEL = 1;
pub type _STORAGE_DIAGNOSTIC_LEVEL = ::std::os::raw::c_int;
pub use self::_STORAGE_DIAGNOSTIC_LEVEL as STORAGE_DIAGNOSTIC_LEVEL;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeUndefined:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 0;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypePort:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 1;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeMiniport:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 2;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeHbaFirmware:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 3;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeMax:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 4;
pub type _STORAGE_DIAGNOSTIC_TARGET_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_DIAGNOSTIC_TARGET_TYPE as STORAGE_DIAGNOSTIC_TARGET_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DIAGNOSTIC_REQUEST {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Reserved: DWORD,
  pub TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
  pub Level: STORAGE_DIAGNOSTIC_LEVEL,
}
#[test]
fn bindgen_test_layout__STORAGE_DIAGNOSTIC_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DIAGNOSTIC_REQUEST>(),
    20usize,
    concat!("Size of: ", stringify!(_STORAGE_DIAGNOSTIC_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DIAGNOSTIC_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DIAGNOSTIC_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Reserved as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).TargetType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(TargetType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Level as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Level)
    )
  );
}
pub type STORAGE_DIAGNOSTIC_REQUEST = _STORAGE_DIAGNOSTIC_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DIAGNOSTIC_DATA {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProviderId: GUID,
  pub BufferSize: DWORD,
  pub Reserved: DWORD,
  pub DiagnosticDataBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DIAGNOSTIC_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DIAGNOSTIC_DATA>(),
    36usize,
    concat!("Size of: ", stringify!(_STORAGE_DIAGNOSTIC_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DIAGNOSTIC_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DIAGNOSTIC_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).ProviderId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(ProviderId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).BufferSize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(BufferSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).Reserved as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).DiagnosticDataBuffer as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(DiagnosticDataBuffer)
    )
  );
}
pub type STORAGE_DIAGNOSTIC_DATA = _STORAGE_DIAGNOSTIC_DATA;
#[repr(C)]
#[derive(Debug)]
pub struct _STORAGE_MEDIA_SERIAL_NUMBER_DATA {
  pub Reserved: WORD,
  pub SerialNumberLength: WORD,
  pub SerialNumber: __IncompleteArrayField<BYTE>,
}
#[test]
fn bindgen_test_layout__STORAGE_MEDIA_SERIAL_NUMBER_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>())).Reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>())).SerialNumberLength as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA),
      "::",
      stringify!(SerialNumberLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>())).SerialNumber as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA),
      "::",
      stringify!(SerialNumber)
    )
  );
}
pub type STORAGE_MEDIA_SERIAL_NUMBER_DATA = _STORAGE_MEDIA_SERIAL_NUMBER_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_READ_CAPACITY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub BlockLength: DWORD,
  pub NumberOfBlocks: LARGE_INTEGER,
  pub DiskLength: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__STORAGE_READ_CAPACITY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_READ_CAPACITY>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_READ_CAPACITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_READ_CAPACITY>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_READ_CAPACITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).BlockLength as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(BlockLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).NumberOfBlocks as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(NumberOfBlocks)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).DiskLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(DiskLength)
    )
  );
}
pub type STORAGE_READ_CAPACITY = _STORAGE_READ_CAPACITY;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeUnknown: _WRITE_CACHE_TYPE = 0;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeNone: _WRITE_CACHE_TYPE = 1;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeWriteBack: _WRITE_CACHE_TYPE = 2;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeWriteThrough: _WRITE_CACHE_TYPE = 3;
pub type _WRITE_CACHE_TYPE = ::std::os::raw::c_int;
pub use self::_WRITE_CACHE_TYPE as WRITE_CACHE_TYPE;
pub const _WRITE_CACHE_ENABLE_WriteCacheEnableUnknown: _WRITE_CACHE_ENABLE = 0;
pub const _WRITE_CACHE_ENABLE_WriteCacheDisabled: _WRITE_CACHE_ENABLE = 1;
pub const _WRITE_CACHE_ENABLE_WriteCacheEnabled: _WRITE_CACHE_ENABLE = 2;
pub type _WRITE_CACHE_ENABLE = ::std::os::raw::c_int;
pub use self::_WRITE_CACHE_ENABLE as WRITE_CACHE_ENABLE;
pub const _WRITE_CACHE_CHANGE_WriteCacheChangeUnknown: _WRITE_CACHE_CHANGE = 0;
pub const _WRITE_CACHE_CHANGE_WriteCacheNotChangeable: _WRITE_CACHE_CHANGE = 1;
pub const _WRITE_CACHE_CHANGE_WriteCacheChangeable: _WRITE_CACHE_CHANGE = 2;
pub type _WRITE_CACHE_CHANGE = ::std::os::raw::c_int;
pub use self::_WRITE_CACHE_CHANGE as WRITE_CACHE_CHANGE;
pub const _WRITE_THROUGH_WriteThroughUnknown: _WRITE_THROUGH = 0;
pub const _WRITE_THROUGH_WriteThroughNotSupported: _WRITE_THROUGH = 1;
pub const _WRITE_THROUGH_WriteThroughSupported: _WRITE_THROUGH = 2;
pub type _WRITE_THROUGH = ::std::os::raw::c_int;
pub use self::_WRITE_THROUGH as WRITE_THROUGH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_WRITE_CACHE_PROPERTY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub WriteCacheType: WRITE_CACHE_TYPE,
  pub WriteCacheEnabled: WRITE_CACHE_ENABLE,
  pub WriteCacheChangeable: WRITE_CACHE_CHANGE,
  pub WriteThroughSupported: WRITE_THROUGH,
  pub FlushCacheSupported: BOOLEAN,
  pub UserDefinedPowerProtection: BOOLEAN,
  pub NVCacheEnabled: BOOLEAN,
}
#[test]
fn bindgen_test_layout__STORAGE_WRITE_CACHE_PROPERTY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_WRITE_CACHE_PROPERTY>(),
    28usize,
    concat!("Size of: ", stringify!(_STORAGE_WRITE_CACHE_PROPERTY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_WRITE_CACHE_PROPERTY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_WRITE_CACHE_PROPERTY))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteCacheType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteCacheType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteCacheEnabled as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteCacheEnabled)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteCacheChangeable as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteCacheChangeable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteThroughSupported as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteThroughSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).FlushCacheSupported as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(FlushCacheSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).UserDefinedPowerProtection
        as *const _ as usize
    },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(UserDefinedPowerProtection)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).NVCacheEnabled as *const _ as usize
    },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(NVCacheEnabled)
    )
  );
}
pub type STORAGE_WRITE_CACHE_PROPERTY = _STORAGE_WRITE_CACHE_PROPERTY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDLE_POWER {
  pub Version: DWORD,
  pub Size: DWORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
  pub D3IdleTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_IDLE_POWER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_IDLE_POWER>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_IDLE_POWER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_IDLE_POWER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_IDLE_POWER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWER>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWER),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWER>())).D3IdleTimeout as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWER),
      "::",
      stringify!(D3IdleTimeout)
    )
  );
}
impl _STORAGE_IDLE_POWER {
  #[inline]
  pub fn WakeCapableHint(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_WakeCapableHint(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn D3ColdSupported(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_D3ColdSupported(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    WakeCapableHint: DWORD,
    D3ColdSupported: DWORD,
    Reserved: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let WakeCapableHint: u32 = unsafe { ::std::mem::transmute(WakeCapableHint) };
      WakeCapableHint as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let D3ColdSupported: u32 = unsafe { ::std::mem::transmute(D3ColdSupported) };
      D3ColdSupported as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_IDLE_POWER = _STORAGE_IDLE_POWER;
pub const _STORAGE_POWERUP_REASON_TYPE_StoragePowerupUnknown: _STORAGE_POWERUP_REASON_TYPE = 0;
pub const _STORAGE_POWERUP_REASON_TYPE_StoragePowerupIO: _STORAGE_POWERUP_REASON_TYPE = 1;
pub const _STORAGE_POWERUP_REASON_TYPE_StoragePowerupDeviceAttention: _STORAGE_POWERUP_REASON_TYPE =
  2;
pub type _STORAGE_POWERUP_REASON_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_POWERUP_REASON_TYPE as STORAGE_POWERUP_REASON_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDLE_POWERUP_REASON {
  pub Version: DWORD,
  pub Size: DWORD,
  pub PowerupReason: STORAGE_POWERUP_REASON_TYPE,
}
#[test]
fn bindgen_test_layout__STORAGE_IDLE_POWERUP_REASON() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_IDLE_POWERUP_REASON>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_IDLE_POWERUP_REASON))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_IDLE_POWERUP_REASON>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_IDLE_POWERUP_REASON))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_IDLE_POWERUP_REASON>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWERUP_REASON),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWERUP_REASON>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWERUP_REASON),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_IDLE_POWERUP_REASON>())).PowerupReason as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWERUP_REASON),
      "::",
      stringify!(PowerupReason)
    )
  );
}
pub type STORAGE_IDLE_POWERUP_REASON = _STORAGE_IDLE_POWERUP_REASON;
pub const _STORAGE_DEVICE_POWER_CAP_UNITS_StorageDevicePowerCapUnitsPercent:
  _STORAGE_DEVICE_POWER_CAP_UNITS = 0;
pub const _STORAGE_DEVICE_POWER_CAP_UNITS_StorageDevicePowerCapUnitsMilliwatts:
  _STORAGE_DEVICE_POWER_CAP_UNITS = 1;
pub type _STORAGE_DEVICE_POWER_CAP_UNITS = ::std::os::raw::c_int;
pub use self::_STORAGE_DEVICE_POWER_CAP_UNITS as STORAGE_DEVICE_POWER_CAP_UNITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_POWER_CAP {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Units: STORAGE_DEVICE_POWER_CAP_UNITS,
  pub MaxPower: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_POWER_CAP() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_POWER_CAP>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_POWER_CAP))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_POWER_CAP>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_POWER_CAP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).Units as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(Units)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).MaxPower as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(MaxPower)
    )
  );
}
pub type STORAGE_DEVICE_POWER_CAP = _STORAGE_DEVICE_POWER_CAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_RPMB_DATA_FRAME {
  pub Stuff: [BYTE; 196usize],
  pub KeyOrMAC: [BYTE; 32usize],
  pub Data: [BYTE; 256usize],
  pub Nonce: [BYTE; 16usize],
  pub WriteCounter: [BYTE; 4usize],
  pub Address: [BYTE; 2usize],
  pub BlockCount: [BYTE; 2usize],
  pub OperationResult: [BYTE; 2usize],
  pub RequestOrResponseType: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout__STORAGE_RPMB_DATA_FRAME() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_RPMB_DATA_FRAME>(),
    512usize,
    concat!("Size of: ", stringify!(_STORAGE_RPMB_DATA_FRAME))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_RPMB_DATA_FRAME>(),
    1usize,
    concat!("Alignment of ", stringify!(_STORAGE_RPMB_DATA_FRAME))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Stuff as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Stuff)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).KeyOrMAC as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(KeyOrMAC)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Data as *const _ as usize },
    228usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Nonce as *const _ as usize },
    484usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Nonce)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).WriteCounter as *const _ as usize
    },
    500usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(WriteCounter)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Address as *const _ as usize },
    504usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Address)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).BlockCount as *const _ as usize },
    506usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(BlockCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).OperationResult as *const _ as usize
    },
    508usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(OperationResult)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).RequestOrResponseType as *const _
        as usize
    },
    510usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(RequestOrResponseType)
    )
  );
}
pub type STORAGE_RPMB_DATA_FRAME = _STORAGE_RPMB_DATA_FRAME;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbProgramAuthKey: _STORAGE_RPMB_COMMAND_TYPE = 1;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbQueryWriteCounter: _STORAGE_RPMB_COMMAND_TYPE = 2;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedWrite: _STORAGE_RPMB_COMMAND_TYPE = 3;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedRead: _STORAGE_RPMB_COMMAND_TYPE = 4;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbReadResultRequest: _STORAGE_RPMB_COMMAND_TYPE = 5;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedDeviceConfigWrite:
  _STORAGE_RPMB_COMMAND_TYPE = 6;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedDeviceConfigRead:
  _STORAGE_RPMB_COMMAND_TYPE = 7;
pub type _STORAGE_RPMB_COMMAND_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_RPMB_COMMAND_TYPE as STORAGE_RPMB_COMMAND_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_EVENT_NOTIFICATION {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Events: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_EVENT_NOTIFICATION() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_EVENT_NOTIFICATION>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_EVENT_NOTIFICATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_EVENT_NOTIFICATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_EVENT_NOTIFICATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_EVENT_NOTIFICATION>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_EVENT_NOTIFICATION),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_EVENT_NOTIFICATION>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_EVENT_NOTIFICATION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_EVENT_NOTIFICATION>())).Events as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_EVENT_NOTIFICATION),
      "::",
      stringify!(Events)
    )
  );
}
pub type STORAGE_EVENT_NOTIFICATION = _STORAGE_EVENT_NOTIFICATION;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeUnknown: _STORAGE_COUNTER_TYPE = 0;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeTemperatureCelsius: _STORAGE_COUNTER_TYPE = 1;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeTemperatureCelsiusMax: _STORAGE_COUNTER_TYPE = 2;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadErrorsTotal: _STORAGE_COUNTER_TYPE = 3;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadErrorsCorrected: _STORAGE_COUNTER_TYPE = 4;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadErrorsUncorrected: _STORAGE_COUNTER_TYPE = 5;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteErrorsTotal: _STORAGE_COUNTER_TYPE = 6;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteErrorsCorrected: _STORAGE_COUNTER_TYPE = 7;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteErrorsUncorrected: _STORAGE_COUNTER_TYPE = 8;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeManufactureDate: _STORAGE_COUNTER_TYPE = 9;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeStartStopCycleCount: _STORAGE_COUNTER_TYPE = 10;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeStartStopCycleCountMax: _STORAGE_COUNTER_TYPE =
  11;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeLoadUnloadCycleCount: _STORAGE_COUNTER_TYPE = 12;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeLoadUnloadCycleCountMax: _STORAGE_COUNTER_TYPE =
  13;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWearPercentage: _STORAGE_COUNTER_TYPE = 14;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWearPercentageWarning: _STORAGE_COUNTER_TYPE = 15;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWearPercentageMax: _STORAGE_COUNTER_TYPE = 16;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypePowerOnHours: _STORAGE_COUNTER_TYPE = 17;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadLatency100NSMax: _STORAGE_COUNTER_TYPE = 18;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteLatency100NSMax: _STORAGE_COUNTER_TYPE = 19;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeFlushLatency100NSMax: _STORAGE_COUNTER_TYPE = 20;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeMax: _STORAGE_COUNTER_TYPE = 21;
pub type _STORAGE_COUNTER_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_COUNTER_TYPE as STORAGE_COUNTER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_COUNTER {
  pub Type: STORAGE_COUNTER_TYPE,
  pub Value: _STORAGE_COUNTER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_COUNTER__bindgen_ty_1 {
  pub ManufactureDate: _STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1,
  pub AsUlonglong: DWORDLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1 {
  pub Week: DWORD,
  pub Year: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>())).Week as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Week)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>())).Year as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Year)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_STORAGE_COUNTER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_COUNTER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1>())).ManufactureDate as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1),
      "::",
      stringify!(ManufactureDate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1>())).AsUlonglong as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1),
      "::",
      stringify!(AsUlonglong)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTER>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_COUNTER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTER>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_COUNTER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTER>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTER>())).Value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER),
      "::",
      stringify!(Value)
    )
  );
}
pub type STORAGE_COUNTER = _STORAGE_COUNTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_COUNTERS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfCounters: DWORD,
  pub Counters: [STORAGE_COUNTER; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTERS() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTERS>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_COUNTERS))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTERS>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_COUNTERS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).NumberOfCounters as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(NumberOfCounters)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).Counters as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(Counters)
    )
  );
}
pub type STORAGE_COUNTERS = _STORAGE_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_INFO_QUERY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_INFO_QUERY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_INFO_QUERY>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_INFO_QUERY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Reserved as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_INFO_QUERY = _STORAGE_HW_FIRMWARE_INFO_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_SLOT_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SlotNumber: BYTE,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved1: [BYTE; 6usize],
  pub Revision: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_SLOT_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_SLOT_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_SLOT_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).SlotNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(SlotNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Reserved1 as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Revision as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Revision)
    )
  );
}
impl _STORAGE_HW_FIRMWARE_SLOT_INFO {
  #[inline]
  pub fn ReadOnly(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_ReadOnly(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    ReadOnly: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let ReadOnly: u8 = unsafe { ::std::mem::transmute(ReadOnly) };
      ReadOnly as u64
    });
    __bindgen_bitfield_unit.set(1usize, 7u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_HW_FIRMWARE_SLOT_INFO = _STORAGE_HW_FIRMWARE_SLOT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub SlotCount: BYTE,
  pub ActiveSlot: BYTE,
  pub PendingActivateSlot: BYTE,
  pub FirmwareShared: BOOLEAN,
  pub Reserved: [BYTE; 3usize],
  pub ImagePayloadAlignment: DWORD,
  pub ImagePayloadMaxSize: DWORD,
  pub Slot: [STORAGE_HW_FIRMWARE_SLOT_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_INFO>(),
    56usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).SlotCount as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(SlotCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).ActiveSlot as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(ActiveSlot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).PendingActivateSlot as *const _ as usize
    },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(PendingActivateSlot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).FirmwareShared as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(FirmwareShared)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Reserved as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).ImagePayloadAlignment as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(ImagePayloadAlignment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).ImagePayloadMaxSize as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(ImagePayloadMaxSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Slot as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Slot)
    )
  );
}
impl _STORAGE_HW_FIRMWARE_INFO {
  #[inline]
  pub fn SupportUpgrade(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_SupportUpgrade(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    SupportUpgrade: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let SupportUpgrade: u8 = unsafe { ::std::mem::transmute(SupportUpgrade) };
      SupportUpgrade as u64
    });
    __bindgen_bitfield_unit.set(1usize, 7u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_HW_FIRMWARE_INFO = _STORAGE_HW_FIRMWARE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_DOWNLOAD {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved: [BYTE; 3usize],
  pub Offset: DWORDLONG,
  pub BufferSize: DWORDLONG,
  pub ImageBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_DOWNLOAD() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Reserved as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Offset as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).BufferSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(BufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).ImageBuffer as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(ImageBuffer)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_DOWNLOAD = _STORAGE_HW_FIRMWARE_DOWNLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved: [BYTE; 3usize],
  pub Offset: DWORDLONG,
  pub BufferSize: DWORDLONG,
  pub ImageSize: DWORD,
  pub Reserved2: DWORD,
  pub ImageBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_DOWNLOAD_V2() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Slot as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Reserved as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Offset as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).BufferSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(BufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).ImageSize as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(ImageSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Reserved2 as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).ImageBuffer as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(ImageBuffer)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = _STORAGE_HW_FIRMWARE_DOWNLOAD_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_ACTIVATE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved0: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_ACTIVATE() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_ACTIVATE>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_ACTIVATE>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Reserved0 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Reserved0)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_ACTIVATE = _STORAGE_HW_FIRMWARE_ACTIVATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_COMMAND {
  pub Version: DWORD,
  pub Length: DWORD,
  pub ProtocolType: STORAGE_PROTOCOL_TYPE,
  pub Flags: DWORD,
  pub ReturnStatus: DWORD,
  pub ErrorCode: DWORD,
  pub CommandLength: DWORD,
  pub ErrorInfoLength: DWORD,
  pub DataToDeviceTransferLength: DWORD,
  pub DataFromDeviceTransferLength: DWORD,
  pub TimeOutValue: DWORD,
  pub ErrorInfoOffset: DWORD,
  pub DataToDeviceBufferOffset: DWORD,
  pub DataFromDeviceBufferOffset: DWORD,
  pub CommandSpecific: DWORD,
  pub Reserved0: DWORD,
  pub FixedProtocolReturnData: DWORD,
  pub Reserved1: [DWORD; 3usize],
  pub Command: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_COMMAND() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_COMMAND>(),
    84usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_COMMAND))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_COMMAND>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROTOCOL_COMMAND))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Length as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ProtocolType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ProtocolType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Flags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ReturnStatus as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ReturnStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ErrorCode as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ErrorCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).CommandLength as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(CommandLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ErrorInfoLength as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ErrorInfoLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataToDeviceTransferLength as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataToDeviceTransferLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataFromDeviceTransferLength as *const _
        as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataFromDeviceTransferLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).TimeOutValue as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(TimeOutValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ErrorInfoOffset as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ErrorInfoOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataToDeviceBufferOffset as *const _
        as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataToDeviceBufferOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataFromDeviceBufferOffset as *const _
        as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataFromDeviceBufferOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).CommandSpecific as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(CommandSpecific)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Reserved0 as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).FixedProtocolReturnData as *const _
        as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(FixedProtocolReturnData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Reserved1 as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Command as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Command)
    )
  );
}
pub type STORAGE_PROTOCOL_COMMAND = _STORAGE_PROTOCOL_COMMAND;
pub const _STORAGE_ATTRIBUTE_MGMT_ACTION_StorAttributeMgmt_ClearAttribute:
  _STORAGE_ATTRIBUTE_MGMT_ACTION = 0;
pub const _STORAGE_ATTRIBUTE_MGMT_ACTION_StorAttributeMgmt_SetAttribute:
  _STORAGE_ATTRIBUTE_MGMT_ACTION = 1;
pub const _STORAGE_ATTRIBUTE_MGMT_ACTION_StorAttributeMgmt_ResetAttribute:
  _STORAGE_ATTRIBUTE_MGMT_ACTION = 2;
pub type _STORAGE_ATTRIBUTE_MGMT_ACTION = ::std::os::raw::c_int;
pub use self::_STORAGE_ATTRIBUTE_MGMT_ACTION as STORAGE_ATTRIBUTE_MGMT_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ATTRIBUTE_MGMT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
  pub Attribute: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ATTRIBUTE_MGMT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ATTRIBUTE_MGMT>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_ATTRIBUTE_MGMT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ATTRIBUTE_MGMT>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_ATTRIBUTE_MGMT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Action as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Action)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Attribute as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Attribute)
    )
  );
}
pub type STORAGE_ATTRIBUTE_MGMT = _STORAGE_ATTRIBUTE_MGMT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_HEALTH_NOTIFICATION_DATA {
  pub DeviceGuid: GUID,
}
#[test]
fn bindgen_test_layout__SCM_PD_HEALTH_NOTIFICATION_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_HEALTH_NOTIFICATION_DATA>(),
    16usize,
    concat!("Size of: ", stringify!(_SCM_PD_HEALTH_NOTIFICATION_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_HEALTH_NOTIFICATION_DATA>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_HEALTH_NOTIFICATION_DATA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_HEALTH_NOTIFICATION_DATA>())).DeviceGuid as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_HEALTH_NOTIFICATION_DATA),
      "::",
      stringify!(DeviceGuid)
    )
  );
}
pub type SCM_PD_HEALTH_NOTIFICATION_DATA = _SCM_PD_HEALTH_NOTIFICATION_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_LOGICAL_DEVICE_INSTANCE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceGuid: GUID,
  pub SymbolicLink: [WCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__SCM_LOGICAL_DEVICE_INSTANCE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_LOGICAL_DEVICE_INSTANCE>(),
    536usize,
    concat!("Size of: ", stringify!(_SCM_LOGICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_LOGICAL_DEVICE_INSTANCE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_LOGICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).DeviceGuid as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).SymbolicLink as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(SymbolicLink)
    )
  );
}
pub type SCM_LOGICAL_DEVICE_INSTANCE = _SCM_LOGICAL_DEVICE_INSTANCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_LOGICAL_DEVICES {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceCount: DWORD,
  pub Devices: [SCM_LOGICAL_DEVICE_INSTANCE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_LOGICAL_DEVICES() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_LOGICAL_DEVICES>(),
    548usize,
    concat!("Size of: ", stringify!(_SCM_LOGICAL_DEVICES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_LOGICAL_DEVICES>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_LOGICAL_DEVICES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).DeviceCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(DeviceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).Devices as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(Devices)
    )
  );
}
pub type SCM_LOGICAL_DEVICES = _SCM_LOGICAL_DEVICES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PHYSICAL_DEVICE_INSTANCE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NfitHandle: DWORD,
  pub SymbolicLink: [WCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__SCM_PHYSICAL_DEVICE_INSTANCE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PHYSICAL_DEVICE_INSTANCE>(),
    524usize,
    concat!("Size of: ", stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PHYSICAL_DEVICE_INSTANCE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).NfitHandle as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(NfitHandle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).SymbolicLink as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(SymbolicLink)
    )
  );
}
pub type SCM_PHYSICAL_DEVICE_INSTANCE = _SCM_PHYSICAL_DEVICE_INSTANCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PHYSICAL_DEVICES {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceCount: DWORD,
  pub Devices: [SCM_PHYSICAL_DEVICE_INSTANCE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PHYSICAL_DEVICES() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PHYSICAL_DEVICES>(),
    536usize,
    concat!("Size of: ", stringify!(_SCM_PHYSICAL_DEVICES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PHYSICAL_DEVICES>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PHYSICAL_DEVICES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).DeviceCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(DeviceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).Devices as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(Devices)
    )
  );
}
pub type SCM_PHYSICAL_DEVICES = _SCM_PHYSICAL_DEVICES;
pub const _SCM_REGION_FLAG_ScmRegionFlagNone: _SCM_REGION_FLAG = 0;
pub const _SCM_REGION_FLAG_ScmRegionFlagLabel: _SCM_REGION_FLAG = 1;
pub type _SCM_REGION_FLAG = ::std::os::raw::c_int;
pub use self::_SCM_REGION_FLAG as SCM_REGION_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_REGION {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub NfitHandle: DWORD,
  pub LogicalDeviceGuid: GUID,
  pub AddressRangeType: GUID,
  pub AssociatedId: DWORD,
  pub Length: DWORD64,
  pub StartingDPA: DWORD64,
  pub BaseSPA: DWORD64,
  pub SPAOffset: DWORD64,
  pub RegionOffset: DWORD64,
}
#[test]
fn bindgen_test_layout__SCM_REGION() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_REGION>(),
    96usize,
    concat!("Size of: ", stringify!(_SCM_REGION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_REGION>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_REGION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).NfitHandle as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(NfitHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).LogicalDeviceGuid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(LogicalDeviceGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).AddressRangeType as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(AddressRangeType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).AssociatedId as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(AssociatedId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Length as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).StartingDPA as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(StartingDPA)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).BaseSPA as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(BaseSPA)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).SPAOffset as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(SPAOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).RegionOffset as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(RegionOffset)
    )
  );
}
pub type SCM_REGION = _SCM_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_REGIONS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub RegionCount: DWORD,
  pub Regions: [SCM_REGION; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_REGIONS() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_REGIONS>(),
    112usize,
    concat!("Size of: ", stringify!(_SCM_REGIONS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_REGIONS>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_REGIONS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).RegionCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(RegionCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).Regions as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(Regions)
    )
  );
}
pub type SCM_REGIONS = _SCM_REGIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_INTERLEAVED_PD_INFO {
  pub DeviceHandle: DWORD,
  pub DeviceGuid: GUID,
}
#[test]
fn bindgen_test_layout__SCM_INTERLEAVED_PD_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_INTERLEAVED_PD_INFO>(),
    20usize,
    concat!("Size of: ", stringify!(_SCM_INTERLEAVED_PD_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_INTERLEAVED_PD_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_INTERLEAVED_PD_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_INTERLEAVED_PD_INFO>())).DeviceHandle as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_INTERLEAVED_PD_INFO),
      "::",
      stringify!(DeviceHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_INTERLEAVED_PD_INFO>())).DeviceGuid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_INTERLEAVED_PD_INFO),
      "::",
      stringify!(DeviceGuid)
    )
  );
}
pub type SCM_INTERLEAVED_PD_INFO = _SCM_INTERLEAVED_PD_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_LD_INTERLEAVE_SET_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub InterleaveSetSize: DWORD,
  pub InterleaveSet: [SCM_INTERLEAVED_PD_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_LD_INTERLEAVE_SET_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_LD_INTERLEAVE_SET_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_LD_INTERLEAVE_SET_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_LD_INTERLEAVE_SET_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_LD_INTERLEAVE_SET_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).InterleaveSetSize as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(InterleaveSetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).InterleaveSet as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(InterleaveSet)
    )
  );
}
pub type SCM_LD_INTERLEAVE_SET_INFO = _SCM_LD_INTERLEAVE_SET_INFO;
pub const _SCM_PD_QUERY_TYPE_ScmPhysicalDeviceQuery_Descriptor: _SCM_PD_QUERY_TYPE = 0;
pub const _SCM_PD_QUERY_TYPE_ScmPhysicalDeviceQuery_IsSupported: _SCM_PD_QUERY_TYPE = 1;
pub const _SCM_PD_QUERY_TYPE_ScmPhysicalDeviceQuery_Max: _SCM_PD_QUERY_TYPE = 2;
pub type _SCM_PD_QUERY_TYPE = ::std::os::raw::c_int;
pub use self::_SCM_PD_QUERY_TYPE as SCM_PD_QUERY_TYPE;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_DeviceInfo: _SCM_PD_PROPERTY_ID = 0;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_ManagementStatus: _SCM_PD_PROPERTY_ID = 1;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_FirmwareInfo: _SCM_PD_PROPERTY_ID = 2;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_LocationString: _SCM_PD_PROPERTY_ID = 3;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_DeviceSpecificInfo: _SCM_PD_PROPERTY_ID = 4;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_DeviceHandle: _SCM_PD_PROPERTY_ID = 5;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_Max: _SCM_PD_PROPERTY_ID = 6;
pub type _SCM_PD_PROPERTY_ID = ::std::os::raw::c_int;
pub use self::_SCM_PD_PROPERTY_ID as SCM_PD_PROPERTY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PROPERTY_QUERY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub PropertyId: SCM_PD_PROPERTY_ID,
  pub QueryType: SCM_PD_QUERY_TYPE,
  pub AdditionalParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PROPERTY_QUERY() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PROPERTY_QUERY>(),
    20usize,
    concat!("Size of: ", stringify!(_SCM_PD_PROPERTY_QUERY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PROPERTY_QUERY>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_PROPERTY_QUERY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).PropertyId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(PropertyId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).QueryType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(QueryType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).AdditionalParameters as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(AdditionalParameters)
    )
  );
}
pub type SCM_PD_PROPERTY_QUERY = _SCM_PD_PROPERTY_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DESCRIPTOR_HEADER {
  pub Version: DWORD,
  pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__SCM_PD_DESCRIPTOR_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DESCRIPTOR_HEADER>(),
    8usize,
    concat!("Size of: ", stringify!(_SCM_PD_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DESCRIPTOR_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DESCRIPTOR_HEADER>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DESCRIPTOR_HEADER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DESCRIPTOR_HEADER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DESCRIPTOR_HEADER),
      "::",
      stringify!(Size)
    )
  );
}
pub type SCM_PD_DESCRIPTOR_HEADER = _SCM_PD_DESCRIPTOR_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_HANDLE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceGuid: GUID,
  pub DeviceHandle: DWORD,
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_HANDLE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_HANDLE>(),
    28usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_HANDLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_HANDLE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DEVICE_HANDLE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).DeviceGuid as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).DeviceHandle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(DeviceHandle)
    )
  );
}
pub type SCM_PD_DEVICE_HANDLE = _SCM_PD_DEVICE_HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceGuid: GUID,
  pub UnsafeShutdownCount: DWORD,
  pub PersistentMemorySizeInBytes: DWORD64,
  pub VolatileMemorySizeInBytes: DWORD64,
  pub TotalMemorySizeInBytes: DWORD64,
  pub SlotNumber: DWORD,
  pub DeviceHandle: DWORD,
  pub PhysicalId: WORD,
  pub NumberOfFormatInterfaceCodes: BYTE,
  pub FormatInterfaceCodes: [WORD; 8usize],
  pub VendorId: DWORD,
  pub ProductId: DWORD,
  pub SubsystemDeviceId: DWORD,
  pub SubsystemVendorId: DWORD,
  pub ManufacturingLocation: BYTE,
  pub ManufacturingWeek: BYTE,
  pub ManufacturingYear: BYTE,
  pub SerialNumber4Byte: DWORD,
  pub SerialNumberLengthInChars: DWORD,
  pub SerialNumber: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_INFO>(),
    120usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DEVICE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).DeviceGuid as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).UnsafeShutdownCount as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(UnsafeShutdownCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).PersistentMemorySizeInBytes as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(PersistentMemorySizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).VolatileMemorySizeInBytes as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(VolatileMemorySizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).TotalMemorySizeInBytes as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(TotalMemorySizeInBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SlotNumber as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SlotNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).DeviceHandle as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(DeviceHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).PhysicalId as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(PhysicalId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).NumberOfFormatInterfaceCodes as *const _
        as usize
    },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(NumberOfFormatInterfaceCodes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).FormatInterfaceCodes as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(FormatInterfaceCodes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).VendorId as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(VendorId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ProductId as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ProductId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SubsystemDeviceId as *const _ as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SubsystemDeviceId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SubsystemVendorId as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SubsystemVendorId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ManufacturingLocation as *const _ as usize
    },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ManufacturingLocation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ManufacturingWeek as *const _ as usize
    },
    101usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ManufacturingWeek)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ManufacturingYear as *const _ as usize
    },
    102usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ManufacturingYear)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SerialNumber4Byte as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SerialNumber4Byte)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SerialNumberLengthInChars as *const _ as usize
    },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SerialNumberLengthInChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SerialNumber as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SerialNumber)
    )
  );
}
pub type SCM_PD_DEVICE_INFO = _SCM_PD_DEVICE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PD_DEVICE_SPECIFIC_PROPERTY {
  pub Name: [WCHAR; 128usize],
  pub Value: LONGLONG,
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_SPECIFIC_PROPERTY() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>(),
    264usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>())).Name as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY),
      "::",
      stringify!(Name)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>())).Value as *const _ as usize
    },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY),
      "::",
      stringify!(Value)
    )
  );
}
pub type SCM_PD_DEVICE_SPECIFIC_PROPERTY = _SCM_PD_DEVICE_SPECIFIC_PROPERTY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PD_DEVICE_SPECIFIC_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfProperties: DWORD,
  pub DeviceSpecificProperties: [SCM_PD_DEVICE_SPECIFIC_PROPERTY; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_SPECIFIC_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_SPECIFIC_INFO>(),
    280usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_SPECIFIC_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).NumberOfProperties as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(NumberOfProperties)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).DeviceSpecificProperties as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(DeviceSpecificProperties)
    )
  );
}
pub type SCM_PD_DEVICE_SPECIFIC_INFO = _SCM_PD_DEVICE_SPECIFIC_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_SLOT_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SlotNumber: BYTE,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved1: [BYTE; 6usize],
  pub Revision: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_SLOT_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_SLOT_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_SLOT_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).SlotNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(SlotNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Reserved1 as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Revision as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Revision)
    )
  );
}
impl _SCM_PD_FIRMWARE_SLOT_INFO {
  #[inline]
  pub fn ReadOnly(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_ReadOnly(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    ReadOnly: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let ReadOnly: u8 = unsafe { ::std::mem::transmute(ReadOnly) };
      ReadOnly as u64
    });
    __bindgen_bitfield_unit.set(1usize, 7u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type SCM_PD_FIRMWARE_SLOT_INFO = _SCM_PD_FIRMWARE_SLOT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ActiveSlot: BYTE,
  pub NextActiveSlot: BYTE,
  pub SlotCount: BYTE,
  pub Slots: [SCM_PD_FIRMWARE_SLOT_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_INFO>(),
    60usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).ActiveSlot as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(ActiveSlot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).NextActiveSlot as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(NextActiveSlot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).SlotCount as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(SlotCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).Slots as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(Slots)
    )
  );
}
pub type SCM_PD_FIRMWARE_INFO = _SCM_PD_FIRMWARE_INFO;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Unknown: _SCM_PD_HEALTH_STATUS = 0;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Unhealthy: _SCM_PD_HEALTH_STATUS = 1;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Warning: _SCM_PD_HEALTH_STATUS = 2;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Healthy: _SCM_PD_HEALTH_STATUS = 3;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Max: _SCM_PD_HEALTH_STATUS = 4;
pub type _SCM_PD_HEALTH_STATUS = ::std::os::raw::c_int;
pub use self::_SCM_PD_HEALTH_STATUS as SCM_PD_HEALTH_STATUS;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Unknown: _SCM_PD_OPERATIONAL_STATUS =
  0;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Ok: _SCM_PD_OPERATIONAL_STATUS = 1;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_PredictingFailure:
  _SCM_PD_OPERATIONAL_STATUS = 2;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_InService:
  _SCM_PD_OPERATIONAL_STATUS = 3;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_HardwareError:
  _SCM_PD_OPERATIONAL_STATUS = 4;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_NotUsable:
  _SCM_PD_OPERATIONAL_STATUS = 5;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_TransientError:
  _SCM_PD_OPERATIONAL_STATUS = 6;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Missing: _SCM_PD_OPERATIONAL_STATUS =
  7;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Max: _SCM_PD_OPERATIONAL_STATUS = 8;
pub type _SCM_PD_OPERATIONAL_STATUS = ::std::os::raw::c_int;
pub use self::_SCM_PD_OPERATIONAL_STATUS as SCM_PD_OPERATIONAL_STATUS;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Unknown:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 0;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Media:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 1;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_ThresholdExceeded:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 2;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_LostData:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 3;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_EnergySource:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 4;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Configuration:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 5;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_DeviceController:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 6;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_MediaController:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 7;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Component:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 8;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_BackgroundOperation:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 9;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_InvalidFirmware:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 10;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_HealthCheck:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 11;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_LostDataPersistence:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 12;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_DisabledByPlatform:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 13;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_PermanentError:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 14;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_LostWritePersistence:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 15;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_FatalError:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 16;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_DataPersistenceLossImminent : _SCM_PD_OPERATIONAL_STATUS_REASON = 17 ;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_WritePersistenceLossImminent : _SCM_PD_OPERATIONAL_STATUS_REASON = 18 ;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 19;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_PerformanceDegradation:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 20;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_ExcessiveTemperature:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 21;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Max:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 22;
pub type _SCM_PD_OPERATIONAL_STATUS_REASON = ::std::os::raw::c_int;
pub use self::_SCM_PD_OPERATIONAL_STATUS_REASON as SCM_PD_OPERATIONAL_STATUS_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_MANAGEMENT_STATUS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Health: SCM_PD_HEALTH_STATUS,
  pub NumberOfOperationalStatus: DWORD,
  pub NumberOfAdditionalReasons: DWORD,
  pub OperationalStatus: [SCM_PD_OPERATIONAL_STATUS; 16usize],
  pub AdditionalReasons: [SCM_PD_OPERATIONAL_STATUS_REASON; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_MANAGEMENT_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_MANAGEMENT_STATUS>(),
    88usize,
    concat!("Size of: ", stringify!(_SCM_PD_MANAGEMENT_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_MANAGEMENT_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_MANAGEMENT_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).Health as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(Health)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).NumberOfOperationalStatus as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfOperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).NumberOfAdditionalReasons as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfAdditionalReasons)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).OperationalStatus as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(OperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).AdditionalReasons as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(AdditionalReasons)
    )
  );
}
pub type SCM_PD_MANAGEMENT_STATUS = _SCM_PD_MANAGEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_LOCATION_STRING {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Location: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_LOCATION_STRING() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_LOCATION_STRING>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_LOCATION_STRING))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_LOCATION_STRING>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_LOCATION_STRING))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_LOCATION_STRING>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_LOCATION_STRING),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_LOCATION_STRING>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_LOCATION_STRING),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_LOCATION_STRING>())).Location as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_LOCATION_STRING),
      "::",
      stringify!(Location)
    )
  );
}
pub type SCM_PD_LOCATION_STRING = _SCM_PD_LOCATION_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_DOWNLOAD {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved: [BYTE; 3usize],
  pub Offset: DWORD64,
  pub FirmwareImageSizeInBytes: DWORD,
  pub FirmwareImage: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_DOWNLOAD() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_DOWNLOAD>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_DOWNLOAD>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Reserved as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Offset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).FirmwareImageSizeInBytes as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(FirmwareImageSizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).FirmwareImage as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(FirmwareImage)
    )
  );
}
pub type SCM_PD_FIRMWARE_DOWNLOAD = _SCM_PD_FIRMWARE_DOWNLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_ACTIVATE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_ACTIVATE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_ACTIVATE>(),
    16usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_ACTIVATE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Slot)
    )
  );
}
pub type SCM_PD_FIRMWARE_ACTIVATE = _SCM_PD_FIRMWARE_ACTIVATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolGuid: GUID,
  pub DataSize: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_INPUT>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_PASSTHROUGH_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).ProtocolGuid as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(ProtocolGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).DataSize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(DataSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(Data)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_INPUT = _SCM_PD_PASSTHROUGH_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_OUTPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolGuid: GUID,
  pub DataSize: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_OUTPUT>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_OUTPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_PASSTHROUGH_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).ProtocolGuid as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(ProtocolGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).DataSize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(DataSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(Data)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_OUTPUT = _SCM_PD_PASSTHROUGH_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
  pub Opcode: DWORD,
  pub OpcodeParametersLength: DWORD,
  pub OpcodeParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_INVDIMM_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>())).Opcode as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT),
      "::",
      stringify!(Opcode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>())).OpcodeParametersLength
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT),
      "::",
      stringify!(OpcodeParametersLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>())).OpcodeParameters as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT),
      "::",
      stringify!(OpcodeParameters)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_INVDIMM_INPUT = _SCM_PD_PASSTHROUGH_INVDIMM_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
  pub GeneralStatus: WORD,
  pub ExtendedStatus: WORD,
  pub OutputDataLength: DWORD,
  pub OutputData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).GeneralStatus as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(GeneralStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).ExtendedStatus as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(ExtendedStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).OutputDataLength as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(OutputDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).OutputData as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(OutputData)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_INPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Options: _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1)
    )
  );
}
impl _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1 {
  #[inline]
  pub fn Overwrite(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Overwrite(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(Overwrite: DWORD) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Overwrite: u32 = unsafe { ::std::mem::transmute(Overwrite) };
      Overwrite as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SCM_PD_REINITIALIZE_MEDIA_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>())).Options as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT),
      "::",
      stringify!(Options)
    )
  );
}
pub type SCM_PD_REINITIALIZE_MEDIA_INPUT = _SCM_PD_REINITIALIZE_MEDIA_INPUT;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_Success:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 0;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_RebootNeeded:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 1;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_ColdBootNeeded:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 2;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_Max:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 3;
pub type _SCM_PD_MEDIA_REINITIALIZATION_STATUS = ::std::os::raw::c_int;
pub use self::_SCM_PD_MEDIA_REINITIALIZATION_STATUS as SCM_PD_MEDIA_REINITIALIZATION_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
}
#[test]
fn bindgen_test_layout__SCM_PD_REINITIALIZE_MEDIA_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>())).Status as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT),
      "::",
      stringify!(Status)
    )
  );
}
pub type SCM_PD_REINITIALIZE_MEDIA_OUTPUT = _SCM_PD_REINITIALIZE_MEDIA_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_PARTITION_INFORMATION {
  pub PartitionType: BYTE,
}
#[test]
fn bindgen_test_layout__SET_PARTITION_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PARTITION_INFORMATION>(),
    1usize,
    concat!("Size of: ", stringify!(_SET_PARTITION_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PARTITION_INFORMATION>(),
    1usize,
    concat!("Alignment of ", stringify!(_SET_PARTITION_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION>())).PartitionType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION),
      "::",
      stringify!(PartitionType)
    )
  );
}
pub type SET_PARTITION_INFORMATION = _SET_PARTITION_INFORMATION;
pub const _PARTITION_STYLE_PARTITION_STYLE_MBR: _PARTITION_STYLE = 0;
pub const _PARTITION_STYLE_PARTITION_STYLE_GPT: _PARTITION_STYLE = 1;
pub const _PARTITION_STYLE_PARTITION_STYLE_RAW: _PARTITION_STYLE = 2;
pub type _PARTITION_STYLE = ::std::os::raw::c_int;
pub use self::_PARTITION_STYLE as PARTITION_STYLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PARTITION_INFORMATION_GPT {
  pub PartitionType: GUID,
  pub PartitionId: GUID,
  pub Attributes: DWORD64,
  pub Name: [WCHAR; 36usize],
}
#[test]
fn bindgen_test_layout__PARTITION_INFORMATION_GPT() {
  assert_eq!(
    ::std::mem::size_of::<_PARTITION_INFORMATION_GPT>(),
    112usize,
    concat!("Size of: ", stringify!(_PARTITION_INFORMATION_GPT))
  );
  assert_eq!(
    ::std::mem::align_of::<_PARTITION_INFORMATION_GPT>(),
    8usize,
    concat!("Alignment of ", stringify!(_PARTITION_INFORMATION_GPT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).PartitionType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(PartitionType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).PartitionId as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(PartitionId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).Attributes as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(Attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).Name as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(Name)
    )
  );
}
pub type PARTITION_INFORMATION_GPT = _PARTITION_INFORMATION_GPT;
pub type SET_PARTITION_INFORMATION_MBR = SET_PARTITION_INFORMATION;
pub type SET_PARTITION_INFORMATION_GPT = PARTITION_INFORMATION_GPT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SET_PARTITION_INFORMATION_EX {
  pub PartitionStyle: PARTITION_STYLE,
  pub __bindgen_anon_1: _SET_PARTITION_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SET_PARTITION_INFORMATION_EX__bindgen_ty_1 {
  pub Mbr: SET_PARTITION_INFORMATION_MBR,
  pub Gpt: SET_PARTITION_INFORMATION_GPT,
  _bindgen_union_align: [u64; 14usize],
}
#[test]
fn bindgen_test_layout__SET_PARTITION_INFORMATION_EX__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>(),
    112usize,
    concat!(
      "Size of: ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>())).Mbr as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Mbr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>())).Gpt as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Gpt)
    )
  );
}
#[test]
fn bindgen_test_layout__SET_PARTITION_INFORMATION_EX() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PARTITION_INFORMATION_EX>(),
    120usize,
    concat!("Size of: ", stringify!(_SET_PARTITION_INFORMATION_EX))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PARTITION_INFORMATION_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(_SET_PARTITION_INFORMATION_EX))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION_EX>())).PartitionStyle as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION_EX),
      "::",
      stringify!(PartitionStyle)
    )
  );
}
pub type SET_PARTITION_INFORMATION_EX = _SET_PARTITION_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IDEREGS {
  pub bFeaturesReg: BYTE,
  pub bSectorCountReg: BYTE,
  pub bSectorNumberReg: BYTE,
  pub bCylLowReg: BYTE,
  pub bCylHighReg: BYTE,
  pub bDriveHeadReg: BYTE,
  pub bCommandReg: BYTE,
  pub bReserved: BYTE,
}
#[test]
fn bindgen_test_layout__IDEREGS() {
  assert_eq!(
    ::std::mem::size_of::<_IDEREGS>(),
    8usize,
    concat!("Size of: ", stringify!(_IDEREGS))
  );
  assert_eq!(
    ::std::mem::align_of::<_IDEREGS>(),
    1usize,
    concat!("Alignment of ", stringify!(_IDEREGS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bFeaturesReg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bFeaturesReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bSectorCountReg as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bSectorCountReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bSectorNumberReg as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bSectorNumberReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bCylLowReg as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bCylLowReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bCylHighReg as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bCylHighReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bDriveHeadReg as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bDriveHeadReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bCommandReg as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bCommandReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bReserved as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bReserved)
    )
  );
}
pub type IDEREGS = _IDEREGS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SENDCMDINPARAMS {
  pub cBufferSize: DWORD,
  pub irDriveRegs: IDEREGS,
  pub bDriveNumber: BYTE,
  pub bReserved: [BYTE; 3usize],
  pub dwReserved: [DWORD; 4usize],
  pub bBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SENDCMDINPARAMS() {
  assert_eq!(
    ::std::mem::size_of::<_SENDCMDINPARAMS>(),
    33usize,
    concat!("Size of: ", stringify!(_SENDCMDINPARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SENDCMDINPARAMS>(),
    1usize,
    concat!("Alignment of ", stringify!(_SENDCMDINPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).cBufferSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(cBufferSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).irDriveRegs as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(irDriveRegs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).bDriveNumber as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(bDriveNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).bReserved as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(bReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).dwReserved as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).bBuffer as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(bBuffer)
    )
  );
}
pub type SENDCMDINPARAMS = _SENDCMDINPARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVERSTATUS {
  pub bDriverError: BYTE,
  pub bIDEError: BYTE,
  pub bReserved: [BYTE; 2usize],
  pub dwReserved: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout__DRIVERSTATUS() {
  assert_eq!(
    ::std::mem::size_of::<_DRIVERSTATUS>(),
    12usize,
    concat!("Size of: ", stringify!(_DRIVERSTATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_DRIVERSTATUS>(),
    1usize,
    concat!("Alignment of ", stringify!(_DRIVERSTATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).bDriverError as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(bDriverError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).bIDEError as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(bIDEError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).bReserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(bReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).dwReserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(dwReserved)
    )
  );
}
pub type DRIVERSTATUS = _DRIVERSTATUS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SENDCMDOUTPARAMS {
  pub cBufferSize: DWORD,
  pub DriverStatus: DRIVERSTATUS,
  pub bBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SENDCMDOUTPARAMS() {
  assert_eq!(
    ::std::mem::size_of::<_SENDCMDOUTPARAMS>(),
    17usize,
    concat!("Size of: ", stringify!(_SENDCMDOUTPARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SENDCMDOUTPARAMS>(),
    1usize,
    concat!("Alignment of ", stringify!(_SENDCMDOUTPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDOUTPARAMS>())).cBufferSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDOUTPARAMS),
      "::",
      stringify!(cBufferSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDOUTPARAMS>())).DriverStatus as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDOUTPARAMS),
      "::",
      stringify!(DriverStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDOUTPARAMS>())).bBuffer as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDOUTPARAMS),
      "::",
      stringify!(bBuffer)
    )
  );
}
pub type SENDCMDOUTPARAMS = _SENDCMDOUTPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_DISK_ATTRIBUTES {
  pub Version: DWORD,
  pub Persist: BOOLEAN,
  pub Reserved1: [BYTE; 3usize],
  pub Attributes: DWORDLONG,
  pub AttributesMask: DWORDLONG,
  pub Reserved2: [DWORD; 4usize],
}
#[test]
fn bindgen_test_layout__SET_DISK_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_SET_DISK_ATTRIBUTES>(),
    40usize,
    concat!("Size of: ", stringify!(_SET_DISK_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_DISK_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SET_DISK_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Persist as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Persist)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Reserved1 as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).AttributesMask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(AttributesMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Reserved2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Reserved2)
    )
  );
}
pub type SET_DISK_ATTRIBUTES = _SET_DISK_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER {
  pub StartingLcn: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_STARTING_LCN_INPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<STARTING_LCN_INPUT_BUFFER>(),
    8usize,
    concat!("Size of: ", stringify!(STARTING_LCN_INPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<STARTING_LCN_INPUT_BUFFER>(),
    8usize,
    concat!("Alignment of ", stringify!(STARTING_LCN_INPUT_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STARTING_LCN_INPUT_BUFFER>())).StartingLcn as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_LCN_INPUT_BUFFER),
      "::",
      stringify!(StartingLcn)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER_EX {
  pub StartingLcn: LARGE_INTEGER,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout_STARTING_LCN_INPUT_BUFFER_EX() {
  assert_eq!(
    ::std::mem::size_of::<STARTING_LCN_INPUT_BUFFER_EX>(),
    16usize,
    concat!("Size of: ", stringify!(STARTING_LCN_INPUT_BUFFER_EX))
  );
  assert_eq!(
    ::std::mem::align_of::<STARTING_LCN_INPUT_BUFFER_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(STARTING_LCN_INPUT_BUFFER_EX))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STARTING_LCN_INPUT_BUFFER_EX>())).StartingLcn as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_LCN_INPUT_BUFFER_EX),
      "::",
      stringify!(StartingLcn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<STARTING_LCN_INPUT_BUFFER_EX>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_LCN_INPUT_BUFFER_EX),
      "::",
      stringify!(Flags)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_VCN_INPUT_BUFFER {
  pub StartingVcn: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_STARTING_VCN_INPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<STARTING_VCN_INPUT_BUFFER>(),
    8usize,
    concat!("Size of: ", stringify!(STARTING_VCN_INPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<STARTING_VCN_INPUT_BUFFER>(),
    8usize,
    concat!("Alignment of ", stringify!(STARTING_VCN_INPUT_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STARTING_VCN_INPUT_BUFFER>())).StartingVcn as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_VCN_INPUT_BUFFER),
      "::",
      stringify!(StartingVcn)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER {
  pub ExtentCount: DWORD,
  pub StartingVcn: LARGE_INTEGER,
  pub Extents: [RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1 {
  pub NextVcn: LARGE_INTEGER,
  pub Lcn: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>())).NextVcn as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1),
      "::",
      stringify!(NextVcn)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>())).Lcn as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1),
      "::",
      stringify!(Lcn)
    )
  );
}
#[test]
fn bindgen_test_layout_RETRIEVAL_POINTERS_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<RETRIEVAL_POINTERS_BUFFER>(),
    32usize,
    concat!("Size of: ", stringify!(RETRIEVAL_POINTERS_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<RETRIEVAL_POINTERS_BUFFER>(),
    8usize,
    concat!("Alignment of ", stringify!(RETRIEVAL_POINTERS_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER>())).ExtentCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER),
      "::",
      stringify!(ExtentCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER>())).StartingVcn as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER),
      "::",
      stringify!(StartingVcn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER>())).Extents as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER),
      "::",
      stringify!(Extents)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SI_COPYFILE {
  pub SourceFileNameLength: DWORD,
  pub DestinationFileNameLength: DWORD,
  pub Flags: DWORD,
  pub FileNameBuffer: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SI_COPYFILE() {
  assert_eq!(
    ::std::mem::size_of::<_SI_COPYFILE>(),
    16usize,
    concat!("Size of: ", stringify!(_SI_COPYFILE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SI_COPYFILE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SI_COPYFILE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SI_COPYFILE>())).SourceFileNameLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(SourceFileNameLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SI_COPYFILE>())).DestinationFileNameLength as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(DestinationFileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SI_COPYFILE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SI_COPYFILE>())).FileNameBuffer as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(FileNameBuffer)
    )
  );
}
pub type SI_COPYFILE = _SI_COPYFILE;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkPrepare: _SHRINK_VOLUME_REQUEST_TYPES = 1;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkCommit: _SHRINK_VOLUME_REQUEST_TYPES = 2;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkAbort: _SHRINK_VOLUME_REQUEST_TYPES = 3;
pub type _SHRINK_VOLUME_REQUEST_TYPES = ::std::os::raw::c_int;
pub use self::_SHRINK_VOLUME_REQUEST_TYPES as SHRINK_VOLUME_REQUEST_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHRINK_VOLUME_INFORMATION {
  pub ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
  pub Flags: DWORDLONG,
  pub NewNumberOfSectors: LONGLONG,
}
#[test]
fn bindgen_test_layout__SHRINK_VOLUME_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SHRINK_VOLUME_INFORMATION>(),
    24usize,
    concat!("Size of: ", stringify!(_SHRINK_VOLUME_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHRINK_VOLUME_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHRINK_VOLUME_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHRINK_VOLUME_INFORMATION>())).ShrinkRequestType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHRINK_VOLUME_INFORMATION),
      "::",
      stringify!(ShrinkRequestType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHRINK_VOLUME_INFORMATION>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHRINK_VOLUME_INFORMATION),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHRINK_VOLUME_INFORMATION>())).NewNumberOfSectors as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHRINK_VOLUME_INFORMATION),
      "::",
      stringify!(NewNumberOfSectors)
    )
  );
}
pub type SHRINK_VOLUME_INFORMATION = _SHRINK_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_STORAGE_TYPE {
  pub DeviceId: DWORD,
  pub VendorId: GUID,
}
#[test]
fn bindgen_test_layout__VIRTUAL_STORAGE_TYPE() {
  assert_eq!(
    ::std::mem::size_of::<_VIRTUAL_STORAGE_TYPE>(),
    20usize,
    concat!("Size of: ", stringify!(_VIRTUAL_STORAGE_TYPE))
  );
  assert_eq!(
    ::std::mem::align_of::<_VIRTUAL_STORAGE_TYPE>(),
    4usize,
    concat!("Alignment of ", stringify!(_VIRTUAL_STORAGE_TYPE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_VIRTUAL_STORAGE_TYPE>())).DeviceId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIRTUAL_STORAGE_TYPE),
      "::",
      stringify!(DeviceId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_VIRTUAL_STORAGE_TYPE>())).VendorId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIRTUAL_STORAGE_TYPE),
      "::",
      stringify!(VendorId)
    )
  );
}
pub type VIRTUAL_STORAGE_TYPE = _VIRTUAL_STORAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
  pub RequestLevel: DWORD,
  pub RequestFlags: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>())).RequestLevel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST),
      "::",
      stringify!(RequestLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>())).RequestFlags as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST),
      "::",
      stringify!(RequestFlags)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
  pub EntryLength: DWORD,
  pub DependencyTypeFlags: DWORD,
  pub ProviderSpecificFlags: DWORD,
  pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).EntryLength as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(EntryLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).DependencyTypeFlags
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(DependencyTypeFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).ProviderSpecificFlags
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(ProviderSpecificFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).VirtualStorageType
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(VirtualStorageType)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
  pub EntryLength: DWORD,
  pub DependencyTypeFlags: DWORD,
  pub ProviderSpecificFlags: DWORD,
  pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
  pub AncestorLevel: DWORD,
  pub HostVolumeNameOffset: DWORD,
  pub HostVolumeNameSize: DWORD,
  pub DependentVolumeNameOffset: DWORD,
  pub DependentVolumeNameSize: DWORD,
  pub RelativePathOffset: DWORD,
  pub RelativePathSize: DWORD,
  pub DependentDeviceNameOffset: DWORD,
  pub DependentDeviceNameSize: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>(),
    68usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).EntryLength as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(EntryLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).DependencyTypeFlags
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependencyTypeFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).ProviderSpecificFlags
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(ProviderSpecificFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).VirtualStorageType
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(VirtualStorageType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).AncestorLevel
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(AncestorLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).HostVolumeNameOffset
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(HostVolumeNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).HostVolumeNameSize
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(HostVolumeNameSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>()))
        .DependentVolumeNameOffset as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentVolumeNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).DependentVolumeNameSize
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentVolumeNameSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).RelativePathOffset
        as *const _ as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(RelativePathOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).RelativePathSize
        as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(RelativePathSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>()))
        .DependentDeviceNameOffset as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentDeviceNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).DependentDeviceNameSize
        as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentDeviceNameSize)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
  pub ResponseLevel: DWORD,
  pub NumberEntries: DWORD,
  pub __bindgen_anon_1: _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1,
}
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1 {
  pub Lev1Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY; 0usize]>,
  pub Lev2Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY; 0usize]>,
  pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>())).Lev1Depends
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1),
      "::",
      stringify!(Lev1Depends)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>())).Lev2Depends
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1),
      "::",
      stringify!(Lev2Depends)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>())).ResponseLevel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE),
      "::",
      stringify!(ResponseLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>())).NumberEntries as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE),
      "::",
      stringify!(NumberEntries)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_INPUT {
  pub CurrentMachineSIDOffset: WORD,
  pub CurrentMachineSIDLength: WORD,
  pub NewMachineSIDOffset: WORD,
  pub NewMachineSIDLength: WORD,
}
#[test]
fn bindgen_test_layout__SD_CHANGE_MACHINE_SID_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_CHANGE_MACHINE_SID_INPUT>(),
    8usize,
    concat!("Size of: ", stringify!(_SD_CHANGE_MACHINE_SID_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_CHANGE_MACHINE_SID_INPUT>(),
    2usize,
    concat!("Alignment of ", stringify!(_SD_CHANGE_MACHINE_SID_INPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).CurrentMachineSIDOffset as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(CurrentMachineSIDOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).CurrentMachineSIDLength as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(CurrentMachineSIDLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).NewMachineSIDOffset as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(NewMachineSIDOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).NewMachineSIDLength as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(NewMachineSIDLength)
    )
  );
}
pub type SD_CHANGE_MACHINE_SID_INPUT = _SD_CHANGE_MACHINE_SID_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_OUTPUT {
  pub NumSDChangedSuccess: DWORDLONG,
  pub NumSDChangedFail: DWORDLONG,
  pub NumSDUnused: DWORDLONG,
  pub NumSDTotal: DWORDLONG,
  pub NumMftSDChangedSuccess: DWORDLONG,
  pub NumMftSDChangedFail: DWORDLONG,
  pub NumMftSDTotal: DWORDLONG,
}
#[test]
fn bindgen_test_layout__SD_CHANGE_MACHINE_SID_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_CHANGE_MACHINE_SID_OUTPUT>(),
    56usize,
    concat!("Size of: ", stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_CHANGE_MACHINE_SID_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDChangedSuccess as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDChangedSuccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDChangedFail as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDChangedFail)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDUnused as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDUnused)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDTotal as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDTotal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumMftSDChangedSuccess as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumMftSDChangedSuccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumMftSDChangedFail as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumMftSDChangedFail)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumMftSDTotal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumMftSDTotal)
    )
  );
}
pub type SD_CHANGE_MACHINE_SID_OUTPUT = _SD_CHANGE_MACHINE_SID_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_INPUT {
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__SD_QUERY_STATS_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_QUERY_STATS_INPUT>(),
    4usize,
    concat!("Size of: ", stringify!(_SD_QUERY_STATS_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_QUERY_STATS_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SD_QUERY_STATS_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_QUERY_STATS_INPUT>())).Reserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_INPUT),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type SD_QUERY_STATS_INPUT = _SD_QUERY_STATS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_OUTPUT {
  pub SdsStreamSize: DWORDLONG,
  pub SdsAllocationSize: DWORDLONG,
  pub SiiStreamSize: DWORDLONG,
  pub SiiAllocationSize: DWORDLONG,
  pub SdhStreamSize: DWORDLONG,
  pub SdhAllocationSize: DWORDLONG,
  pub NumSDTotal: DWORDLONG,
  pub NumSDUnused: DWORDLONG,
}
#[test]
fn bindgen_test_layout__SD_QUERY_STATS_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_QUERY_STATS_OUTPUT>(),
    64usize,
    concat!("Size of: ", stringify!(_SD_QUERY_STATS_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_QUERY_STATS_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_QUERY_STATS_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdsStreamSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdsStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdsAllocationSize as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdsAllocationSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SiiStreamSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SiiStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SiiAllocationSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SiiAllocationSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdhStreamSize as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdhStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdhAllocationSize as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdhAllocationSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).NumSDTotal as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(NumSDTotal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).NumSDUnused as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(NumSDUnused)
    )
  );
}
pub type SD_QUERY_STATS_OUTPUT = _SD_QUERY_STATS_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_INPUT {
  pub StartingOffset: DWORDLONG,
  pub MaxSDEntriesToReturn: DWORDLONG,
}
#[test]
fn bindgen_test_layout__SD_ENUM_SDS_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_ENUM_SDS_INPUT>(),
    16usize,
    concat!("Size of: ", stringify!(_SD_ENUM_SDS_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_ENUM_SDS_INPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_ENUM_SDS_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_INPUT>())).StartingOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_INPUT),
      "::",
      stringify!(StartingOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_ENUM_SDS_INPUT>())).MaxSDEntriesToReturn as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_INPUT),
      "::",
      stringify!(MaxSDEntriesToReturn)
    )
  );
}
pub type SD_ENUM_SDS_INPUT = _SD_ENUM_SDS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_ENTRY {
  pub Hash: DWORD,
  pub SecurityId: DWORD,
  pub Offset: DWORDLONG,
  pub Length: DWORD,
  pub Descriptor: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SD_ENUM_SDS_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_SD_ENUM_SDS_ENTRY>(),
    24usize,
    concat!("Size of: ", stringify!(_SD_ENUM_SDS_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_ENUM_SDS_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_ENUM_SDS_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Hash as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Hash)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).SecurityId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(SecurityId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Offset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Length as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Descriptor as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Descriptor)
    )
  );
}
pub type SD_ENUM_SDS_ENTRY = _SD_ENUM_SDS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_OUTPUT {
  pub NextOffset: DWORDLONG,
  pub NumSDEntriesReturned: DWORDLONG,
  pub NumSDBytesReturned: DWORDLONG,
  pub SDEntry: [SD_ENUM_SDS_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__SD_ENUM_SDS_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_ENUM_SDS_OUTPUT>(),
    48usize,
    concat!("Size of: ", stringify!(_SD_ENUM_SDS_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_ENUM_SDS_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_ENUM_SDS_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).NextOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(NextOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).NumSDEntriesReturned as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(NumSDEntriesReturned)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).NumSDBytesReturned as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(NumSDBytesReturned)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).SDEntry as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(SDEntry)
    )
  );
}
pub type SD_ENUM_SDS_OUTPUT = _SD_ENUM_SDS_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_INPUT {
  pub Flags: DWORD,
  pub ChangeType: DWORD,
  pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1 {
  pub SdChange: SD_CHANGE_MACHINE_SID_INPUT,
  pub SdQueryStats: SD_QUERY_STATS_INPUT,
  pub SdEnumSds: SD_ENUM_SDS_INPUT,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>())).SdChange as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1),
      "::",
      stringify!(SdChange)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>())).SdQueryStats as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1),
      "::",
      stringify!(SdQueryStats)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>())).SdEnumSds as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1),
      "::",
      stringify!(SdEnumSds)
    )
  );
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_INPUT>(),
    24usize,
    concat!("Size of: ", stringify!(_SD_GLOBAL_CHANGE_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_INPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_GLOBAL_CHANGE_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT>())).ChangeType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT),
      "::",
      stringify!(ChangeType)
    )
  );
}
pub type SD_GLOBAL_CHANGE_INPUT = _SD_GLOBAL_CHANGE_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_OUTPUT {
  pub Flags: DWORD,
  pub ChangeType: DWORD,
  pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1 {
  pub SdChange: SD_CHANGE_MACHINE_SID_OUTPUT,
  pub SdQueryStats: SD_QUERY_STATS_OUTPUT,
  pub SdEnumSds: SD_ENUM_SDS_OUTPUT,
  _bindgen_union_align: [u64; 8usize],
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>(),
    64usize,
    concat!(
      "Size of: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>())).SdChange as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1),
      "::",
      stringify!(SdChange)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>())).SdQueryStats as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1),
      "::",
      stringify!(SdQueryStats)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>())).SdEnumSds as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1),
      "::",
      stringify!(SdEnumSds)
    )
  );
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_OUTPUT>(),
    72usize,
    concat!("Size of: ", stringify!(_SD_GLOBAL_CHANGE_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_GLOBAL_CHANGE_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT>())).ChangeType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT),
      "::",
      stringify!(ChangeType)
    )
  );
}
pub type SD_GLOBAL_CHANGE_OUTPUT = _SD_GLOBAL_CHANGE_OUTPUT;
pub const _STORAGE_RESERVE_ID_StorageReserveIdNone: _STORAGE_RESERVE_ID = 0;
pub const _STORAGE_RESERVE_ID_StorageReserveIdHard: _STORAGE_RESERVE_ID = 1;
pub const _STORAGE_RESERVE_ID_StorageReserveIdSoft: _STORAGE_RESERVE_ID = 2;
pub const _STORAGE_RESERVE_ID_StorageReserveIdUpdateScratch: _STORAGE_RESERVE_ID = 3;
pub const _STORAGE_RESERVE_ID_StorageReserveIdMax: _STORAGE_RESERVE_ID = 4;
pub type _STORAGE_RESERVE_ID = ::std::os::raw::c_int;
pub use self::_STORAGE_RESERVE_ID as STORAGE_RESERVE_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_LAYOUT_ENTRY {
  pub Version: DWORD,
  pub NextStreamOffset: DWORD,
  pub Flags: DWORD,
  pub ExtentInformationOffset: DWORD,
  pub AllocationSize: LARGE_INTEGER,
  pub EndOfFile: LARGE_INTEGER,
  pub StreamInformationOffset: DWORD,
  pub AttributeTypeCode: DWORD,
  pub AttributeFlags: DWORD,
  pub StreamIdentifierLength: DWORD,
  pub StreamIdentifier: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__STREAM_LAYOUT_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_LAYOUT_ENTRY>(),
    56usize,
    concat!("Size of: ", stringify!(_STREAM_LAYOUT_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_LAYOUT_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_STREAM_LAYOUT_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).NextStreamOffset as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(NextStreamOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).ExtentInformationOffset as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(ExtentInformationOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).AllocationSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(AllocationSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).EndOfFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(EndOfFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).StreamInformationOffset as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(StreamInformationOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).AttributeTypeCode as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(AttributeTypeCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).AttributeFlags as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(AttributeFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).StreamIdentifierLength as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(StreamIdentifierLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).StreamIdentifier as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(StreamIdentifier)
    )
  );
}
pub type STREAM_LAYOUT_ENTRY = _STREAM_LAYOUT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_EXTENT_ENTRY {
  pub Flags: DWORD,
  pub ExtentInformation: _STREAM_EXTENT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_EXTENT_ENTRY__bindgen_ty_1 {
  pub RetrievalPointers: RETRIEVAL_POINTERS_BUFFER,
  _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__STREAM_EXTENT_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_EXTENT_ENTRY__bindgen_ty_1>(),
    32usize,
    concat!("Size of: ", stringify!(_STREAM_EXTENT_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_EXTENT_ENTRY__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAM_EXTENT_ENTRY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_EXTENT_ENTRY__bindgen_ty_1>())).RetrievalPointers as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_EXTENT_ENTRY__bindgen_ty_1),
      "::",
      stringify!(RetrievalPointers)
    )
  );
}
#[test]
fn bindgen_test_layout__STREAM_EXTENT_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_EXTENT_ENTRY>(),
    40usize,
    concat!("Size of: ", stringify!(_STREAM_EXTENT_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_EXTENT_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_STREAM_EXTENT_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_EXTENT_ENTRY>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_EXTENT_ENTRY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_EXTENT_ENTRY>())).ExtentInformation as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_EXTENT_ENTRY),
      "::",
      stringify!(ExtentInformation)
    )
  );
}
pub type STREAM_EXTENT_ENTRY = _STREAM_EXTENT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_PURGE_FAILURE_MODE_INPUT {
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__SET_PURGE_FAILURE_MODE_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PURGE_FAILURE_MODE_INPUT>(),
    4usize,
    concat!("Size of: ", stringify!(_SET_PURGE_FAILURE_MODE_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PURGE_FAILURE_MODE_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SET_PURGE_FAILURE_MODE_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_PURGE_FAILURE_MODE_INPUT>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PURGE_FAILURE_MODE_INPUT),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SET_PURGE_FAILURE_MODE_INPUT = _SET_PURGE_FAILURE_MODE_INPUT;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassUnspecified: _FILE_STORAGE_TIER_CLASS = 0;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassCapacity: _FILE_STORAGE_TIER_CLASS = 1;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassPerformance: _FILE_STORAGE_TIER_CLASS = 2;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassMax: _FILE_STORAGE_TIER_CLASS = 3;
pub type _FILE_STORAGE_TIER_CLASS = ::std::os::raw::c_int;
pub use self::_FILE_STORAGE_TIER_CLASS as FILE_STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY {
  pub Version: DWORD,
  pub Flags: DWORD,
  pub StreamInformation: _STREAM_INFORMATION_ENTRY__StreamInformation,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_INFORMATION_ENTRY__StreamInformation {
  pub DesiredStorageClass: _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass {
  pub Class: FILE_STORAGE_TIER_CLASS,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>()))
        .Class as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass),
      "::",
      stringify!(Class)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>()))
        .Flags as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass),
      "::",
      stringify!(Flags)
    )
  );
}
#[test]
fn bindgen_test_layout__STREAM_INFORMATION_ENTRY__StreamInformation() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_INFORMATION_ENTRY__StreamInformation>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_INFORMATION_ENTRY__StreamInformation>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY__StreamInformation>())).DesiredStorageClass
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation),
      "::",
      stringify!(DesiredStorageClass)
    )
  );
}
#[test]
fn bindgen_test_layout__STREAM_INFORMATION_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_INFORMATION_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_STREAM_INFORMATION_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_INFORMATION_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STREAM_INFORMATION_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY>())).StreamInformation as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY),
      "::",
      stringify!(StreamInformation)
    )
  );
}
pub type STREAM_INFORMATION_ENTRY = _STREAM_INFORMATION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
  pub OptimalWriteSize: DWORD,
  pub StreamGranularitySize: DWORD,
  pub StreamIdMin: DWORD,
  pub StreamIdMax: DWORD,
}
#[test]
fn bindgen_test_layout__STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).OptimalWriteSize
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(OptimalWriteSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).StreamGranularitySize
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(StreamGranularitySize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).StreamIdMin as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(StreamIdMin)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).StreamIdMax as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(StreamIdMax)
    )
  );
}
pub type STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
  pub Flags: DWORD,
  pub StreamId: DWORD,
}
#[test]
fn bindgen_test_layout__STREAMS_ASSOCIATE_ID_INPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>(),
    8usize,
    concat!("Size of: ", stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>())).Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>())).StreamId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER),
      "::",
      stringify!(StreamId)
    )
  );
}
pub type STREAMS_ASSOCIATE_ID_INPUT_BUFFER = _STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_ID_OUTPUT_BUFFER {
  pub StreamId: DWORD,
}
#[test]
fn bindgen_test_layout__STREAMS_QUERY_ID_OUTPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_STREAMS_QUERY_ID_OUTPUT_BUFFER>(),
    4usize,
    concat!("Size of: ", stringify!(_STREAMS_QUERY_ID_OUTPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAMS_QUERY_ID_OUTPUT_BUFFER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STREAMS_QUERY_ID_OUTPUT_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_ID_OUTPUT_BUFFER>())).StreamId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_ID_OUTPUT_BUFFER),
      "::",
      stringify!(StreamId)
    )
  );
}
pub type STREAMS_QUERY_ID_OUTPUT_BUFFER = _STREAMS_QUERY_ID_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
  pub Flags: DWORD,
  pub AlignmentShift: DWORD,
  pub FileOffsetToAlign: DWORDLONG,
  pub FallbackAlignmentShift: DWORD,
}
#[test]
fn bindgen_test_layout__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>(),
    24usize,
    concat!("Size of: ", stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).AlignmentShift as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(AlignmentShift)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).FileOffsetToAlign as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(FileOffsetToAlign)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).FallbackAlignmentShift
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(FallbackAlignmentShift)
    )
  );
}
pub type SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_IO_REQUEST {
  pub dwProtocol: DWORD,
  pub cbPciLength: DWORD,
}
#[test]
fn bindgen_test_layout__SCARD_IO_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_IO_REQUEST>(),
    8usize,
    concat!("Size of: ", stringify!(_SCARD_IO_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_IO_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_IO_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_IO_REQUEST>())).dwProtocol as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_IO_REQUEST),
      "::",
      stringify!(dwProtocol)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_IO_REQUEST>())).cbPciLength as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_IO_REQUEST),
      "::",
      stringify!(cbPciLength)
    )
  );
}
pub type SCARD_IO_REQUEST = _SCARD_IO_REQUEST;
pub type LPSCARD_IO_REQUEST = *mut _SCARD_IO_REQUEST;
pub type LPCSCARD_IO_REQUEST = *const SCARD_IO_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_T0_COMMAND {
  pub bCla: BYTE,
  pub bIns: BYTE,
  pub bP1: BYTE,
  pub bP2: BYTE,
  pub bP3: BYTE,
}
#[test]
fn bindgen_test_layout__SCARD_T0_COMMAND() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T0_COMMAND>(),
    5usize,
    concat!("Size of: ", stringify!(_SCARD_T0_COMMAND))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T0_COMMAND>(),
    1usize,
    concat!("Alignment of ", stringify!(_SCARD_T0_COMMAND))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bCla as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bCla)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bIns as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bIns)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bP1 as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bP1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bP2 as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bP2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bP3 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bP3)
    )
  );
}
pub type SCARD_T0_COMMAND = _SCARD_T0_COMMAND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCARD_T0_REQUEST {
  pub ioRequest: SCARD_IO_REQUEST,
  pub bSw1: BYTE,
  pub bSw2: BYTE,
  pub __bindgen_anon_1: _SCARD_T0_REQUEST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SCARD_T0_REQUEST__bindgen_ty_1 {
  pub CmdBytes: SCARD_T0_COMMAND,
  pub rgbHeader: [BYTE; 5usize],
  _bindgen_union_align: [u8; 5usize],
}
#[test]
fn bindgen_test_layout__SCARD_T0_REQUEST__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T0_REQUEST__bindgen_ty_1>(),
    5usize,
    concat!("Size of: ", stringify!(_SCARD_T0_REQUEST__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T0_REQUEST__bindgen_ty_1>(),
    1usize,
    concat!("Alignment of ", stringify!(_SCARD_T0_REQUEST__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCARD_T0_REQUEST__bindgen_ty_1>())).CmdBytes as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST__bindgen_ty_1),
      "::",
      stringify!(CmdBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCARD_T0_REQUEST__bindgen_ty_1>())).rgbHeader as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST__bindgen_ty_1),
      "::",
      stringify!(rgbHeader)
    )
  );
}
#[test]
fn bindgen_test_layout__SCARD_T0_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T0_REQUEST>(),
    16usize,
    concat!("Size of: ", stringify!(_SCARD_T0_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T0_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_T0_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_REQUEST>())).ioRequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST),
      "::",
      stringify!(ioRequest)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_REQUEST>())).bSw1 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST),
      "::",
      stringify!(bSw1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_REQUEST>())).bSw2 as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST),
      "::",
      stringify!(bSw2)
    )
  );
}
pub type SCARD_T0_REQUEST = _SCARD_T0_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_T1_REQUEST {
  pub ioRequest: SCARD_IO_REQUEST,
}
#[test]
fn bindgen_test_layout__SCARD_T1_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T1_REQUEST>(),
    8usize,
    concat!("Size of: ", stringify!(_SCARD_T1_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T1_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_T1_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T1_REQUEST>())).ioRequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T1_REQUEST),
      "::",
      stringify!(ioRequest)
    )
  );
}
pub type SCARD_T1_REQUEST = _SCARD_T1_REQUEST;
pub type LPCBYTE = *const BYTE;
pub type SCARDCONTEXT = ULONG_PTR;
pub type LPSCARDCONTEXT = *mut SCARDCONTEXT;
pub type SCARDHANDLE = ULONG_PTR;
pub type LPSCARDHANDLE = *mut SCARDHANDLE;
extern "C" {
  pub fn SCardEstablishContext(
    dwScope: DWORD,
    pvReserved1: LPCVOID,
    pvReserved2: LPCVOID,
    phContext: LPSCARDCONTEXT,
  ) -> LONG;
}
extern "C" {
  pub fn SCardReleaseContext(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
  pub fn SCardIsValidContext(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
  pub fn SCardListReaderGroupsA(
    hContext: SCARDCONTEXT,
    mszGroups: LPSTR,
    pcchGroups: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReaderGroupsW(
    hContext: SCARDCONTEXT,
    mszGroups: LPWSTR,
    pcchGroups: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersA(
    hContext: SCARDCONTEXT,
    mszGroups: LPCSTR,
    mszReaders: LPSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersW(
    hContext: SCARDCONTEXT,
    mszGroups: LPCWSTR,
    mszReaders: LPWSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListCardsA(
    hContext: SCARDCONTEXT,
    pbAtr: LPCBYTE,
    rgquidInterfaces: LPCGUID,
    cguidInterfaceCount: DWORD,
    mszCards: *mut CHAR,
    pcchCards: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListCardsW(
    hContext: SCARDCONTEXT,
    pbAtr: LPCBYTE,
    rgquidInterfaces: LPCGUID,
    cguidInterfaceCount: DWORD,
    mszCards: *mut WCHAR,
    pcchCards: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListInterfacesA(
    hContext: SCARDCONTEXT,
    szCard: LPCSTR,
    pguidInterfaces: LPGUID,
    pcguidInterfaces: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListInterfacesW(
    hContext: SCARDCONTEXT,
    szCard: LPCWSTR,
    pguidInterfaces: LPGUID,
    pcguidInterfaces: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetProviderIdA(
    hContext: SCARDCONTEXT,
    szCard: LPCSTR,
    pguidProviderId: LPGUID,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetProviderIdW(
    hContext: SCARDCONTEXT,
    szCard: LPCWSTR,
    pguidProviderId: LPGUID,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetCardTypeProviderNameA(
    hContext: SCARDCONTEXT,
    szCardName: LPCSTR,
    dwProviderId: DWORD,
    szProvider: *mut CHAR,
    pcchProvider: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetCardTypeProviderNameW(
    hContext: SCARDCONTEXT,
    szCardName: LPCWSTR,
    dwProviderId: DWORD,
    szProvider: *mut WCHAR,
    pcchProvider: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szDeviceName: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szDeviceName: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderA(hContext: SCARDCONTEXT, szReaderName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardAddReaderToGroupA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szGroupName: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardAddReaderToGroupW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szGroupName: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardRemoveReaderFromGroupA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szGroupName: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardRemoveReaderFromGroupW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szGroupName: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceCardTypeA(
    hContext: SCARDCONTEXT,
    szCardName: LPCSTR,
    pguidPrimaryProvider: LPCGUID,
    rgguidInterfaces: LPCGUID,
    dwInterfaceCount: DWORD,
    pbAtr: LPCBYTE,
    pbAtrMask: LPCBYTE,
    cbAtrLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceCardTypeW(
    hContext: SCARDCONTEXT,
    szCardName: LPCWSTR,
    pguidPrimaryProvider: LPCGUID,
    rgguidInterfaces: LPCGUID,
    dwInterfaceCount: DWORD,
    pbAtr: LPCBYTE,
    pbAtrMask: LPCBYTE,
    cbAtrLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardSetCardTypeProviderNameA(
    hContext: SCARDCONTEXT,
    szCardName: LPCSTR,
    dwProviderId: DWORD,
    szProvider: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardSetCardTypeProviderNameW(
    hContext: SCARDCONTEXT,
    szCardName: LPCWSTR,
    dwProviderId: DWORD,
    szProvider: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardForgetCardTypeA(hContext: SCARDCONTEXT, szCardName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetCardTypeW(hContext: SCARDCONTEXT, szCardName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardFreeMemory(hContext: SCARDCONTEXT, pvMem: LPCVOID) -> LONG;
}
extern "C" {
  pub fn SCardAccessStartedEvent() -> HANDLE;
}
extern "C" {
  pub fn SCardReleaseStartedEvent();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCARD_READERSTATEA {
  pub szReader: LPCSTR,
  pub pvUserData: LPVOID,
  pub dwCurrentState: DWORD,
  pub dwEventState: DWORD,
  pub cbAtr: DWORD,
  pub rgbAtr: [BYTE; 36usize],
}
#[test]
fn bindgen_test_layout_SCARD_READERSTATEA() {
  assert_eq!(
    ::std::mem::size_of::<SCARD_READERSTATEA>(),
    64usize,
    concat!("Size of: ", stringify!(SCARD_READERSTATEA))
  );
  assert_eq!(
    ::std::mem::align_of::<SCARD_READERSTATEA>(),
    8usize,
    concat!("Alignment of ", stringify!(SCARD_READERSTATEA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).szReader as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(szReader)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).pvUserData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).dwCurrentState as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).dwEventState as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(dwEventState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).cbAtr as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(cbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).rgbAtr as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(rgbAtr)
    )
  );
}
pub type LPSCARD_READERSTATEA = *mut SCARD_READERSTATEA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCARD_READERSTATEW {
  pub szReader: LPCWSTR,
  pub pvUserData: LPVOID,
  pub dwCurrentState: DWORD,
  pub dwEventState: DWORD,
  pub cbAtr: DWORD,
  pub rgbAtr: [BYTE; 36usize],
}
#[test]
fn bindgen_test_layout_SCARD_READERSTATEW() {
  assert_eq!(
    ::std::mem::size_of::<SCARD_READERSTATEW>(),
    64usize,
    concat!("Size of: ", stringify!(SCARD_READERSTATEW))
  );
  assert_eq!(
    ::std::mem::align_of::<SCARD_READERSTATEW>(),
    8usize,
    concat!("Alignment of ", stringify!(SCARD_READERSTATEW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).szReader as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(szReader)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).pvUserData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).dwCurrentState as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).dwEventState as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(dwEventState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).cbAtr as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(cbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).rgbAtr as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(rgbAtr)
    )
  );
}
pub type LPSCARD_READERSTATEW = *mut SCARD_READERSTATEW;
pub type SCARD_READERSTATE = SCARD_READERSTATEW;
extern "C" {
  pub fn SCardLocateCardsA(
    hContext: SCARDCONTEXT,
    mszCards: LPCSTR,
    rgReaderStates: LPSCARD_READERSTATEA,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardLocateCardsW(
    hContext: SCARDCONTEXT,
    mszCards: LPCWSTR,
    rgReaderStates: LPSCARD_READERSTATEW,
    cReaders: DWORD,
  ) -> LONG;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCARD_ATRMASK {
  pub cbAtr: DWORD,
  pub rgbAtr: [BYTE; 36usize],
  pub rgbMask: [BYTE; 36usize],
}
#[test]
fn bindgen_test_layout__SCARD_ATRMASK() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_ATRMASK>(),
    76usize,
    concat!("Size of: ", stringify!(_SCARD_ATRMASK))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_ATRMASK>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_ATRMASK))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_ATRMASK>())).cbAtr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_ATRMASK),
      "::",
      stringify!(cbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_ATRMASK>())).rgbAtr as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_ATRMASK),
      "::",
      stringify!(rgbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_ATRMASK>())).rgbMask as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_ATRMASK),
      "::",
      stringify!(rgbMask)
    )
  );
}
pub type SCARD_ATRMASK = _SCARD_ATRMASK;
pub type LPSCARD_ATRMASK = *mut _SCARD_ATRMASK;
extern "C" {
  pub fn SCardLocateCardsByATRA(
    hContext: SCARDCONTEXT,
    rgAtrMasks: LPSCARD_ATRMASK,
    cAtrs: DWORD,
    rgReaderStates: LPSCARD_READERSTATEA,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardLocateCardsByATRW(
    hContext: SCARDCONTEXT,
    rgAtrMasks: LPSCARD_ATRMASK,
    cAtrs: DWORD,
    rgReaderStates: LPSCARD_READERSTATEW,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetStatusChangeA(
    hContext: SCARDCONTEXT,
    dwTimeout: DWORD,
    rgReaderStates: LPSCARD_READERSTATEA,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetStatusChangeW(
    hContext: SCARDCONTEXT,
    dwTimeout: DWORD,
    rgReaderStates: LPSCARD_READERSTATEW,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardCancel(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
  pub fn SCardConnectA(
    hContext: SCARDCONTEXT,
    szReader: LPCSTR,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    phCard: LPSCARDHANDLE,
    pdwActiveProtocol: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardConnectW(
    hContext: SCARDCONTEXT,
    szReader: LPCWSTR,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    phCard: LPSCARDHANDLE,
    pdwActiveProtocol: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardReconnect(
    hCard: SCARDHANDLE,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwInitialization: DWORD,
    pdwActiveProtocol: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardDisconnect(hCard: SCARDHANDLE, dwDisposition: DWORD) -> LONG;
}
extern "C" {
  pub fn SCardBeginTransaction(hCard: SCARDHANDLE) -> LONG;
}
extern "C" {
  pub fn SCardEndTransaction(hCard: SCARDHANDLE, dwDisposition: DWORD) -> LONG;
}
extern "C" {
  pub fn SCardCancelTransaction(hCard: SCARDHANDLE) -> LONG;
}
extern "C" {
  pub fn SCardState(
    hCard: SCARDHANDLE,
    pdwState: LPDWORD,
    pdwProtocol: LPDWORD,
    pbAtr: LPBYTE,
    pcbAtrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardStatusA(
    hCard: SCARDHANDLE,
    mszReaderNames: LPSTR,
    pcchReaderLen: LPDWORD,
    pdwState: LPDWORD,
    pdwProtocol: LPDWORD,
    pbAtr: LPBYTE,
    pcbAtrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardStatusW(
    hCard: SCARDHANDLE,
    mszReaderNames: LPWSTR,
    pcchReaderLen: LPDWORD,
    pdwState: LPDWORD,
    pdwProtocol: LPDWORD,
    pbAtr: LPBYTE,
    pcbAtrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardTransmit(
    hCard: SCARDHANDLE,
    pioSendPci: LPCSCARD_IO_REQUEST,
    pbSendBuffer: LPCBYTE,
    cbSendLength: DWORD,
    pioRecvPci: LPSCARD_IO_REQUEST,
    pbRecvBuffer: LPBYTE,
    pcbRecvLength: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetTransmitCount(hCard: SCARDHANDLE, pcTransmitCount: LPDWORD) -> LONG;
}
extern "C" {
  pub fn SCardControl(
    hCard: SCARDHANDLE,
    dwControlCode: DWORD,
    lpInBuffer: LPCVOID,
    cbInBufferSize: DWORD,
    lpOutBuffer: LPVOID,
    cbOutBufferSize: DWORD,
    lpBytesReturned: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetAttrib(
    hCard: SCARDHANDLE,
    dwAttrId: DWORD,
    pbAttr: LPBYTE,
    pcbAttrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardSetAttrib(
    hCard: SCARDHANDLE,
    dwAttrId: DWORD,
    pbAttr: LPCBYTE,
    cbAttrLen: DWORD,
  ) -> LONG;
}
pub type LPOCNCONNPROCA = ::std::option::Option<
  unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: LPSTR, arg3: LPSTR, arg4: PVOID) -> SCARDHANDLE,
>;
pub type LPOCNCONNPROCW = ::std::option::Option<
  unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: LPWSTR, arg3: LPWSTR, arg4: PVOID) -> SCARDHANDLE,
>;
pub type LPOCNCHKPROC = ::std::option::Option<
  unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: SCARDHANDLE, arg3: PVOID) -> BOOL,
>;
pub type LPOCNDSCPROC =
  ::std::option::Option<unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: SCARDHANDLE, arg3: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARD_SEARCH_CRITERIAA {
  pub dwStructSize: DWORD,
  pub lpstrGroupNames: LPSTR,
  pub nMaxGroupNames: DWORD,
  pub rgguidInterfaces: LPCGUID,
  pub cguidInterfaces: DWORD,
  pub lpstrCardNames: LPSTR,
  pub nMaxCardNames: DWORD,
  pub lpfnCheck: LPOCNCHKPROC,
  pub lpfnConnect: LPOCNCONNPROCA,
  pub lpfnDisconnect: LPOCNDSCPROC,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
}
#[test]
fn bindgen_test_layout_OPENCARD_SEARCH_CRITERIAA() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARD_SEARCH_CRITERIAA>(),
    96usize,
    concat!("Size of: ", stringify!(OPENCARD_SEARCH_CRITERIAA))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARD_SEARCH_CRITERIAA>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARD_SEARCH_CRITERIAA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).dwStructSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpstrGroupNames as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpstrGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).nMaxGroupNames as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(nMaxGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).rgguidInterfaces as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(rgguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).cguidInterfaces as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(cguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpstrCardNames as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpstrCardNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).nMaxCardNames as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(nMaxCardNames)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpfnCheck as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpfnCheck)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpfnConnect as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpfnDisconnect as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpfnDisconnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).pvUserData as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).dwShareMode as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).dwPreferredProtocols as *const _
        as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
}
pub type POPENCARD_SEARCH_CRITERIAA = *mut OPENCARD_SEARCH_CRITERIAA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARD_SEARCH_CRITERIAW {
  pub dwStructSize: DWORD,
  pub lpstrGroupNames: LPWSTR,
  pub nMaxGroupNames: DWORD,
  pub rgguidInterfaces: LPCGUID,
  pub cguidInterfaces: DWORD,
  pub lpstrCardNames: LPWSTR,
  pub nMaxCardNames: DWORD,
  pub lpfnCheck: LPOCNCHKPROC,
  pub lpfnConnect: LPOCNCONNPROCW,
  pub lpfnDisconnect: LPOCNDSCPROC,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
}
#[test]
fn bindgen_test_layout_OPENCARD_SEARCH_CRITERIAW() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARD_SEARCH_CRITERIAW>(),
    96usize,
    concat!("Size of: ", stringify!(OPENCARD_SEARCH_CRITERIAW))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARD_SEARCH_CRITERIAW>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARD_SEARCH_CRITERIAW))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).dwStructSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpstrGroupNames as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpstrGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).nMaxGroupNames as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(nMaxGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).rgguidInterfaces as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(rgguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).cguidInterfaces as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(cguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpstrCardNames as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpstrCardNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).nMaxCardNames as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(nMaxCardNames)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpfnCheck as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpfnCheck)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpfnConnect as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpfnDisconnect as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpfnDisconnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).pvUserData as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).dwShareMode as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).dwPreferredProtocols as *const _
        as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
}
pub type POPENCARD_SEARCH_CRITERIAW = *mut OPENCARD_SEARCH_CRITERIAW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAME_EXA {
  pub dwStructSize: DWORD,
  pub hSCardContext: SCARDCONTEXT,
  pub hwndOwner: HWND,
  pub dwFlags: DWORD,
  pub lpstrTitle: LPCSTR,
  pub lpstrSearchDesc: LPCSTR,
  pub hIcon: HICON,
  pub pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAA,
  pub lpfnConnect: LPOCNCONNPROCA,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
  pub lpstrRdr: LPSTR,
  pub nMaxRdr: DWORD,
  pub lpstrCard: LPSTR,
  pub nMaxCard: DWORD,
  pub dwActiveProtocol: DWORD,
  pub hCardHandle: SCARDHANDLE,
}
#[test]
fn bindgen_test_layout_OPENCARDNAME_EXA() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARDNAME_EXA>(),
    128usize,
    concat!("Size of: ", stringify!(OPENCARDNAME_EXA))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARDNAME_EXA>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARDNAME_EXA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hSCardContext as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hSCardContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hwndOwner as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrTitle as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrSearchDesc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrSearchDesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hIcon as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).pOpenCardSearchCriteria as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(pOpenCardSearchCriteria)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpfnConnect as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).pvUserData as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwShareMode as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwPreferredProtocols as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrRdr as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).nMaxRdr as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(nMaxRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrCard as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).nMaxCard as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(nMaxCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwActiveProtocol as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwActiveProtocol)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hCardHandle as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hCardHandle)
    )
  );
}
pub type LPOPENCARDNAME_EXA = *mut OPENCARDNAME_EXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAME_EXW {
  pub dwStructSize: DWORD,
  pub hSCardContext: SCARDCONTEXT,
  pub hwndOwner: HWND,
  pub dwFlags: DWORD,
  pub lpstrTitle: LPCWSTR,
  pub lpstrSearchDesc: LPCWSTR,
  pub hIcon: HICON,
  pub pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAW,
  pub lpfnConnect: LPOCNCONNPROCW,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
  pub lpstrRdr: LPWSTR,
  pub nMaxRdr: DWORD,
  pub lpstrCard: LPWSTR,
  pub nMaxCard: DWORD,
  pub dwActiveProtocol: DWORD,
  pub hCardHandle: SCARDHANDLE,
}
#[test]
fn bindgen_test_layout_OPENCARDNAME_EXW() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARDNAME_EXW>(),
    128usize,
    concat!("Size of: ", stringify!(OPENCARDNAME_EXW))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARDNAME_EXW>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARDNAME_EXW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hSCardContext as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hSCardContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hwndOwner as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrTitle as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrSearchDesc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrSearchDesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hIcon as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).pOpenCardSearchCriteria as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(pOpenCardSearchCriteria)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpfnConnect as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).pvUserData as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwShareMode as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwPreferredProtocols as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrRdr as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).nMaxRdr as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(nMaxRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrCard as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).nMaxCard as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(nMaxCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwActiveProtocol as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwActiveProtocol)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hCardHandle as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hCardHandle)
    )
  );
}
pub type LPOPENCARDNAME_EXW = *mut OPENCARDNAME_EXW;
extern "C" {
  pub fn SCardUIDlgSelectCardA(arg1: LPOPENCARDNAME_EXA) -> LONG;
}
extern "C" {
  pub fn SCardUIDlgSelectCardW(arg1: LPOPENCARDNAME_EXW) -> LONG;
}
extern "C" {
  pub fn SCardDlgExtendedError() -> LONG;
}
extern "C" {
  pub fn SCardReadCacheA(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPSTR,
    Data: PBYTE,
    DataLen: *mut DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardReadCacheW(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPWSTR,
    Data: PBYTE,
    DataLen: *mut DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardWriteCacheA(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPSTR,
    Data: PBYTE,
    DataLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardWriteCacheW(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPWSTR,
    Data: PBYTE,
    DataLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderIconA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    pbIcon: LPBYTE,
    pcbIcon: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderIconW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    pbIcon: LPBYTE,
    pcbIcon: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetDeviceTypeIdA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    pdwDeviceTypeId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetDeviceTypeIdW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    pdwDeviceTypeId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderDeviceInstanceIdA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szDeviceInstanceId: LPSTR,
    pcchDeviceInstanceId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderDeviceInstanceIdW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szDeviceInstanceId: LPWSTR,
    pcchDeviceInstanceId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersWithDeviceInstanceIdA(
    hContext: SCARDCONTEXT,
    szDeviceInstanceId: LPCSTR,
    mszReaders: LPSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersWithDeviceInstanceIdW(
    hContext: SCARDCONTEXT,
    szDeviceInstanceId: LPCWSTR,
    mszReaders: LPWSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardAudit(hContext: SCARDCONTEXT, dwEvent: DWORD) -> LONG;
}
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUnknown {
  pub vtable_: *const IUnknown__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_IUnknown() {
  assert_eq!(
    ::std::mem::size_of::<IUnknown>(),
    8usize,
    concat!("Size of: ", stringify!(IUnknown))
  );
  assert_eq!(
    ::std::mem::align_of::<IUnknown>(),
    8usize,
    concat!("Alignment of ", stringify!(IUnknown))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumString {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IEnumString() {
  assert_eq!(
    ::std::mem::size_of::<IEnumString>(),
    8usize,
    concat!("Size of: ", stringify!(IEnumString))
  );
  assert_eq!(
    ::std::mem::align_of::<IEnumString>(),
    8usize,
    concat!("Alignment of ", stringify!(IEnumString))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISequentialStream {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ISequentialStream() {
  assert_eq!(
    ::std::mem::size_of::<ISequentialStream>(),
    8usize,
    concat!("Size of: ", stringify!(ISequentialStream))
  );
  assert_eq!(
    ::std::mem::align_of::<ISequentialStream>(),
    8usize,
    concat!("Alignment of ", stringify!(ISequentialStream))
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTATSTG {
  pub pwcsName: LPOLESTR,
  pub type_: DWORD,
  pub cbSize: ULARGE_INTEGER,
  pub mtime: FILETIME,
  pub ctime: FILETIME,
  pub atime: FILETIME,
  pub grfMode: DWORD,
  pub grfLocksSupported: DWORD,
  pub clsid: CLSID,
  pub grfStateBits: DWORD,
  pub reserved: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTATSTG() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATSTG>(),
    80usize,
    concat!("Size of: ", stringify!(tagSTATSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATSTG>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTATSTG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).pwcsName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(pwcsName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).cbSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).mtime as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(mtime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).ctime as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(ctime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).atime as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(atime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).grfMode as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(grfMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).grfLocksSupported as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(grfLocksSupported)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).clsid as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(clsid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).grfStateBits as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(grfStateBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).reserved as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(reserved)
    )
  );
}
pub type STATSTG = tagSTATSTG;
pub const tagSTGTY_STGTY_STORAGE: tagSTGTY = 1;
pub const tagSTGTY_STGTY_STREAM: tagSTGTY = 2;
pub const tagSTGTY_STGTY_LOCKBYTES: tagSTGTY = 3;
pub const tagSTGTY_STGTY_PROPERTY: tagSTGTY = 4;
pub type tagSTGTY = ::std::os::raw::c_int;
pub use self::tagSTGTY as STGTY;
pub const tagSTREAM_SEEK_STREAM_SEEK_SET: tagSTREAM_SEEK = 0;
pub const tagSTREAM_SEEK_STREAM_SEEK_CUR: tagSTREAM_SEEK = 1;
pub const tagSTREAM_SEEK_STREAM_SEEK_END: tagSTREAM_SEEK = 2;
pub type tagSTREAM_SEEK = ::std::os::raw::c_int;
pub use self::tagSTREAM_SEEK as STREAM_SEEK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStream {
  pub _base: ISequentialStream,
}
#[test]
fn bindgen_test_layout_IStream() {
  assert_eq!(
    ::std::mem::size_of::<IStream>(),
    8usize,
    concat!("Size of: ", stringify!(IStream))
  );
  assert_eq!(
    ::std::mem::align_of::<IStream>(),
    8usize,
    concat!("Alignment of ", stringify!(IStream))
  );
}
pub type RPCOLEDATAREP = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPCOLEMESSAGE {
  pub reserved1: *mut ::std::os::raw::c_void,
  pub dataRepresentation: RPCOLEDATAREP,
  pub Buffer: *mut ::std::os::raw::c_void,
  pub cbBuffer: ULONG,
  pub iMethod: ULONG,
  pub reserved2: [*mut ::std::os::raw::c_void; 5usize],
  pub rpcFlags: ULONG,
}
#[test]
fn bindgen_test_layout_tagRPCOLEMESSAGE() {
  assert_eq!(
    ::std::mem::size_of::<tagRPCOLEMESSAGE>(),
    80usize,
    concat!("Size of: ", stringify!(tagRPCOLEMESSAGE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagRPCOLEMESSAGE>(),
    8usize,
    concat!("Alignment of ", stringify!(tagRPCOLEMESSAGE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).reserved1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).dataRepresentation as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(dataRepresentation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).Buffer as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(Buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).cbBuffer as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(cbBuffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).iMethod as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(iMethod)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).reserved2 as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).rpcFlags as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(rpcFlags)
    )
  );
}
pub type RPCOLEMESSAGE = tagRPCOLEMESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcChannelBuffer {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IRpcChannelBuffer() {
  assert_eq!(
    ::std::mem::size_of::<IRpcChannelBuffer>(),
    8usize,
    concat!("Size of: ", stringify!(IRpcChannelBuffer))
  );
  assert_eq!(
    ::std::mem::align_of::<IRpcChannelBuffer>(),
    8usize,
    concat!("Alignment of ", stringify!(IRpcChannelBuffer))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SChannelHookCallInfo {
  pub iid: IID,
  pub cbSize: DWORD,
  pub uCausality: GUID,
  pub dwServerPid: DWORD,
  pub iMethod: DWORD,
  pub pObject: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SChannelHookCallInfo() {
  assert_eq!(
    ::std::mem::size_of::<SChannelHookCallInfo>(),
    56usize,
    concat!("Size of: ", stringify!(SChannelHookCallInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<SChannelHookCallInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(SChannelHookCallInfo))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).iid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(iid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).cbSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).uCausality as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(uCausality)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).dwServerPid as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(dwServerPid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).iMethod as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(iMethod)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).pObject as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(pObject)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_SERVICE {
  pub dwAuthnSvc: DWORD,
  pub dwAuthzSvc: DWORD,
  pub pPrincipalName: *mut OLECHAR,
  pub hr: HRESULT,
}
#[test]
fn bindgen_test_layout_tagSOLE_AUTHENTICATION_SERVICE() {
  assert_eq!(
    ::std::mem::size_of::<tagSOLE_AUTHENTICATION_SERVICE>(),
    24usize,
    concat!("Size of: ", stringify!(tagSOLE_AUTHENTICATION_SERVICE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOLE_AUTHENTICATION_SERVICE>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOLE_AUTHENTICATION_SERVICE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).dwAuthnSvc as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(dwAuthnSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).dwAuthzSvc as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(dwAuthzSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).pPrincipalName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(pPrincipalName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).hr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(hr)
    )
  );
}
pub type SOLE_AUTHENTICATION_SERVICE = tagSOLE_AUTHENTICATION_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_INFO {
  pub dwAuthnSvc: DWORD,
  pub dwAuthzSvc: DWORD,
  pub pAuthInfo: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_tagSOLE_AUTHENTICATION_INFO() {
  assert_eq!(
    ::std::mem::size_of::<tagSOLE_AUTHENTICATION_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(tagSOLE_AUTHENTICATION_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOLE_AUTHENTICATION_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOLE_AUTHENTICATION_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_INFO>())).dwAuthnSvc as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_INFO),
      "::",
      stringify!(dwAuthnSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_INFO>())).dwAuthzSvc as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_INFO),
      "::",
      stringify!(dwAuthzSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_INFO>())).pAuthInfo as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_INFO),
      "::",
      stringify!(pAuthInfo)
    )
  );
}
pub type SOLE_AUTHENTICATION_INFO = tagSOLE_AUTHENTICATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_LIST {
  pub cAuthInfo: DWORD,
  pub aAuthInfo: *mut SOLE_AUTHENTICATION_INFO,
}
#[test]
fn bindgen_test_layout_tagSOLE_AUTHENTICATION_LIST() {
  assert_eq!(
    ::std::mem::size_of::<tagSOLE_AUTHENTICATION_LIST>(),
    16usize,
    concat!("Size of: ", stringify!(tagSOLE_AUTHENTICATION_LIST))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOLE_AUTHENTICATION_LIST>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOLE_AUTHENTICATION_LIST))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_LIST>())).cAuthInfo as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_LIST),
      "::",
      stringify!(cAuthInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_LIST>())).aAuthInfo as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_LIST),
      "::",
      stringify!(aAuthInfo)
    )
  );
}
pub type SOLE_AUTHENTICATION_LIST = tagSOLE_AUTHENTICATION_LIST;
pub const tagSTDMSHLFLAGS_SMEXF_SERVER: tagSTDMSHLFLAGS = 1;
pub const tagSTDMSHLFLAGS_SMEXF_HANDLER: tagSTDMSHLFLAGS = 2;
pub type tagSTDMSHLFLAGS = ::std::os::raw::c_int;
pub use self::tagSTDMSHLFLAGS as STDMSHLFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBIND_OPTS {
  pub cbStruct: DWORD,
  pub grfFlags: DWORD,
  pub grfMode: DWORD,
  pub dwTickCountDeadline: DWORD,
}
#[test]
fn bindgen_test_layout_tagBIND_OPTS() {
  assert_eq!(
    ::std::mem::size_of::<tagBIND_OPTS>(),
    16usize,
    concat!("Size of: ", stringify!(tagBIND_OPTS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagBIND_OPTS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagBIND_OPTS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).cbStruct as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(cbStruct)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).grfFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(grfFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).grfMode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(grfMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).dwTickCountDeadline as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(dwTickCountDeadline)
    )
  );
}
pub type BIND_OPTS = tagBIND_OPTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindCtx {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IBindCtx() {
  assert_eq!(
    ::std::mem::size_of::<IBindCtx>(),
    8usize,
    concat!("Size of: ", stringify!(IBindCtx))
  );
  assert_eq!(
    ::std::mem::align_of::<IBindCtx>(),
    8usize,
    concat!("Alignment of ", stringify!(IBindCtx))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumMoniker {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IEnumMoniker() {
  assert_eq!(
    ::std::mem::size_of::<IEnumMoniker>(),
    8usize,
    concat!("Size of: ", stringify!(IEnumMoniker))
  );
  assert_eq!(
    ::std::mem::align_of::<IEnumMoniker>(),
    8usize,
    concat!("Alignment of ", stringify!(IEnumMoniker))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRunningObjectTable {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IRunningObjectTable() {
  assert_eq!(
    ::std::mem::size_of::<IRunningObjectTable>(),
    8usize,
    concat!("Size of: ", stringify!(IRunningObjectTable))
  );
  assert_eq!(
    ::std::mem::align_of::<IRunningObjectTable>(),
    8usize,
    concat!("Alignment of ", stringify!(IRunningObjectTable))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersist {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IPersist() {
  assert_eq!(
    ::std::mem::size_of::<IPersist>(),
    8usize,
    concat!("Size of: ", stringify!(IPersist))
  );
  assert_eq!(
    ::std::mem::align_of::<IPersist>(),
    8usize,
    concat!("Alignment of ", stringify!(IPersist))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersistStream {
  pub _base: IPersist,
}
#[test]
fn bindgen_test_layout_IPersistStream() {
  assert_eq!(
    ::std::mem::size_of::<IPersistStream>(),
    8usize,
    concat!("Size of: ", stringify!(IPersistStream))
  );
  assert_eq!(
    ::std::mem::align_of::<IPersistStream>(),
    8usize,
    concat!("Alignment of ", stringify!(IPersistStream))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMoniker {
  pub _base: IPersistStream,
}
#[test]
fn bindgen_test_layout_IMoniker() {
  assert_eq!(
    ::std::mem::size_of::<IMoniker>(),
    8usize,
    concat!("Size of: ", stringify!(IMoniker))
  );
  assert_eq!(
    ::std::mem::align_of::<IMoniker>(),
    8usize,
    concat!("Alignment of ", stringify!(IMoniker))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATSTG {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IEnumSTATSTG() {
  assert_eq!(
    ::std::mem::size_of::<IEnumSTATSTG>(),
    8usize,
    concat!("Size of: ", stringify!(IEnumSTATSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<IEnumSTATSTG>(),
    8usize,
    concat!("Alignment of ", stringify!(IEnumSTATSTG))
  );
}
pub type SNB = *mut LPOLESTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStorage {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IStorage() {
  assert_eq!(
    ::std::mem::size_of::<IStorage>(),
    8usize,
    concat!("Size of: ", stringify!(IStorage))
  );
  assert_eq!(
    ::std::mem::align_of::<IStorage>(),
    8usize,
    concat!("Alignment of ", stringify!(IStorage))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDVTARGETDEVICE {
  pub tdSize: DWORD,
  pub tdDriverNameOffset: WORD,
  pub tdDeviceNameOffset: WORD,
  pub tdPortNameOffset: WORD,
  pub tdExtDevmodeOffset: WORD,
  pub tdData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagDVTARGETDEVICE() {
  assert_eq!(
    ::std::mem::size_of::<tagDVTARGETDEVICE>(),
    16usize,
    concat!("Size of: ", stringify!(tagDVTARGETDEVICE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDVTARGETDEVICE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagDVTARGETDEVICE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdDriverNameOffset as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdDriverNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdDeviceNameOffset as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdDeviceNameOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdPortNameOffset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdPortNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdExtDevmodeOffset as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdExtDevmodeOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdData as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdData)
    )
  );
}
pub type DVTARGETDEVICE = tagDVTARGETDEVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFORMATETC {
  pub cfFormat: CLIPFORMAT,
  pub ptd: *mut DVTARGETDEVICE,
  pub dwAspect: DWORD,
  pub lindex: LONG,
  pub tymed: DWORD,
}
#[test]
fn bindgen_test_layout_tagFORMATETC() {
  assert_eq!(
    ::std::mem::size_of::<tagFORMATETC>(),
    32usize,
    concat!("Size of: ", stringify!(tagFORMATETC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagFORMATETC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagFORMATETC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).cfFormat as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(cfFormat)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).ptd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(ptd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).dwAspect as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(dwAspect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).lindex as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(lindex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).tymed as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(tymed)
    )
  );
}
pub type FORMATETC = tagFORMATETC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATDATA {
  pub formatetc: FORMATETC,
  pub advf: DWORD,
  pub pAdvSink: *mut IAdviseSink,
  pub dwConnection: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTATDATA() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATDATA>(),
    56usize,
    concat!("Size of: ", stringify!(tagSTATDATA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATDATA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTATDATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).formatetc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(formatetc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).advf as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(advf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).pAdvSink as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(pAdvSink)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).dwConnection as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(dwConnection)
    )
  );
}
pub type STATDATA = tagSTATDATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTGMEDIUM {
  pub tymed: DWORD,
  pub __bindgen_anon_1: tagSTGMEDIUM__bindgen_ty_1,
  pub pUnkForRelease: *mut IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagSTGMEDIUM__bindgen_ty_1 {
  pub hBitmap: HBITMAP,
  pub hMetaFilePict: HMETAFILEPICT,
  pub hEnhMetaFile: HENHMETAFILE,
  pub hGlobal: HGLOBAL,
  pub lpszFileName: LPOLESTR,
  pub pstm: *mut IStream,
  pub pstg: *mut IStorage,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagSTGMEDIUM__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagSTGMEDIUM__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTGMEDIUM__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTGMEDIUM__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTGMEDIUM__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hBitmap as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hBitmap)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hMetaFilePict as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hMetaFilePict)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hEnhMetaFile as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hEnhMetaFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hGlobal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hGlobal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).lpszFileName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(lpszFileName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).pstm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(pstm)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).pstg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(pstg)
    )
  );
}
#[test]
fn bindgen_test_layout_tagSTGMEDIUM() {
  assert_eq!(
    ::std::mem::size_of::<tagSTGMEDIUM>(),
    24usize,
    concat!("Size of: ", stringify!(tagSTGMEDIUM))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTGMEDIUM>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTGMEDIUM))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM>())).tymed as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM),
      "::",
      stringify!(tymed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM>())).pUnkForRelease as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM),
      "::",
      stringify!(pUnkForRelease)
    )
  );
}
pub type uSTGMEDIUM = tagSTGMEDIUM;
pub type STGMEDIUM = uSTGMEDIUM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAdviseSink {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IAdviseSink() {
  assert_eq!(
    ::std::mem::size_of::<IAdviseSink>(),
    8usize,
    concat!("Size of: ", stringify!(IAdviseSink))
  );
  assert_eq!(
    ::std::mem::align_of::<IAdviseSink>(),
    8usize,
    concat!("Alignment of ", stringify!(IAdviseSink))
  );
}
pub const tagSERVERCALL_SERVERCALL_ISHANDLED: tagSERVERCALL = 0;
pub const tagSERVERCALL_SERVERCALL_REJECTED: tagSERVERCALL = 1;
pub const tagSERVERCALL_SERVERCALL_RETRYLATER: tagSERVERCALL = 2;
pub type tagSERVERCALL = ::std::os::raw::c_int;
pub use self::tagSERVERCALL as SERVERCALL;
extern "C" {
  pub fn SNB_UserSize(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut SNB,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn SNB_UserMarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserUnmarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut SNB);
}
extern "C" {
  pub fn STGMEDIUM_UserSize(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut STGMEDIUM,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn STGMEDIUM_UserMarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserUnmarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut STGMEDIUM);
}
extern "C" {
  pub fn SNB_UserSize64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut SNB,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn SNB_UserMarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserUnmarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut SNB);
}
extern "C" {
  pub fn STGMEDIUM_UserSize64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut STGMEDIUM,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn STGMEDIUM_UserMarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserUnmarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut STGMEDIUM);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAYBOUND {
  pub cElements: ULONG,
  pub lLbound: LONG,
}
#[test]
fn bindgen_test_layout_tagSAFEARRAYBOUND() {
  assert_eq!(
    ::std::mem::size_of::<tagSAFEARRAYBOUND>(),
    8usize,
    concat!("Size of: ", stringify!(tagSAFEARRAYBOUND))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSAFEARRAYBOUND>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSAFEARRAYBOUND))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAYBOUND>())).cElements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAYBOUND),
      "::",
      stringify!(cElements)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAYBOUND>())).lLbound as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAYBOUND),
      "::",
      stringify!(lLbound)
    )
  );
}
pub type SAFEARRAYBOUND = tagSAFEARRAYBOUND;
pub type wireVARIANT = *mut _wireVARIANT;
pub type wireBRECORD = *mut _wireBRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_BSTR {
  pub Size: ULONG,
  pub aBstr: *mut wireBSTR,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_BSTR() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_BSTR>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_BSTR))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_BSTR>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_BSTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BSTR>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BSTR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BSTR>())).aBstr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BSTR),
      "::",
      stringify!(aBstr)
    )
  );
}
pub type SAFEARR_BSTR = _wireSAFEARR_BSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_UNKNOWN {
  pub Size: ULONG,
  pub apUnknown: *mut *mut IUnknown,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_UNKNOWN() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_UNKNOWN>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_UNKNOWN))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_UNKNOWN>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_UNKNOWN))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_UNKNOWN>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_UNKNOWN),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_UNKNOWN>())).apUnknown as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_UNKNOWN),
      "::",
      stringify!(apUnknown)
    )
  );
}
pub type SAFEARR_UNKNOWN = _wireSAFEARR_UNKNOWN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_DISPATCH {
  pub Size: ULONG,
  pub apDispatch: *mut *mut IDispatch,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_DISPATCH() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_DISPATCH>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_DISPATCH))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_DISPATCH>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_DISPATCH))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_DISPATCH>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_DISPATCH),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_DISPATCH>())).apDispatch as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_DISPATCH),
      "::",
      stringify!(apDispatch)
    )
  );
}
pub type SAFEARR_DISPATCH = _wireSAFEARR_DISPATCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_VARIANT {
  pub Size: ULONG,
  pub aVariant: *mut wireVARIANT,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_VARIANT() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_VARIANT>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_VARIANT))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_VARIANT>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_VARIANT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_VARIANT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_VARIANT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_VARIANT>())).aVariant as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_VARIANT),
      "::",
      stringify!(aVariant)
    )
  );
}
pub type SAFEARR_VARIANT = _wireSAFEARR_VARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_BRECORD {
  pub Size: ULONG,
  pub aRecord: *mut wireBRECORD,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_BRECORD() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_BRECORD>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_BRECORD))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_BRECORD>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_BRECORD))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BRECORD>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BRECORD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BRECORD>())).aRecord as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BRECORD),
      "::",
      stringify!(aRecord)
    )
  );
}
pub type SAFEARR_BRECORD = _wireSAFEARR_BRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_HAVEIID {
  pub Size: ULONG,
  pub apUnknown: *mut *mut IUnknown,
  pub iid: IID,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_HAVEIID() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_HAVEIID>(),
    32usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_HAVEIID))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_HAVEIID>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_HAVEIID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_HAVEIID>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_HAVEIID),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_HAVEIID>())).apUnknown as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_HAVEIID),
      "::",
      stringify!(apUnknown)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_HAVEIID>())).iid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_HAVEIID),
      "::",
      stringify!(iid)
    )
  );
}
pub type SAFEARR_HAVEIID = _wireSAFEARR_HAVEIID;
pub const tagSF_TYPE_SF_ERROR: tagSF_TYPE = 10;
pub const tagSF_TYPE_SF_I1: tagSF_TYPE = 16;
pub const tagSF_TYPE_SF_I2: tagSF_TYPE = 2;
pub const tagSF_TYPE_SF_I4: tagSF_TYPE = 3;
pub const tagSF_TYPE_SF_I8: tagSF_TYPE = 20;
pub const tagSF_TYPE_SF_BSTR: tagSF_TYPE = 8;
pub const tagSF_TYPE_SF_UNKNOWN: tagSF_TYPE = 13;
pub const tagSF_TYPE_SF_DISPATCH: tagSF_TYPE = 9;
pub const tagSF_TYPE_SF_VARIANT: tagSF_TYPE = 12;
pub const tagSF_TYPE_SF_RECORD: tagSF_TYPE = 36;
pub const tagSF_TYPE_SF_HAVEIID: tagSF_TYPE = 32781;
pub type tagSF_TYPE = ::std::os::raw::c_int;
pub use self::tagSF_TYPE as SF_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireSAFEARRAY_UNION {
  pub sfType: ULONG,
  pub u: _wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001 {
  pub BstrStr: SAFEARR_BSTR,
  pub UnknownStr: SAFEARR_UNKNOWN,
  pub DispatchStr: SAFEARR_DISPATCH,
  pub VariantStr: SAFEARR_VARIANT,
  pub RecordStr: SAFEARR_BRECORD,
  pub HaveIidStr: SAFEARR_HAVEIID,
  pub ByteStr: BYTE_SIZEDARR,
  pub WordStr: WORD_SIZEDARR,
  pub LongStr: DWORD_SIZEDARR,
  pub HyperStr: HYPER_SIZEDARR,
  _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).BstrStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(BstrStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).UnknownStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(UnknownStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).DispatchStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(DispatchStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).VariantStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(VariantStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).RecordStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(RecordStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).HaveIidStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(HaveIidStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).ByteStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(ByteStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).WordStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(WordStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).LongStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(LongStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).HyperStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(HyperStr)
    )
  );
}
#[test]
fn bindgen_test_layout__wireSAFEARRAY_UNION() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARRAY_UNION>(),
    40usize,
    concat!("Size of: ", stringify!(_wireSAFEARRAY_UNION))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARRAY_UNION>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARRAY_UNION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY_UNION>())).sfType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION),
      "::",
      stringify!(sfType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY_UNION>())).u as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION),
      "::",
      stringify!(u)
    )
  );
}
pub type SAFEARRAYUNION = _wireSAFEARRAY_UNION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireSAFEARRAY {
  pub cDims: USHORT,
  pub fFeatures: USHORT,
  pub cbElements: ULONG,
  pub cLocks: ULONG,
  pub uArrayStructs: SAFEARRAYUNION,
  pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
#[test]
fn bindgen_test_layout__wireSAFEARRAY() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARRAY>(),
    64usize,
    concat!("Size of: ", stringify!(_wireSAFEARRAY))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARRAY>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARRAY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).cDims as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(cDims)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).fFeatures as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(fFeatures)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).cbElements as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(cbElements)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).cLocks as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(cLocks)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).uArrayStructs as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(uArrayStructs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).rgsabound as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(rgsabound)
    )
  );
}
pub type wireSAFEARRAY = *mut _wireSAFEARRAY;
pub type wirePSAFEARRAY = *mut wireSAFEARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAY {
  pub cDims: USHORT,
  pub fFeatures: USHORT,
  pub cbElements: ULONG,
  pub cLocks: ULONG,
  pub pvData: PVOID,
  pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
#[test]
fn bindgen_test_layout_tagSAFEARRAY() {
  assert_eq!(
    ::std::mem::size_of::<tagSAFEARRAY>(),
    32usize,
    concat!("Size of: ", stringify!(tagSAFEARRAY))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSAFEARRAY>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSAFEARRAY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).cDims as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(cDims)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).fFeatures as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(fFeatures)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).cbElements as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(cbElements)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).cLocks as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(cLocks)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).pvData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(pvData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).rgsabound as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(rgsabound)
    )
  );
}
pub type SAFEARRAY = tagSAFEARRAY;
pub type VARIANT = tagVARIANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT {
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1 {
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1,
  pub decVal: DECIMAL,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1 {
  pub vt: VARTYPE,
  pub wReserved1: WORD,
  pub wReserved2: WORD,
  pub wReserved3: WORD,
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub llVal: LONGLONG,
  pub lVal: LONG,
  pub bVal: BYTE,
  pub iVal: SHORT,
  pub fltVal: FLOAT,
  pub dblVal: DOUBLE,
  pub boolVal: VARIANT_BOOL,
  pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
  pub scode: SCODE,
  pub cyVal: CY,
  pub date: DATE,
  pub bstrVal: BSTR,
  pub punkVal: *mut IUnknown,
  pub pdispVal: *mut IDispatch,
  pub parray: *mut SAFEARRAY,
  pub pbVal: *mut BYTE,
  pub piVal: *mut SHORT,
  pub plVal: *mut LONG,
  pub pllVal: *mut LONGLONG,
  pub pfltVal: *mut FLOAT,
  pub pdblVal: *mut DOUBLE,
  pub pboolVal: *mut VARIANT_BOOL,
  pub __OBSOLETE__VARIANT_PBOOL: *mut VARIANT_BOOL,
  pub pscode: *mut SCODE,
  pub pcyVal: *mut CY,
  pub pdate: *mut DATE,
  pub pbstrVal: *mut BSTR,
  pub ppunkVal: *mut *mut IUnknown,
  pub ppdispVal: *mut *mut IDispatch,
  pub pparray: *mut *mut SAFEARRAY,
  pub pvarVal: *mut VARIANT,
  pub byref: PVOID,
  pub cVal: CHAR,
  pub uiVal: USHORT,
  pub ulVal: ULONG,
  pub ullVal: ULONGLONG,
  pub intVal: INT,
  pub uintVal: UINT,
  pub pdecVal: *mut DECIMAL,
  pub pcVal: *mut CHAR,
  pub puiVal: *mut USHORT,
  pub pulVal: *mut ULONG,
  pub pullVal: *mut ULONGLONG,
  pub pintVal: *mut INT,
  pub puintVal: *mut UINT,
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub pvRecord: PVOID,
  pub pRecInfo: *mut IRecordInfo,
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .pvRecord as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pvRecord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .pRecInfo as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pRecInfo)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).llVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(llVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).lVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(lVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).bVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(bVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).iVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(iVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).fltVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(fltVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).dblVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dblVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).boolVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(boolVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .__OBSOLETE__VARIANT_BOOL as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(__OBSOLETE__VARIANT_BOOL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).scode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(scode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).cyVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(cyVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).date
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(date)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).bstrVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(bstrVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).punkVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(punkVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdispVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdispVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).parray
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(parray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pbVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pbVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).piVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(piVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).plVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(plVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pllVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pllVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pfltVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pfltVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdblVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdblVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pboolVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pboolVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .__OBSOLETE__VARIANT_PBOOL as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(__OBSOLETE__VARIANT_PBOOL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pscode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pscode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pcyVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pcyVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdate
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pbstrVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pbstrVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ppunkVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ppunkVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ppdispVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ppdispVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pparray
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pparray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pvarVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pvarVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).byref
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(byref)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).cVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(cVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).uiVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uiVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ulVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ulVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ullVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ullVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).intVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(intVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).uintVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uintVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdecVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdecVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pcVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pcVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).puiVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(puiVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pulVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pulVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pullVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pullVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pintVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pintVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).puintVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(puintVal)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).vt as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(vt)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).wReserved1 as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).wReserved2 as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).wReserved3 as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved3)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(tagVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1>())).decVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1),
      "::",
      stringify!(decVal)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT>(),
    24usize,
    concat!("Size of: ", stringify!(tagVARIANT))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARIANT))
  );
}
pub type VARIANTARG = VARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireBRECORD {
  pub fFlags: ULONG,
  pub clSize: ULONG,
  pub pRecInfo: *mut IRecordInfo,
  pub pRecord: *mut byte,
}
#[test]
fn bindgen_test_layout__wireBRECORD() {
  assert_eq!(
    ::std::mem::size_of::<_wireBRECORD>(),
    24usize,
    concat!("Size of: ", stringify!(_wireBRECORD))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireBRECORD>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireBRECORD))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).fFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).clSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).pRecInfo as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(pRecInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).pRecord as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(pRecord)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireVARIANT {
  pub clSize: DWORD,
  pub rpcReserved: DWORD,
  pub vt: USHORT,
  pub wReserved1: USHORT,
  pub wReserved2: USHORT,
  pub wReserved3: USHORT,
  pub __bindgen_anon_1: _wireVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _wireVARIANT__bindgen_ty_1 {
  pub llVal: LONGLONG,
  pub lVal: LONG,
  pub bVal: BYTE,
  pub iVal: SHORT,
  pub fltVal: FLOAT,
  pub dblVal: DOUBLE,
  pub boolVal: VARIANT_BOOL,
  pub scode: SCODE,
  pub cyVal: CY,
  pub date: DATE,
  pub bstrVal: wireBSTR,
  pub punkVal: *mut IUnknown,
  pub pdispVal: *mut IDispatch,
  pub parray: wirePSAFEARRAY,
  pub brecVal: wireBRECORD,
  pub pbVal: *mut BYTE,
  pub piVal: *mut SHORT,
  pub plVal: *mut LONG,
  pub pllVal: *mut LONGLONG,
  pub pfltVal: *mut FLOAT,
  pub pdblVal: *mut DOUBLE,
  pub pboolVal: *mut VARIANT_BOOL,
  pub pscode: *mut SCODE,
  pub pcyVal: *mut CY,
  pub pdate: *mut DATE,
  pub pbstrVal: *mut wireBSTR,
  pub ppunkVal: *mut *mut IUnknown,
  pub ppdispVal: *mut *mut IDispatch,
  pub pparray: *mut wirePSAFEARRAY,
  pub pvarVal: *mut wireVARIANT,
  pub cVal: CHAR,
  pub uiVal: USHORT,
  pub ulVal: ULONG,
  pub ullVal: ULONGLONG,
  pub intVal: INT,
  pub uintVal: UINT,
  pub decVal: DECIMAL,
  pub pdecVal: *mut DECIMAL,
  pub pcVal: *mut CHAR,
  pub puiVal: *mut USHORT,
  pub pulVal: *mut ULONG,
  pub pullVal: *mut ULONGLONG,
  pub pintVal: *mut INT,
  pub puintVal: *mut UINT,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__wireVARIANT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_wireVARIANT__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_wireVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireVARIANT__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).llVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(llVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).lVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(lVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).bVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(bVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).iVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(iVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).fltVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(fltVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).dblVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(dblVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).boolVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(boolVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).scode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(scode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).cyVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(cyVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).date as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(date)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).bstrVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(bstrVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).punkVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(punkVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdispVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdispVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).parray as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(parray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).brecVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(brecVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pbVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pbVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).piVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(piVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).plVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(plVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pllVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pllVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pfltVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pfltVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdblVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdblVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pboolVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pboolVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pscode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pscode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pcyVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pcyVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdate as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pbstrVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pbstrVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ppunkVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ppunkVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ppdispVal as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ppdispVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pparray as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pparray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pvarVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pvarVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).cVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(cVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).uiVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(uiVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ulVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ulVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ullVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ullVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).intVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(intVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).uintVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(uintVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).decVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(decVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdecVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdecVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pcVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pcVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).puiVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(puiVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pulVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pulVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pullVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pullVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pintVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pintVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).puintVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(puintVal)
    )
  );
}
#[test]
fn bindgen_test_layout__wireVARIANT() {
  assert_eq!(
    ::std::mem::size_of::<_wireVARIANT>(),
    32usize,
    concat!("Size of: ", stringify!(_wireVARIANT))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireVARIANT>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireVARIANT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).rpcReserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(rpcReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).vt as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(vt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).wReserved1 as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(wReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).wReserved2 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(wReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).wReserved3 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(wReserved3)
    )
  );
}
pub type DISPID = LONG;
pub type MEMBERID = DISPID;
pub type HREFTYPE = DWORD;
pub const tagTYPEKIND_TKIND_ENUM: tagTYPEKIND = 0;
pub const tagTYPEKIND_TKIND_RECORD: tagTYPEKIND = 1;
pub const tagTYPEKIND_TKIND_MODULE: tagTYPEKIND = 2;
pub const tagTYPEKIND_TKIND_INTERFACE: tagTYPEKIND = 3;
pub const tagTYPEKIND_TKIND_DISPATCH: tagTYPEKIND = 4;
pub const tagTYPEKIND_TKIND_COCLASS: tagTYPEKIND = 5;
pub const tagTYPEKIND_TKIND_ALIAS: tagTYPEKIND = 6;
pub const tagTYPEKIND_TKIND_UNION: tagTYPEKIND = 7;
pub const tagTYPEKIND_TKIND_MAX: tagTYPEKIND = 8;
pub type tagTYPEKIND = ::std::os::raw::c_int;
pub use self::tagTYPEKIND as TYPEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEDESC {
  pub __bindgen_anon_1: tagTYPEDESC__bindgen_ty_1,
  pub vt: VARTYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagTYPEDESC__bindgen_ty_1 {
  pub lptdesc: *mut tagTYPEDESC,
  pub lpadesc: *mut tagARRAYDESC,
  pub hreftype: HREFTYPE,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagTYPEDESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagTYPEDESC__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagTYPEDESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTYPEDESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTYPEDESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC__bindgen_ty_1>())).lptdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC__bindgen_ty_1),
      "::",
      stringify!(lptdesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC__bindgen_ty_1>())).lpadesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC__bindgen_ty_1),
      "::",
      stringify!(lpadesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC__bindgen_ty_1>())).hreftype as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC__bindgen_ty_1),
      "::",
      stringify!(hreftype)
    )
  );
}
#[test]
fn bindgen_test_layout_tagTYPEDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagTYPEDESC>(),
    16usize,
    concat!("Size of: ", stringify!(tagTYPEDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTYPEDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTYPEDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC>())).vt as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC),
      "::",
      stringify!(vt)
    )
  );
}
pub type TYPEDESC = tagTYPEDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagARRAYDESC {
  pub tdescElem: TYPEDESC,
  pub cDims: USHORT,
  pub rgbounds: [SAFEARRAYBOUND; 1usize],
}
#[test]
fn bindgen_test_layout_tagARRAYDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagARRAYDESC>(),
    32usize,
    concat!("Size of: ", stringify!(tagARRAYDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagARRAYDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagARRAYDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagARRAYDESC>())).tdescElem as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagARRAYDESC),
      "::",
      stringify!(tdescElem)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagARRAYDESC>())).cDims as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagARRAYDESC),
      "::",
      stringify!(cDims)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagARRAYDESC>())).rgbounds as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagARRAYDESC),
      "::",
      stringify!(rgbounds)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPARAMDESCEX {
  pub cBytes: ULONG,
  pub varDefaultValue: VARIANTARG,
}
#[test]
fn bindgen_test_layout_tagPARAMDESCEX() {
  assert_eq!(
    ::std::mem::size_of::<tagPARAMDESCEX>(),
    32usize,
    concat!("Size of: ", stringify!(tagPARAMDESCEX))
  );
  assert_eq!(
    ::std::mem::align_of::<tagPARAMDESCEX>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPARAMDESCEX))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESCEX>())).cBytes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESCEX),
      "::",
      stringify!(cBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESCEX>())).varDefaultValue as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESCEX),
      "::",
      stringify!(varDefaultValue)
    )
  );
}
pub type LPPARAMDESCEX = *mut tagPARAMDESCEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPARAMDESC {
  pub pparamdescex: LPPARAMDESCEX,
  pub wParamFlags: USHORT,
}
#[test]
fn bindgen_test_layout_tagPARAMDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagPARAMDESC>(),
    16usize,
    concat!("Size of: ", stringify!(tagPARAMDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagPARAMDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPARAMDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESC>())).pparamdescex as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESC),
      "::",
      stringify!(pparamdescex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESC>())).wParamFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESC),
      "::",
      stringify!(wParamFlags)
    )
  );
}
pub type PARAMDESC = tagPARAMDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIDLDESC {
  pub dwReserved: ULONG_PTR,
  pub wIDLFlags: USHORT,
}
#[test]
fn bindgen_test_layout_tagIDLDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagIDLDESC>(),
    16usize,
    concat!("Size of: ", stringify!(tagIDLDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagIDLDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagIDLDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagIDLDESC>())).dwReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIDLDESC),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagIDLDESC>())).wIDLFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIDLDESC),
      "::",
      stringify!(wIDLFlags)
    )
  );
}
pub type IDLDESC = tagIDLDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagELEMDESC {
  pub tdesc: TYPEDESC,
  pub __bindgen_anon_1: tagELEMDESC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagELEMDESC__bindgen_ty_1 {
  pub idldesc: IDLDESC,
  pub paramdesc: PARAMDESC,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_tagELEMDESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagELEMDESC__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(tagELEMDESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagELEMDESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagELEMDESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagELEMDESC__bindgen_ty_1>())).idldesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagELEMDESC__bindgen_ty_1),
      "::",
      stringify!(idldesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagELEMDESC__bindgen_ty_1>())).paramdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagELEMDESC__bindgen_ty_1),
      "::",
      stringify!(paramdesc)
    )
  );
}
#[test]
fn bindgen_test_layout_tagELEMDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagELEMDESC>(),
    32usize,
    concat!("Size of: ", stringify!(tagELEMDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagELEMDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagELEMDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagELEMDESC>())).tdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagELEMDESC),
      "::",
      stringify!(tdesc)
    )
  );
}
pub type ELEMDESC = tagELEMDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEATTR {
  pub guid: GUID,
  pub lcid: LCID,
  pub dwReserved: DWORD,
  pub memidConstructor: MEMBERID,
  pub memidDestructor: MEMBERID,
  pub lpstrSchema: LPOLESTR,
  pub cbSizeInstance: ULONG,
  pub typekind: TYPEKIND,
  pub cFuncs: WORD,
  pub cVars: WORD,
  pub cImplTypes: WORD,
  pub cbSizeVft: WORD,
  pub cbAlignment: WORD,
  pub wTypeFlags: WORD,
  pub wMajorVerNum: WORD,
  pub wMinorVerNum: WORD,
  pub tdescAlias: TYPEDESC,
  pub idldescType: IDLDESC,
}
#[test]
fn bindgen_test_layout_tagTYPEATTR() {
  assert_eq!(
    ::std::mem::size_of::<tagTYPEATTR>(),
    96usize,
    concat!("Size of: ", stringify!(tagTYPEATTR))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTYPEATTR>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTYPEATTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).guid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(guid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).lcid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(lcid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).dwReserved as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).memidConstructor as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(memidConstructor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).memidDestructor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(memidDestructor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).lpstrSchema as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(lpstrSchema)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cbSizeInstance as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cbSizeInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).typekind as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(typekind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cFuncs as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cFuncs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cVars as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cVars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cImplTypes as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cImplTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cbSizeVft as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cbSizeVft)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cbAlignment as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cbAlignment)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).wTypeFlags as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(wTypeFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).wMajorVerNum as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(wMajorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).wMinorVerNum as *const _ as usize },
    62usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(wMinorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).tdescAlias as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(tdescAlias)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).idldescType as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(idldescType)
    )
  );
}
pub type TYPEATTR = tagTYPEATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDISPPARAMS {
  pub rgvarg: *mut VARIANTARG,
  pub rgdispidNamedArgs: *mut DISPID,
  pub cArgs: UINT,
  pub cNamedArgs: UINT,
}
#[test]
fn bindgen_test_layout_tagDISPPARAMS() {
  assert_eq!(
    ::std::mem::size_of::<tagDISPPARAMS>(),
    24usize,
    concat!("Size of: ", stringify!(tagDISPPARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDISPPARAMS>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDISPPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).rgvarg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(rgvarg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).rgdispidNamedArgs as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(rgdispidNamedArgs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).cArgs as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(cArgs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).cNamedArgs as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(cNamedArgs)
    )
  );
}
pub type DISPPARAMS = tagDISPPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXCEPINFO {
  pub wCode: WORD,
  pub wReserved: WORD,
  pub bstrSource: BSTR,
  pub bstrDescription: BSTR,
  pub bstrHelpFile: BSTR,
  pub dwHelpContext: DWORD,
  pub pvReserved: PVOID,
  pub pfnDeferredFillIn:
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut tagEXCEPINFO) -> HRESULT>,
  pub scode: SCODE,
}
#[test]
fn bindgen_test_layout_tagEXCEPINFO() {
  assert_eq!(
    ::std::mem::size_of::<tagEXCEPINFO>(),
    64usize,
    concat!("Size of: ", stringify!(tagEXCEPINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagEXCEPINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagEXCEPINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).wCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(wCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).wReserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(wReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).bstrSource as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(bstrSource)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).bstrDescription as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(bstrDescription)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).bstrHelpFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(bstrHelpFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).dwHelpContext as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(dwHelpContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).pvReserved as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(pvReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).pfnDeferredFillIn as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(pfnDeferredFillIn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).scode as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(scode)
    )
  );
}
pub type EXCEPINFO = tagEXCEPINFO;
pub const tagCALLCONV_CC_FASTCALL: tagCALLCONV = 0;
pub const tagCALLCONV_CC_CDECL: tagCALLCONV = 1;
pub const tagCALLCONV_CC_MSCPASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_PASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_MACPASCAL: tagCALLCONV = 3;
pub const tagCALLCONV_CC_STDCALL: tagCALLCONV = 4;
pub const tagCALLCONV_CC_FPFASTCALL: tagCALLCONV = 5;
pub const tagCALLCONV_CC_SYSCALL: tagCALLCONV = 6;
pub const tagCALLCONV_CC_MPWCDECL: tagCALLCONV = 7;
pub const tagCALLCONV_CC_MPWPASCAL: tagCALLCONV = 8;
pub const tagCALLCONV_CC_MAX: tagCALLCONV = 9;
pub type tagCALLCONV = ::std::os::raw::c_int;
pub use self::tagCALLCONV as CALLCONV;
pub const tagFUNCKIND_FUNC_VIRTUAL: tagFUNCKIND = 0;
pub const tagFUNCKIND_FUNC_PUREVIRTUAL: tagFUNCKIND = 1;
pub const tagFUNCKIND_FUNC_NONVIRTUAL: tagFUNCKIND = 2;
pub const tagFUNCKIND_FUNC_STATIC: tagFUNCKIND = 3;
pub const tagFUNCKIND_FUNC_DISPATCH: tagFUNCKIND = 4;
pub type tagFUNCKIND = ::std::os::raw::c_int;
pub use self::tagFUNCKIND as FUNCKIND;
pub const tagINVOKEKIND_INVOKE_FUNC: tagINVOKEKIND = 1;
pub const tagINVOKEKIND_INVOKE_PROPERTYGET: tagINVOKEKIND = 2;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUT: tagINVOKEKIND = 4;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUTREF: tagINVOKEKIND = 8;
pub type tagINVOKEKIND = ::std::os::raw::c_int;
pub use self::tagINVOKEKIND as INVOKEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagFUNCDESC {
  pub memid: MEMBERID,
  pub lprgscode: *mut SCODE,
  pub lprgelemdescParam: *mut ELEMDESC,
  pub funckind: FUNCKIND,
  pub invkind: INVOKEKIND,
  pub callconv: CALLCONV,
  pub cParams: SHORT,
  pub cParamsOpt: SHORT,
  pub oVft: SHORT,
  pub cScodes: SHORT,
  pub elemdescFunc: ELEMDESC,
  pub wFuncFlags: WORD,
}
#[test]
fn bindgen_test_layout_tagFUNCDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagFUNCDESC>(),
    88usize,
    concat!("Size of: ", stringify!(tagFUNCDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagFUNCDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagFUNCDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).memid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(memid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).lprgscode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(lprgscode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).lprgelemdescParam as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(lprgelemdescParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).funckind as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(funckind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).invkind as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(invkind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).callconv as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(callconv)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).cParams as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(cParams)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).cParamsOpt as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(cParamsOpt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).oVft as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(oVft)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).cScodes as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(cScodes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).elemdescFunc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(elemdescFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).wFuncFlags as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(wFuncFlags)
    )
  );
}
pub type FUNCDESC = tagFUNCDESC;
pub const tagVARKIND_VAR_PERINSTANCE: tagVARKIND = 0;
pub const tagVARKIND_VAR_STATIC: tagVARKIND = 1;
pub const tagVARKIND_VAR_CONST: tagVARKIND = 2;
pub const tagVARKIND_VAR_DISPATCH: tagVARKIND = 3;
pub type tagVARKIND = ::std::os::raw::c_int;
pub use self::tagVARKIND as VARKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARDESC {
  pub memid: MEMBERID,
  pub lpstrSchema: LPOLESTR,
  pub __bindgen_anon_1: tagVARDESC__bindgen_ty_1,
  pub elemdescVar: ELEMDESC,
  pub wVarFlags: WORD,
  pub varkind: VARKIND,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARDESC__bindgen_ty_1 {
  pub oInst: ULONG,
  pub lpvarValue: *mut VARIANT,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagVARDESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARDESC__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagVARDESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARDESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARDESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC__bindgen_ty_1>())).oInst as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC__bindgen_ty_1),
      "::",
      stringify!(oInst)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC__bindgen_ty_1>())).lpvarValue as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC__bindgen_ty_1),
      "::",
      stringify!(lpvarValue)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagVARDESC>(),
    64usize,
    concat!("Size of: ", stringify!(tagVARDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).memid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(memid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).lpstrSchema as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(lpstrSchema)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).elemdescVar as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(elemdescVar)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).wVarFlags as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(wVarFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).varkind as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(varkind)
    )
  );
}
pub type VARDESC = tagVARDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDispatch {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IDispatch() {
  assert_eq!(
    ::std::mem::size_of::<IDispatch>(),
    8usize,
    concat!("Size of: ", stringify!(IDispatch))
  );
  assert_eq!(
    ::std::mem::align_of::<IDispatch>(),
    8usize,
    concat!("Alignment of ", stringify!(IDispatch))
  );
}
pub const tagDESCKIND_DESCKIND_NONE: tagDESCKIND = 0;
pub const tagDESCKIND_DESCKIND_FUNCDESC: tagDESCKIND = 1;
pub const tagDESCKIND_DESCKIND_VARDESC: tagDESCKIND = 2;
pub const tagDESCKIND_DESCKIND_TYPECOMP: tagDESCKIND = 3;
pub const tagDESCKIND_DESCKIND_IMPLICITAPPOBJ: tagDESCKIND = 4;
pub const tagDESCKIND_DESCKIND_MAX: tagDESCKIND = 5;
pub type tagDESCKIND = ::std::os::raw::c_int;
pub use self::tagDESCKIND as DESCKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagBINDPTR {
  pub lpfuncdesc: *mut FUNCDESC,
  pub lpvardesc: *mut VARDESC,
  pub lptcomp: *mut ITypeComp,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagBINDPTR() {
  assert_eq!(
    ::std::mem::size_of::<tagBINDPTR>(),
    8usize,
    concat!("Size of: ", stringify!(tagBINDPTR))
  );
  assert_eq!(
    ::std::mem::align_of::<tagBINDPTR>(),
    8usize,
    concat!("Alignment of ", stringify!(tagBINDPTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBINDPTR>())).lpfuncdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBINDPTR),
      "::",
      stringify!(lpfuncdesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBINDPTR>())).lpvardesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBINDPTR),
      "::",
      stringify!(lpvardesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBINDPTR>())).lptcomp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBINDPTR),
      "::",
      stringify!(lptcomp)
    )
  );
}
pub type BINDPTR = tagBINDPTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeComp {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ITypeComp() {
  assert_eq!(
    ::std::mem::size_of::<ITypeComp>(),
    8usize,
    concat!("Size of: ", stringify!(ITypeComp))
  );
  assert_eq!(
    ::std::mem::align_of::<ITypeComp>(),
    8usize,
    concat!("Alignment of ", stringify!(ITypeComp))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeInfo {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ITypeInfo() {
  assert_eq!(
    ::std::mem::size_of::<ITypeInfo>(),
    8usize,
    concat!("Size of: ", stringify!(ITypeInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<ITypeInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(ITypeInfo))
  );
}
pub const tagSYSKIND_SYS_WIN16: tagSYSKIND = 0;
pub const tagSYSKIND_SYS_WIN32: tagSYSKIND = 1;
pub const tagSYSKIND_SYS_MAC: tagSYSKIND = 2;
pub const tagSYSKIND_SYS_WIN64: tagSYSKIND = 3;
pub type tagSYSKIND = ::std::os::raw::c_int;
pub use self::tagSYSKIND as SYSKIND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTLIBATTR {
  pub guid: GUID,
  pub lcid: LCID,
  pub syskind: SYSKIND,
  pub wMajorVerNum: WORD,
  pub wMinorVerNum: WORD,
  pub wLibFlags: WORD,
}
#[test]
fn bindgen_test_layout_tagTLIBATTR() {
  assert_eq!(
    ::std::mem::size_of::<tagTLIBATTR>(),
    32usize,
    concat!("Size of: ", stringify!(tagTLIBATTR))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTLIBATTR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTLIBATTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).guid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(guid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).lcid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(lcid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).syskind as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(syskind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).wMajorVerNum as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(wMajorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).wMinorVerNum as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(wMinorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).wLibFlags as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(wLibFlags)
    )
  );
}
pub type TLIBATTR = tagTLIBATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLib {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ITypeLib() {
  assert_eq!(
    ::std::mem::size_of::<ITypeLib>(),
    8usize,
    concat!("Size of: ", stringify!(ITypeLib))
  );
  assert_eq!(
    ::std::mem::align_of::<ITypeLib>(),
    8usize,
    concat!("Alignment of ", stringify!(ITypeLib))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRecordInfo {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IRecordInfo() {
  assert_eq!(
    ::std::mem::size_of::<IRecordInfo>(),
    8usize,
    concat!("Size of: ", stringify!(IRecordInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<IRecordInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(IRecordInfo))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATPROPSTG {
  pub lpwstrName: LPOLESTR,
  pub propid: PROPID,
  pub vt: VARTYPE,
}
#[test]
fn bindgen_test_layout_tagSTATPROPSTG() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATPROPSTG>(),
    16usize,
    concat!("Size of: ", stringify!(tagSTATPROPSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATPROPSTG>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTATPROPSTG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSTG>())).lpwstrName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSTG),
      "::",
      stringify!(lpwstrName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSTG>())).propid as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSTG),
      "::",
      stringify!(propid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSTG>())).vt as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSTG),
      "::",
      stringify!(vt)
    )
  );
}
pub type STATPROPSTG = tagSTATPROPSTG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATPROPSETSTG {
  pub fmtid: FMTID,
  pub clsid: CLSID,
  pub grfFlags: DWORD,
  pub mtime: FILETIME,
  pub ctime: FILETIME,
  pub atime: FILETIME,
  pub dwOSVersion: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTATPROPSETSTG() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATPROPSETSTG>(),
    64usize,
    concat!("Size of: ", stringify!(tagSTATPROPSETSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATPROPSETSTG>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTATPROPSETSTG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).fmtid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(fmtid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).clsid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(clsid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).grfFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(grfFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).mtime as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(mtime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).ctime as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(ctime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).atime as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(atime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).dwOSVersion as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(dwOSVersion)
    )
  );
}
pub type STATPROPSETSTG = tagSTATPROPSETSTG;
pub type STGFMT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTGOPTIONS {
  pub usVersion: USHORT,
  pub reserved: USHORT,
  pub ulSectorSize: ULONG,
  pub pwcsTemplateFile: *const WCHAR,
}
#[test]
fn bindgen_test_layout_tagSTGOPTIONS() {
  assert_eq!(
    ::std::mem::size_of::<tagSTGOPTIONS>(),
    16usize,
    concat!("Size of: ", stringify!(tagSTGOPTIONS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTGOPTIONS>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTGOPTIONS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).usVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(usVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).ulSectorSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(ulSectorSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).pwcsTemplateFile as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(pwcsTemplateFile)
    )
  );
}
pub type STGOPTIONS = tagSTGOPTIONS;
pub const __MIDL_IInternetSecurityManager_0003_SZM_CREATE: __MIDL_IInternetSecurityManager_0003 = 0;
pub const __MIDL_IInternetSecurityManager_0003_SZM_DELETE: __MIDL_IInternetSecurityManager_0003 = 1;
pub type __MIDL_IInternetSecurityManager_0003 = ::std::os::raw::c_int;
pub use self::__MIDL_IInternetSecurityManager_0003 as SZM_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagSOFTDISTINFO {
  pub cbSize: ULONG,
  pub dwFlags: DWORD,
  pub dwAdState: DWORD,
  pub szTitle: LPWSTR,
  pub szAbstract: LPWSTR,
  pub szHREF: LPWSTR,
  pub dwInstalledVersionMS: DWORD,
  pub dwInstalledVersionLS: DWORD,
  pub dwUpdateVersionMS: DWORD,
  pub dwUpdateVersionLS: DWORD,
  pub dwAdvertisedVersionMS: DWORD,
  pub dwAdvertisedVersionLS: DWORD,
  pub dwReserved: DWORD,
}
#[test]
fn bindgen_test_layout__tagSOFTDISTINFO() {
  assert_eq!(
    ::std::mem::size_of::<_tagSOFTDISTINFO>(),
    72usize,
    concat!("Size of: ", stringify!(_tagSOFTDISTINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_tagSOFTDISTINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_tagSOFTDISTINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwAdState as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwAdState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).szTitle as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(szTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).szAbstract as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(szAbstract)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).szHREF as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(szHREF)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwInstalledVersionMS as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwInstalledVersionMS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwInstalledVersionLS as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwInstalledVersionLS)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwUpdateVersionMS as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwUpdateVersionMS)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwUpdateVersionLS as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwUpdateVersionLS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwAdvertisedVersionMS as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwAdvertisedVersionMS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwAdvertisedVersionLS as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwAdvertisedVersionLS)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwReserved as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwReserved)
    )
  );
}
pub type SOFTDISTINFO = _tagSOFTDISTINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALIZEDPROPERTYVALUE {
  pub dwType: DWORD,
  pub rgb: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagSERIALIZEDPROPERTYVALUE() {
  assert_eq!(
    ::std::mem::size_of::<tagSERIALIZEDPROPERTYVALUE>(),
    8usize,
    concat!("Size of: ", stringify!(tagSERIALIZEDPROPERTYVALUE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSERIALIZEDPROPERTYVALUE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSERIALIZEDPROPERTYVALUE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALIZEDPROPERTYVALUE>())).dwType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALIZEDPROPERTYVALUE),
      "::",
      stringify!(dwType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALIZEDPROPERTYVALUE>())).rgb as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALIZEDPROPERTYVALUE),
      "::",
      stringify!(rgb)
    )
  );
}
pub type SERIALIZEDPROPERTYVALUE = tagSERIALIZEDPROPERTYVALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SERVICE_TRIGGER_CUSTOM_STATE_ID {
  pub Data: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout_SERVICE_TRIGGER_CUSTOM_STATE_ID() {
  assert_eq!(
    ::std::mem::size_of::<SERVICE_TRIGGER_CUSTOM_STATE_ID>(),
    8usize,
    concat!("Size of: ", stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID))
  );
  assert_eq!(
    ::std::mem::align_of::<SERVICE_TRIGGER_CUSTOM_STATE_ID>(),
    4usize,
    concat!("Alignment of ", stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SERVICE_TRIGGER_CUSTOM_STATE_ID>())).Data as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID),
      "::",
      stringify!(Data)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
  pub u: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1 {
  pub CustomStateId: SERVICE_TRIGGER_CUSTOM_STATE_ID,
  pub s: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1 {
  pub DataOffset: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1>(
    ),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1>(
    ),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<
        _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
      >()))
      .DataOffset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(DataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<
        _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
      >()))
      .Data as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Data)
    )
  );
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>()))
        .CustomStateId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1),
      "::",
      stringify!(CustomStateId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>())).s
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1),
      "::",
      stringify!(s)
    )
  );
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>())).u as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM),
      "::",
      stringify!(u)
    )
  );
}
pub type SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM =
  _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DESCRIPTIONA {
  pub lpDescription: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_DESCRIPTIONA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_DESCRIPTIONA>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_DESCRIPTIONA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_DESCRIPTIONA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_DESCRIPTIONA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_DESCRIPTIONA>())).lpDescription as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DESCRIPTIONA),
      "::",
      stringify!(lpDescription)
    )
  );
}
pub type SERVICE_DESCRIPTIONA = _SERVICE_DESCRIPTIONA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DESCRIPTIONW {
  pub lpDescription: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_DESCRIPTIONW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_DESCRIPTIONW>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_DESCRIPTIONW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_DESCRIPTIONW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_DESCRIPTIONW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_DESCRIPTIONW>())).lpDescription as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DESCRIPTIONW),
      "::",
      stringify!(lpDescription)
    )
  );
}
pub type SERVICE_DESCRIPTIONW = _SERVICE_DESCRIPTIONW;
pub type SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONW;
pub const _SC_ACTION_TYPE_SC_ACTION_NONE: _SC_ACTION_TYPE = 0;
pub const _SC_ACTION_TYPE_SC_ACTION_RESTART: _SC_ACTION_TYPE = 1;
pub const _SC_ACTION_TYPE_SC_ACTION_REBOOT: _SC_ACTION_TYPE = 2;
pub const _SC_ACTION_TYPE_SC_ACTION_RUN_COMMAND: _SC_ACTION_TYPE = 3;
pub const _SC_ACTION_TYPE_SC_ACTION_OWN_RESTART: _SC_ACTION_TYPE = 4;
pub type _SC_ACTION_TYPE = ::std::os::raw::c_int;
pub use self::_SC_ACTION_TYPE as SC_ACTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SC_ACTION {
  pub Type: SC_ACTION_TYPE,
  pub Delay: DWORD,
}
#[test]
fn bindgen_test_layout__SC_ACTION() {
  assert_eq!(
    ::std::mem::size_of::<_SC_ACTION>(),
    8usize,
    concat!("Size of: ", stringify!(_SC_ACTION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SC_ACTION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SC_ACTION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SC_ACTION>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SC_ACTION),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SC_ACTION>())).Delay as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SC_ACTION),
      "::",
      stringify!(Delay)
    )
  );
}
pub type SC_ACTION = _SC_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONSA {
  pub dwResetPeriod: DWORD,
  pub lpRebootMsg: LPSTR,
  pub lpCommand: LPSTR,
  pub cActions: DWORD,
  pub lpsaActions: *mut SC_ACTION,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONSA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_FAILURE_ACTIONSA>(),
    40usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONSA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_FAILURE_ACTIONSA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONSA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).dwResetPeriod as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(dwResetPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpRebootMsg as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpRebootMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpCommand as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).cActions as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(cActions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpsaActions as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpsaActions)
    )
  );
}
pub type SERVICE_FAILURE_ACTIONSA = _SERVICE_FAILURE_ACTIONSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONSW {
  pub dwResetPeriod: DWORD,
  pub lpRebootMsg: LPWSTR,
  pub lpCommand: LPWSTR,
  pub cActions: DWORD,
  pub lpsaActions: *mut SC_ACTION,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONSW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_FAILURE_ACTIONSW>(),
    40usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONSW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_FAILURE_ACTIONSW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONSW))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).dwResetPeriod as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(dwResetPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpRebootMsg as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpRebootMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpCommand as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).cActions as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(cActions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpsaActions as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpsaActions)
    )
  );
}
pub type SERVICE_FAILURE_ACTIONSW = _SERVICE_FAILURE_ACTIONSW;
pub type SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DELAYED_AUTO_START_INFO {
  pub fDelayedAutostart: BOOL,
}
#[test]
fn bindgen_test_layout__SERVICE_DELAYED_AUTO_START_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_DELAYED_AUTO_START_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_DELAYED_AUTO_START_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_DELAYED_AUTO_START_INFO>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_DELAYED_AUTO_START_INFO)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_DELAYED_AUTO_START_INFO>())).fDelayedAutostart as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DELAYED_AUTO_START_INFO),
      "::",
      stringify!(fDelayedAutostart)
    )
  );
}
pub type SERVICE_DELAYED_AUTO_START_INFO = _SERVICE_DELAYED_AUTO_START_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONS_FLAG {
  pub fFailureActionsOnNonCrashFailures: BOOL,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONS_FLAG() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_FAILURE_ACTIONS_FLAG>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONS_FLAG))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_FAILURE_ACTIONS_FLAG>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONS_FLAG))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONS_FLAG>())).fFailureActionsOnNonCrashFailures
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONS_FLAG),
      "::",
      stringify!(fFailureActionsOnNonCrashFailures)
    )
  );
}
pub type SERVICE_FAILURE_ACTIONS_FLAG = _SERVICE_FAILURE_ACTIONS_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_SID_INFO {
  pub dwServiceSidType: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_SID_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_SID_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_SID_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_SID_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_SID_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_SID_INFO>())).dwServiceSidType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_SID_INFO),
      "::",
      stringify!(dwServiceSidType)
    )
  );
}
pub type SERVICE_SID_INFO = _SERVICE_SID_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
  pub pmszRequiredPrivileges: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_REQUIRED_PRIVILEGES_INFOA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>())).pmszRequiredPrivileges
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA),
      "::",
      stringify!(pmszRequiredPrivileges)
    )
  );
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOA = _SERVICE_REQUIRED_PRIVILEGES_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
  pub pmszRequiredPrivileges: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_REQUIRED_PRIVILEGES_INFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>())).pmszRequiredPrivileges
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW),
      "::",
      stringify!(pmszRequiredPrivileges)
    )
  );
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOW = _SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub type SERVICE_REQUIRED_PRIVILEGES_INFO = SERVICE_REQUIRED_PRIVILEGES_INFOW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_PRESHUTDOWN_INFO {
  pub dwPreshutdownTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_PRESHUTDOWN_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_PRESHUTDOWN_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_PRESHUTDOWN_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_PRESHUTDOWN_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_PRESHUTDOWN_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_PRESHUTDOWN_INFO>())).dwPreshutdownTimeout as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PRESHUTDOWN_INFO),
      "::",
      stringify!(dwPreshutdownTimeout)
    )
  );
}
pub type SERVICE_PRESHUTDOWN_INFO = _SERVICE_PRESHUTDOWN_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
  pub dwDataType: DWORD,
  pub cbData: DWORD,
  pub pData: PBYTE,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER_SPECIFIC_DATA_ITEM() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).dwDataType as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(dwDataType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).cbData as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).pData as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(pData)
    )
  );
}
pub type SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
pub type PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM = *mut _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER {
  pub dwTriggerType: DWORD,
  pub dwAction: DWORD,
  pub pTriggerSubtype: *mut GUID,
  pub cDataItems: DWORD,
  pub pDataItems: PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TRIGGER>(),
    32usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TRIGGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TRIGGER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).dwTriggerType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(dwTriggerType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).dwAction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(dwAction)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).pTriggerSubtype as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(pTriggerSubtype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).cDataItems as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(cDataItems)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).pDataItems as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(pDataItems)
    )
  );
}
pub type SERVICE_TRIGGER = _SERVICE_TRIGGER;
pub type PSERVICE_TRIGGER = *mut _SERVICE_TRIGGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER_INFO {
  pub cTriggers: DWORD,
  pub pTriggers: PSERVICE_TRIGGER,
  pub pReserved: PBYTE,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TRIGGER_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TRIGGER_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TRIGGER_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER_INFO>())).cTriggers as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(cTriggers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER_INFO>())).pTriggers as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(pTriggers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER_INFO>())).pReserved as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(pReserved)
    )
  );
}
pub type SERVICE_TRIGGER_INFO = _SERVICE_TRIGGER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_PREFERRED_NODE_INFO {
  pub usPreferredNode: USHORT,
  pub fDelete: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SERVICE_PREFERRED_NODE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_PREFERRED_NODE_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_PREFERRED_NODE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_PREFERRED_NODE_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_SERVICE_PREFERRED_NODE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_PREFERRED_NODE_INFO>())).usPreferredNode as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PREFERRED_NODE_INFO),
      "::",
      stringify!(usPreferredNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_PREFERRED_NODE_INFO>())).fDelete as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PREFERRED_NODE_INFO),
      "::",
      stringify!(fDelete)
    )
  );
}
pub type SERVICE_PREFERRED_NODE_INFO = _SERVICE_PREFERRED_NODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_TIMECHANGE_INFO {
  pub liNewTime: LARGE_INTEGER,
  pub liOldTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__SERVICE_TIMECHANGE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TIMECHANGE_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TIMECHANGE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TIMECHANGE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TIMECHANGE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TIMECHANGE_INFO>())).liNewTime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TIMECHANGE_INFO),
      "::",
      stringify!(liNewTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TIMECHANGE_INFO>())).liOldTime as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TIMECHANGE_INFO),
      "::",
      stringify!(liOldTime)
    )
  );
}
pub type SERVICE_TIMECHANGE_INFO = _SERVICE_TIMECHANGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_LAUNCH_PROTECTED_INFO {
  pub dwLaunchProtected: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_LAUNCH_PROTECTED_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_LAUNCH_PROTECTED_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_LAUNCH_PROTECTED_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_LAUNCH_PROTECTED_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_LAUNCH_PROTECTED_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_LAUNCH_PROTECTED_INFO>())).dwLaunchProtected as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_LAUNCH_PROTECTED_INFO),
      "::",
      stringify!(dwLaunchProtected)
    )
  );
}
pub type SERVICE_LAUNCH_PROTECTED_INFO = _SERVICE_LAUNCH_PROTECTED_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SC_HANDLE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SC_HANDLE__() {
  assert_eq!(
    ::std::mem::size_of::<SC_HANDLE__>(),
    4usize,
    concat!("Size of: ", stringify!(SC_HANDLE__))
  );
  assert_eq!(
    ::std::mem::align_of::<SC_HANDLE__>(),
    4usize,
    concat!("Alignment of ", stringify!(SC_HANDLE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SC_HANDLE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SC_HANDLE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type SC_HANDLE = *mut SC_HANDLE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SERVICE_STATUS_HANDLE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SERVICE_STATUS_HANDLE__() {
  assert_eq!(
    ::std::mem::size_of::<SERVICE_STATUS_HANDLE__>(),
    4usize,
    concat!("Size of: ", stringify!(SERVICE_STATUS_HANDLE__))
  );
  assert_eq!(
    ::std::mem::align_of::<SERVICE_STATUS_HANDLE__>(),
    4usize,
    concat!("Alignment of ", stringify!(SERVICE_STATUS_HANDLE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SERVICE_STATUS_HANDLE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SERVICE_STATUS_HANDLE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type SERVICE_STATUS_HANDLE = *mut SERVICE_STATUS_HANDLE__;
pub const _SC_STATUS_TYPE_SC_STATUS_PROCESS_INFO: _SC_STATUS_TYPE = 0;
pub type _SC_STATUS_TYPE = ::std::os::raw::c_int;
pub use self::_SC_STATUS_TYPE as SC_STATUS_TYPE;
pub const _SC_ENUM_TYPE_SC_ENUM_PROCESS_INFO: _SC_ENUM_TYPE = 0;
pub type _SC_ENUM_TYPE = ::std::os::raw::c_int;
pub use self::_SC_ENUM_TYPE as SC_ENUM_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_STATUS {
  pub dwServiceType: DWORD,
  pub dwCurrentState: DWORD,
  pub dwControlsAccepted: DWORD,
  pub dwWin32ExitCode: DWORD,
  pub dwServiceSpecificExitCode: DWORD,
  pub dwCheckPoint: DWORD,
  pub dwWaitHint: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_STATUS>(),
    28usize,
    concat!("Size of: ", stringify!(_SERVICE_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwServiceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwCurrentState as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwControlsAccepted as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwControlsAccepted)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwWin32ExitCode as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwWin32ExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwServiceSpecificExitCode as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwServiceSpecificExitCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwCheckPoint as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwCheckPoint)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwWaitHint as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwWaitHint)
    )
  );
}
pub type SERVICE_STATUS = _SERVICE_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_STATUS_PROCESS {
  pub dwServiceType: DWORD,
  pub dwCurrentState: DWORD,
  pub dwControlsAccepted: DWORD,
  pub dwWin32ExitCode: DWORD,
  pub dwServiceSpecificExitCode: DWORD,
  pub dwCheckPoint: DWORD,
  pub dwWaitHint: DWORD,
  pub dwProcessId: DWORD,
  pub dwServiceFlags: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS_PROCESS() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_STATUS_PROCESS>(),
    36usize,
    concat!("Size of: ", stringify!(_SERVICE_STATUS_PROCESS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_STATUS_PROCESS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_STATUS_PROCESS))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwCurrentState as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwControlsAccepted as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwControlsAccepted)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwWin32ExitCode as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwWin32ExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceSpecificExitCode as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceSpecificExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwCheckPoint as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwCheckPoint)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwWaitHint as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwWaitHint)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwProcessId as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwProcessId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceFlags as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceFlags)
    )
  );
}
pub type SERVICE_STATUS_PROCESS = _SERVICE_STATUS_PROCESS;
pub type SC_LOCK = LPVOID;
pub type LPSERVICE_MAIN_FUNCTIONW = ::std::option::Option<
  unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPWSTR),
>;
pub type LPSERVICE_MAIN_FUNCTIONA = ::std::option::Option<
  unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPSTR),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TABLE_ENTRYA {
  pub lpServiceName: LPSTR,
  pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONA,
}
#[test]
fn bindgen_test_layout__SERVICE_TABLE_ENTRYA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TABLE_ENTRYA>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TABLE_ENTRYA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TABLE_ENTRYA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TABLE_ENTRYA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYA>())).lpServiceName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYA),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYA>())).lpServiceProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYA),
      "::",
      stringify!(lpServiceProc)
    )
  );
}
pub type SERVICE_TABLE_ENTRYA = _SERVICE_TABLE_ENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TABLE_ENTRYW {
  pub lpServiceName: LPWSTR,
  pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONW,
}
#[test]
fn bindgen_test_layout__SERVICE_TABLE_ENTRYW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TABLE_ENTRYW>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TABLE_ENTRYW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TABLE_ENTRYW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TABLE_ENTRYW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYW>())).lpServiceName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYW),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYW>())).lpServiceProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYW),
      "::",
      stringify!(lpServiceProc)
    )
  );
}
pub type SERVICE_TABLE_ENTRYW = _SERVICE_TABLE_ENTRYW;
pub type SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYW;
pub type PFN_SC_NOTIFY_CALLBACK = ::std::option::Option<unsafe extern "C" fn(pParameter: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_1 {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_1() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_NOTIFY_1>(),
    64usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_NOTIFY_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).pfnNotifyCallback as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
pub type SERVICE_NOTIFY_1 = _SERVICE_NOTIFY_1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_2A {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
  pub dwNotificationTriggered: DWORD,
  pub pszServiceNames: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_2A() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_NOTIFY_2A>(),
    80usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_2A))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_NOTIFY_2A>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_2A))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).pfnNotifyCallback as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(ServiceStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).dwNotificationTriggered as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwNotificationTriggered)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).pszServiceNames as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pszServiceNames)
    )
  );
}
pub type SERVICE_NOTIFY_2A = _SERVICE_NOTIFY_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_2W {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
  pub dwNotificationTriggered: DWORD,
  pub pszServiceNames: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_2W() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_NOTIFY_2W>(),
    80usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_2W))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_NOTIFY_2W>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_2W))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).pfnNotifyCallback as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(ServiceStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).dwNotificationTriggered as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwNotificationTriggered)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).pszServiceNames as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pszServiceNames)
    )
  );
}
pub type SERVICE_NOTIFY_2W = _SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY_2 = SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFYA = SERVICE_NOTIFY_2A;
pub type SERVICE_NOTIFYW = SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY = SERVICE_NOTIFYW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
  pub dwReason: DWORD,
  pub pszComment: LPSTR,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_CONTROL_STATUS_REASON_PARAMSA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).dwReason as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(dwReason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).pszComment as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(pszComment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).ServiceStatus as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSA = _SERVICE_CONTROL_STATUS_REASON_PARAMSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
  pub dwReason: DWORD,
  pub pszComment: LPWSTR,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_CONTROL_STATUS_REASON_PARAMSW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).dwReason as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(dwReason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).pszComment as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(pszComment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).ServiceStatus as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSW = _SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub type SERVICE_CONTROL_STATUS_REASON_PARAMS = SERVICE_CONTROL_STATUS_REASON_PARAMSW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_START_REASON {
  pub dwReason: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_START_REASON() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_START_REASON>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_START_REASON))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_START_REASON>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_START_REASON))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_START_REASON>())).dwReason as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_START_REASON),
      "::",
      stringify!(dwReason)
    )
  );
}
pub type SERVICE_START_REASON = _SERVICE_START_REASON;
pub const _SC_EVENT_TYPE_SC_EVENT_DATABASE_CHANGE: _SC_EVENT_TYPE = 0;
pub const _SC_EVENT_TYPE_SC_EVENT_PROPERTY_CHANGE: _SC_EVENT_TYPE = 1;
pub const _SC_EVENT_TYPE_SC_EVENT_STATUS_CHANGE: _SC_EVENT_TYPE = 2;
pub type _SC_EVENT_TYPE = ::std::os::raw::c_int;
pub use self::_SC_EVENT_TYPE as SC_EVENT_TYPE;
pub const SERVICE_REGISTRY_STATE_TYPE_ServiceRegistryStateParameters: SERVICE_REGISTRY_STATE_TYPE =
  0;
pub const SERVICE_REGISTRY_STATE_TYPE_ServiceRegistryStatePersistent: SERVICE_REGISTRY_STATE_TYPE =
  1;
pub const SERVICE_REGISTRY_STATE_TYPE_MaxServiceRegistryStateType: SERVICE_REGISTRY_STATE_TYPE = 2;
pub type SERVICE_REGISTRY_STATE_TYPE = ::std::os::raw::c_int;
pub const SERVICE_DIRECTORY_TYPE_ServiceDirectoryPersistentState: SERVICE_DIRECTORY_TYPE = 0;
pub const SERVICE_DIRECTORY_TYPE_ServiceDirectoryTypeMax: SERVICE_DIRECTORY_TYPE = 1;
pub type SERVICE_DIRECTORY_TYPE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLEBUFA {
  pub dwStyle: DWORD,
  pub szDescription: [CHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagSTYLEBUFA() {
  assert_eq!(
    ::std::mem::size_of::<tagSTYLEBUFA>(),
    36usize,
    concat!("Size of: ", stringify!(tagSTYLEBUFA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTYLEBUFA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLEBUFA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFA>())).dwStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFA),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFA>())).szDescription as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFA),
      "::",
      stringify!(szDescription)
    )
  );
}
pub type STYLEBUFA = tagSTYLEBUFA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLEBUFW {
  pub dwStyle: DWORD,
  pub szDescription: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagSTYLEBUFW() {
  assert_eq!(
    ::std::mem::size_of::<tagSTYLEBUFW>(),
    68usize,
    concat!("Size of: ", stringify!(tagSTYLEBUFW))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTYLEBUFW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLEBUFW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFW>())).dwStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFW),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFW>())).szDescription as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFW),
      "::",
      stringify!(szDescription)
    )
  );
}
pub type STYLEBUFW = tagSTYLEBUFW;
pub type STYLEBUF = STYLEBUFW;
pub const _SFileInfoClass_SFileMpqFileName: _SFileInfoClass = 0;
pub const _SFileInfoClass_SFileMpqStreamBitmap: _SFileInfoClass = 1;
pub const _SFileInfoClass_SFileMpqUserDataOffset: _SFileInfoClass = 2;
pub const _SFileInfoClass_SFileMpqUserDataHeader: _SFileInfoClass = 3;
pub const _SFileInfoClass_SFileMpqUserData: _SFileInfoClass = 4;
pub const _SFileInfoClass_SFileMpqHeaderOffset: _SFileInfoClass = 5;
pub const _SFileInfoClass_SFileMpqHeaderSize: _SFileInfoClass = 6;
pub const _SFileInfoClass_SFileMpqHeader: _SFileInfoClass = 7;
pub const _SFileInfoClass_SFileMpqHetTableOffset: _SFileInfoClass = 8;
pub const _SFileInfoClass_SFileMpqHetTableSize: _SFileInfoClass = 9;
pub const _SFileInfoClass_SFileMpqHetHeader: _SFileInfoClass = 10;
pub const _SFileInfoClass_SFileMpqHetTable: _SFileInfoClass = 11;
pub const _SFileInfoClass_SFileMpqBetTableOffset: _SFileInfoClass = 12;
pub const _SFileInfoClass_SFileMpqBetTableSize: _SFileInfoClass = 13;
pub const _SFileInfoClass_SFileMpqBetHeader: _SFileInfoClass = 14;
pub const _SFileInfoClass_SFileMpqBetTable: _SFileInfoClass = 15;
pub const _SFileInfoClass_SFileMpqHashTableOffset: _SFileInfoClass = 16;
pub const _SFileInfoClass_SFileMpqHashTableSize64: _SFileInfoClass = 17;
pub const _SFileInfoClass_SFileMpqHashTableSize: _SFileInfoClass = 18;
pub const _SFileInfoClass_SFileMpqHashTable: _SFileInfoClass = 19;
pub const _SFileInfoClass_SFileMpqBlockTableOffset: _SFileInfoClass = 20;
pub const _SFileInfoClass_SFileMpqBlockTableSize64: _SFileInfoClass = 21;
pub const _SFileInfoClass_SFileMpqBlockTableSize: _SFileInfoClass = 22;
pub const _SFileInfoClass_SFileMpqBlockTable: _SFileInfoClass = 23;
pub const _SFileInfoClass_SFileMpqHiBlockTableOffset: _SFileInfoClass = 24;
pub const _SFileInfoClass_SFileMpqHiBlockTableSize64: _SFileInfoClass = 25;
pub const _SFileInfoClass_SFileMpqHiBlockTable: _SFileInfoClass = 26;
pub const _SFileInfoClass_SFileMpqSignatures: _SFileInfoClass = 27;
pub const _SFileInfoClass_SFileMpqStrongSignatureOffset: _SFileInfoClass = 28;
pub const _SFileInfoClass_SFileMpqStrongSignatureSize: _SFileInfoClass = 29;
pub const _SFileInfoClass_SFileMpqStrongSignature: _SFileInfoClass = 30;
pub const _SFileInfoClass_SFileMpqArchiveSize64: _SFileInfoClass = 31;
pub const _SFileInfoClass_SFileMpqArchiveSize: _SFileInfoClass = 32;
pub const _SFileInfoClass_SFileMpqMaxFileCount: _SFileInfoClass = 33;
pub const _SFileInfoClass_SFileMpqFileTableSize: _SFileInfoClass = 34;
pub const _SFileInfoClass_SFileMpqSectorSize: _SFileInfoClass = 35;
pub const _SFileInfoClass_SFileMpqNumberOfFiles: _SFileInfoClass = 36;
pub const _SFileInfoClass_SFileMpqRawChunkSize: _SFileInfoClass = 37;
pub const _SFileInfoClass_SFileMpqStreamFlags: _SFileInfoClass = 38;
pub const _SFileInfoClass_SFileMpqFlags: _SFileInfoClass = 39;
pub const _SFileInfoClass_SFileInfoPatchChain: _SFileInfoClass = 40;
pub const _SFileInfoClass_SFileInfoFileEntry: _SFileInfoClass = 41;
pub const _SFileInfoClass_SFileInfoHashEntry: _SFileInfoClass = 42;
pub const _SFileInfoClass_SFileInfoHashIndex: _SFileInfoClass = 43;
pub const _SFileInfoClass_SFileInfoNameHash1: _SFileInfoClass = 44;
pub const _SFileInfoClass_SFileInfoNameHash2: _SFileInfoClass = 45;
pub const _SFileInfoClass_SFileInfoNameHash3: _SFileInfoClass = 46;
pub const _SFileInfoClass_SFileInfoLocale: _SFileInfoClass = 47;
pub const _SFileInfoClass_SFileInfoFileIndex: _SFileInfoClass = 48;
pub const _SFileInfoClass_SFileInfoByteOffset: _SFileInfoClass = 49;
pub const _SFileInfoClass_SFileInfoFileTime: _SFileInfoClass = 50;
pub const _SFileInfoClass_SFileInfoFileSize: _SFileInfoClass = 51;
pub const _SFileInfoClass_SFileInfoCompressedSize: _SFileInfoClass = 52;
pub const _SFileInfoClass_SFileInfoFlags: _SFileInfoClass = 53;
pub const _SFileInfoClass_SFileInfoEncryptionKey: _SFileInfoClass = 54;
pub const _SFileInfoClass_SFileInfoEncryptionKeyRaw: _SFileInfoClass = 55;
pub const _SFileInfoClass_SFileInfoCRC32: _SFileInfoClass = 56;
pub type _SFileInfoClass = ::std::os::raw::c_int;
pub use self::_SFileInfoClass as SFileInfoClass;
pub type SFILE_DOWNLOAD_CALLBACK = ::std::option::Option<
  unsafe extern "C" fn(
    pvUserData: *mut ::std::os::raw::c_void,
    ByteOffset: ULONGLONG,
    dwTotalBytes: DWORD,
  ),
>;
pub type SFILE_ADDFILE_CALLBACK = ::std::option::Option<
  unsafe extern "C" fn(
    pvUserData: *mut ::std::os::raw::c_void,
    dwBytesWritten: DWORD,
    dwTotalBytes: DWORD,
    bFinalCall: bool,
  ),
>;
pub type SFILE_COMPACT_CALLBACK = ::std::option::Option<
  unsafe extern "C" fn(
    pvUserData: *mut ::std::os::raw::c_void,
    dwWorkType: DWORD,
    BytesProcessed: ULONGLONG,
    TotalBytes: ULONGLONG,
  ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SFILE_FIND_DATA {
  pub cFileName: [::std::os::raw::c_char; 260usize],
  pub szPlainName: *mut ::std::os::raw::c_char,
  pub dwHashIndex: DWORD,
  pub dwBlockIndex: DWORD,
  pub dwFileSize: DWORD,
  pub dwFileFlags: DWORD,
  pub dwCompSize: DWORD,
  pub dwFileTimeLo: DWORD,
  pub dwFileTimeHi: DWORD,
  pub lcLocale: LCID,
}
#[test]
fn bindgen_test_layout__SFILE_FIND_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SFILE_FIND_DATA>(),
    304usize,
    concat!("Size of: ", stringify!(_SFILE_FIND_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SFILE_FIND_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SFILE_FIND_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).cFileName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(cFileName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).szPlainName as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(szPlainName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwHashIndex as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwHashIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwBlockIndex as *const _ as usize },
    276usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwBlockIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileSize as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileFlags as *const _ as usize },
    284usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwCompSize as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwCompSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileTimeLo as *const _ as usize },
    292usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileTimeLo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileTimeHi as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileTimeHi)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).lcLocale as *const _ as usize },
    300usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(lcLocale)
    )
  );
}
pub type SFILE_FIND_DATA = _SFILE_FIND_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SFILE_CREATE_MPQ {
  pub cbSize: DWORD,
  pub dwMpqVersion: DWORD,
  pub pvUserData: *mut ::std::os::raw::c_void,
  pub cbUserData: DWORD,
  pub dwStreamFlags: DWORD,
  pub dwFileFlags1: DWORD,
  pub dwFileFlags2: DWORD,
  pub dwFileFlags3: DWORD,
  pub dwAttrFlags: DWORD,
  pub dwSectorSize: DWORD,
  pub dwRawChunkSize: DWORD,
  pub dwMaxFileCount: DWORD,
}
#[test]
fn bindgen_test_layout__SFILE_CREATE_MPQ() {
  assert_eq!(
    ::std::mem::size_of::<_SFILE_CREATE_MPQ>(),
    56usize,
    concat!("Size of: ", stringify!(_SFILE_CREATE_MPQ))
  );
  assert_eq!(
    ::std::mem::align_of::<_SFILE_CREATE_MPQ>(),
    8usize,
    concat!("Alignment of ", stringify!(_SFILE_CREATE_MPQ))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwMpqVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwMpqVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).pvUserData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).cbUserData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(cbUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwStreamFlags as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwStreamFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwFileFlags1 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwFileFlags1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwFileFlags2 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwFileFlags2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwFileFlags3 as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwFileFlags3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwAttrFlags as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwAttrFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwSectorSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwSectorSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwRawChunkSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwRawChunkSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwMaxFileCount as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwMaxFileCount)
    )
  );
}
pub type SFILE_CREATE_MPQ = _SFILE_CREATE_MPQ;
pub type PSFILE_CREATE_MPQ = *mut _SFILE_CREATE_MPQ;
pub type SFILESETLOCALE = ::std::option::Option<unsafe extern "C" fn(arg1: LCID) -> LCID>;
pub type SFILEOPENARCHIVE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *const ::std::os::raw::c_char,
    arg2: DWORD,
    arg3: DWORD,
    arg4: *mut HANDLE,
  ) -> bool,
>;
pub type SFILECLOSEARCHIVE = ::std::option::Option<unsafe extern "C" fn(arg1: HANDLE) -> bool>;
pub type SFILEOPENFILEEX = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: HANDLE,
    arg2: *const ::std::os::raw::c_char,
    arg3: DWORD,
    arg4: *mut HANDLE,
  ) -> bool,
>;
pub type SFILECLOSEFILE = ::std::option::Option<unsafe extern "C" fn(arg1: HANDLE) -> bool>;
pub type SFILEGETFILESIZE =
  ::std::option::Option<unsafe extern "C" fn(arg1: HANDLE, arg2: LPDWORD) -> DWORD>;
pub type SFILESETFILEPOINTER = ::std::option::Option<
  unsafe extern "C" fn(arg1: HANDLE, arg2: LONG, arg3: *mut LONG, arg4: DWORD) -> DWORD,
>;
pub type SFILEREADFILE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: HANDLE,
    arg2: *mut ::std::os::raw::c_void,
    arg3: DWORD,
    arg4: LPDWORD,
    arg5: LPOVERLAPPED,
  ) -> bool,
>;
extern "C" {
  pub fn SFileGetLocale() -> LCID;
}
extern "C" {
  pub fn SFileSetLocale(lcNewLocale: LCID) -> LCID;
}
extern "C" {
  pub fn SFileOpenArchive(
    szMpqName: *const TCHAR,
    dwPriority: DWORD,
    dwFlags: DWORD,
    phMpq: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileCreateArchive(
    szMpqName: *const TCHAR,
    dwCreateFlags: DWORD,
    dwMaxFileCount: DWORD,
    phMpq: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileCreateArchive2(
    szMpqName: *const TCHAR,
    pCreateInfo: PSFILE_CREATE_MPQ,
    phMpq: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileSetDownloadCallback(
    hMpq: HANDLE,
    DownloadCB: SFILE_DOWNLOAD_CALLBACK,
    pvUserData: *mut ::std::os::raw::c_void,
  ) -> bool;
}
extern "C" {
  pub fn SFileFlushArchive(hMpq: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileCloseArchive(hMpq: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileAddListFile(hMpq: HANDLE, szListFile: *const TCHAR) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SFileSetCompactCallback(
    hMpq: HANDLE,
    CompactCB: SFILE_COMPACT_CALLBACK,
    pvUserData: *mut ::std::os::raw::c_void,
  ) -> bool;
}
extern "C" {
  pub fn SFileCompactArchive(hMpq: HANDLE, szListFile: *const TCHAR, bReserved: bool) -> bool;
}
extern "C" {
  pub fn SFileGetMaxFileCount(hMpq: HANDLE) -> DWORD;
}
extern "C" {
  pub fn SFileSetMaxFileCount(hMpq: HANDLE, dwMaxFileCount: DWORD) -> bool;
}
extern "C" {
  pub fn SFileGetAttributes(hMpq: HANDLE) -> DWORD;
}
extern "C" {
  pub fn SFileSetAttributes(hMpq: HANDLE, dwFlags: DWORD) -> bool;
}
extern "C" {
  pub fn SFileUpdateFileAttributes(hMpq: HANDLE, szFileName: *const ::std::os::raw::c_char)
    -> bool;
}
extern "C" {
  pub fn SFileOpenPatchArchive(
    hMpq: HANDLE,
    szPatchMpqName: *const TCHAR,
    szPatchPathPrefix: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileIsPatchedArchive(hMpq: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileHasFile(hMpq: HANDLE, szFileName: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
  pub fn SFileOpenFileEx(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    dwSearchScope: DWORD,
    phFile: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileGetFileSize(hFile: HANDLE, pdwFileSizeHigh: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn SFileSetFilePointer(
    hFile: HANDLE,
    lFilePos: LONG,
    plFilePosHigh: *mut LONG,
    dwMoveMethod: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SFileReadFile(
    hFile: HANDLE,
    lpBuffer: *mut ::std::os::raw::c_void,
    dwToRead: DWORD,
    pdwRead: LPDWORD,
    lpOverlapped: LPOVERLAPPED,
  ) -> bool;
}
extern "C" {
  pub fn SFileCloseFile(hFile: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileGetFileInfo(
    hMpqOrFile: HANDLE,
    InfoClass: SFileInfoClass,
    pvFileInfo: *mut ::std::os::raw::c_void,
    cbFileInfo: DWORD,
    pcbLengthNeeded: LPDWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileGetFileName(hFile: HANDLE, szFileName: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
  pub fn SFileFreeFileInfo(
    pvFileInfo: *mut ::std::os::raw::c_void,
    InfoClass: SFileInfoClass,
  ) -> bool;
}
extern "C" {
  pub fn SFileExtractFile(
    hMpq: HANDLE,
    szToExtract: *const ::std::os::raw::c_char,
    szExtracted: *const TCHAR,
    dwSearchScope: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileGetFileChecksums(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    pdwCrc32: LPDWORD,
    pMD5: *mut ::std::os::raw::c_char,
  ) -> bool;
}
extern "C" {
  pub fn SFileVerifyFile(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SFileVerifyRawData(
    hMpq: HANDLE,
    dwWhatToVerify: DWORD,
    szFileName: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SFileSignArchive(hMpq: HANDLE, dwSignatureType: DWORD) -> bool;
}
extern "C" {
  pub fn SFileVerifyArchive(hMpq: HANDLE) -> DWORD;
}
extern "C" {
  pub fn SFileFindFirstFile(
    hMpq: HANDLE,
    szMask: *const ::std::os::raw::c_char,
    lpFindFileData: *mut SFILE_FIND_DATA,
    szListFile: *const TCHAR,
  ) -> HANDLE;
}
extern "C" {
  pub fn SFileFindNextFile(hFind: HANDLE, lpFindFileData: *mut SFILE_FIND_DATA) -> bool;
}
extern "C" {
  pub fn SFileFindClose(hFind: HANDLE) -> bool;
}
extern "C" {
  pub fn SListFileFindFirstFile(
    hMpq: HANDLE,
    szListFile: *const TCHAR,
    szMask: *const ::std::os::raw::c_char,
    lpFindFileData: *mut SFILE_FIND_DATA,
  ) -> HANDLE;
}
extern "C" {
  pub fn SListFileFindNextFile(hFind: HANDLE, lpFindFileData: *mut SFILE_FIND_DATA) -> bool;
}
extern "C" {
  pub fn SListFileFindClose(hFind: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileEnumLocales(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    plcLocales: *mut LCID,
    pdwMaxLocales: LPDWORD,
    dwSearchScope: DWORD,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SFileCreateFile(
    hMpq: HANDLE,
    szArchivedName: *const ::std::os::raw::c_char,
    FileTime: ULONGLONG,
    dwFileSize: DWORD,
    lcLocale: LCID,
    dwFlags: DWORD,
    phFile: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileWriteFile(
    hFile: HANDLE,
    pvData: *const ::std::os::raw::c_void,
    dwSize: DWORD,
    dwCompression: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileFinishFile(hFile: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileAddFileEx(
    hMpq: HANDLE,
    szFileName: *const TCHAR,
    szArchivedName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
    dwCompression: DWORD,
    dwCompressionNext: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileAddFile(
    hMpq: HANDLE,
    szFileName: *const TCHAR,
    szArchivedName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileAddWave(
    hMpq: HANDLE,
    szFileName: *const TCHAR,
    szArchivedName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
    dwQuality: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileRemoveFile(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    dwSearchScope: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileRenameFile(
    hMpq: HANDLE,
    szOldFileName: *const ::std::os::raw::c_char,
    szNewFileName: *const ::std::os::raw::c_char,
  ) -> bool;
}
extern "C" {
  pub fn SFileSetFileLocale(hFile: HANDLE, lcNewLocale: LCID) -> bool;
}
extern "C" {
  pub fn SFileSetDataCompression(DataCompression: DWORD) -> bool;
}
extern "C" {
  pub fn SFileSetAddFileCallback(
    hMpq: HANDLE,
    AddFileCB: SFILE_ADDFILE_CALLBACK,
    pvUserData: *mut ::std::os::raw::c_void,
  ) -> bool;
}
extern "C" {
  pub fn SCompImplode(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompExplode(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompCompress(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
    uCompressionMask: ::std::os::raw::c_uint,
    nCmpType: ::std::os::raw::c_int,
    nCmpLevel: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompDecompress(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompDecompress2(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
